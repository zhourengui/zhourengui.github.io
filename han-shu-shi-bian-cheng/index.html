<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>函数式编程 | LittleBoy-前端爱好者</title>
<meta name="description" content="一位前端爱好者的大前端养成记" />
<link rel="shortcut icon" href="https://github.com/zhourengui/zhourengui.github.io/favicon.ico">
<link rel="stylesheet" href="https://github.com/zhourengui/zhourengui.github.io/styles/main.css">

<script src="https://github.com/zhourengui/zhourengui.github.io/media/js/jquery.min.js"></script>
<script src="https://github.com/zhourengui/zhourengui.github.io/media/js/masonry.pkgd.min.js"></script>
<script src="https://github.com/zhourengui/zhourengui.github.io/media/js/aos.js"></script>
<script src="https://github.com/zhourengui/zhourengui.github.io/media/js/pace.min.js"></script>
<script src="https://github.com/zhourengui/zhourengui.github.io/media/js/view-image.min.js"></script>
<script src="https://github.com/zhourengui/zhourengui.github.io/media/js/jquery.magnific-popup.min.js"></script>
<script src="https://github.com/zhourengui/zhourengui.github.io/media/js/functions.js"></script>
    <meta name="referrer" content="never">
    <meta name="description" content="前言：
函数式编程是编程范式中的一种，是一种典型的编程思想和方法。其他的编程范式还包括面向对象编程、逻辑编程等。
函数式编程不是用函数来编程， 也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数。运算过程尽量写成一系列嵌套的函数..." />
    <meta name="keywords" content="JavaScript" />
    <script src="https://github.com/zhourengui/zhourengui.github.io/media/js/waterfall.min.js"></script>
    <script src="https://github.com/zhourengui/zhourengui.github.io/media/js/prism.min.js"></script>
  </head>
  <body>
            <header id="header" class="grid-container">
        <!-- start: .menu-wrapper -->
        <div class="menu-mobile"> 
          <i class="fa fa-reorder"></i>
        </div>
        <div class="menu-wrapper">
          <div class="">
            <div class="logo">
              <a href="https://github.com/zhourengui/zhourengui.github.io"><img src="/media/images/custom-headerLogo.png" alt=""></a>
            </div>
            <!-- start: .main-nav -->

            <nav class="main-nav grid-container grid-parent">
              <ul id="menu-header" class="menu gradient-effect">
                <li class=""><a href="https://github.com/zhourengui/zhourengui.github.io" class="menu">首页</a></li>
                
                  <li class="" >
                    <a href="/archives" class="menu">
                      归档
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="/tags" class="menu">
                      标签
                    </a>
                  </li>
                
                <li class="search-menu-item hide-on-mobile hide-on-tablet"><a href="#search-lightbox" class="lightbox mfp-inline"><i class="fa fa-search-line"></i></a></li>
              </ul>
            </nav>
            <a href="#search-lightbox" class="lightbox epcl-search-button mfp-inline hide-on-tablet hide-on-desktop"><i class="fa fa-search-line"></i></a>
            <!-- end: .main-nav -->
            <div class="clear"></div>
            <div class="border hide-on-tablet hide-on-mobile"></div>
          </div>    
          <div class="clear"></div>
        </div>
        <!-- end: .menu-wrapper -->
        <div class="clear"></div>
      </header>
      <div class="hide-on-mobile hide-on-tablet hide-on-desktop">
        <div id="search-lightbox" class="grid-container grid-small grid-parent mfp-hide">
          <div class="search-wrapper section">
            <form id="gridea-search-form" data-update="1598951556317" action="/search/index.html" class="search-form" _lpchecked="1">
              <input type="text" name="q" id="s" value="" class="search-field" placeholder="搜点啥..." aria-label="搜点啥..." required="">
              <button type="submit" class="submit" aria-label="Submit">
                <i class="fa fa-search-line"></i>
              </button>
            </form>
          </div>
        </div>
      </div>

      <main id="single" class="main grid-container fullcover no-sidebar aos-init aos-animate" data-aos="fade">

        <div class="center content">
          <div class="featured-image cover" style="background-image: url('https://raw.githubusercontent.com/zhourengui/blog-image/master/function-programming.png');">
            <div class="meta top"> 
              <time class="meta-info" style="float:left;" datetime="2020-08-28"><i class="fa fa-calendar"></i><span class="lately">4 天前</span></time>
              
              <a href="https://github.com/zhourengui/zhourengui.github.io/han-shu-shi-bian-cheng/#comments" class="comments meta-info" title="">
                <i class="fa fa-comment remixicon"></i><span class="comment-count valine-comment-count" data-xid="/han-shu-shi-bian-cheng/"> </span>
              </a>
              <span id="/han-shu-shi-bian-cheng/" class="leancloud_visitors views-counter meta-info" title=""><i class="fa fa-leancloud remixicon"></i><span class="leancloud-visitors-count"></span></span>
              
            </div>
            <div class="info">
              <div class="tags ">
                
                      <a href="https://github.com/zhourengui/zhourengui.github.io/b02rvhSHe/" class="ctag ctag-0 ctag-b02rvhSHe" aria-label="">JavaScript</a>
                    
              </div>
              <h1 class="title ularge white bold">函数式编程</h1>
            </div>
          </div>
        </div>  

        <div class="epcl-page-wrapper">
          <div class="left-content grid-70 np-mobile">
            <article class="main-article post">
              <section class="post-content">
                <div class="text">
                  <p>前言：</p>
<p><code>函数式编程</code>是编程范式中的一种，是一种典型的编程思想和方法。其他的编程范式还包括<code>面向对象编程</code>、<code>逻辑编程</code>等。</p>
<p><code>函数式编程</code>不是用函数来编程， 也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数。运算过程尽量写成一系列嵌套的函数调用。</p>
<p><code>函数式编程</code>只是范畴论的运算方法，跟数理逻辑、微积分、 行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。为什么函数式编程要求函数必须是纯的，不能有副作用?因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</p>
<p>为什么要学习<code>函数式编程</code> ? 函数式编程的最大的特点就是<code>纯</code>， 没有任何的副作用，没有任何的依赖，对于代码的review，重构起着重大的作用。（当看过一个耦合度非常高的项目的时候，你会发现函数式编程之美）</p>
<h2 id="一-函数式编程的特点">一. 函数式编程的特点</h2>
<ol>
<li>函数与其他数据类型一样， 可以赋值给其他变量，也可以是参数，传入另一个函数，或者是别的函数的返回值。</li>
<li>只用<code>表达式</code>，不用<code>语句</code></li>
<li>没有<code>副作用</code></li>
<li>不修改状态</li>
<li>函数运行只靠参数</li>
</ol>
<h2 id="二-深入学习函数式编程">二. 深入学习函数式编程</h2>
<h3 id="1-纯函数">1. 纯函数</h3>
<blockquote>
<p>纯函数的特点</p>
</blockquote>
<ol>
<li>相同的输入，会得到相同的输出</li>
<li>没有任何的副作用</li>
<li>不依赖外部环境的状态</li>
</ol>
<blockquote>
<p>通过例子认识纯函数</p>
</blockquote>
<pre><code class="language-js">// 举一个是纯函数的例子：  
const arr = [1, 2, 3, 4, 5]
arr.slice(0, 3) // [1, 2, 3]
arr.slice(0, 3) // [1, 2, 3]
arr.slice(0, 3) // [1, 2, 3]
arr.slice(0, 3) // [1, 2, 3]
</code></pre>
<p><code>slice</code>传入的相同的参数，输出都是相同的，没有任何的依赖，没有任何的副作用（arr数组没有变化），说明<code>Array.ptototype.slice</code>是个纯函数</p>
<pre><code class="language-js">// 举一个不是纯函数的例子：
const minAge = 20
const checkAge = age =&gt; age &gt; minAge
</code></pre>
<p>由于<code>checkAge</code>方法依赖了minAge这个变量，所以<code>checkAge</code>不是纯函数，可以将<code>checkAge</code>修改成<code>const checkage = age =&gt; age &gt; 20</code>。</p>
<blockquote>
<p>问题思考？</p>
</blockquote>
<p>假如需要另一个函数判断传入的年龄是否是大于21，大于22。。。 那不得不重写一个方法，这样一个最大的问题就是拓展性不好。下一节的<code>柯里化函数</code>可以得到答案。</p>
<h3 id="2-柯里化函数">2. 柯里化函数</h3>
<blockquote>
<p>☝️上一节的答案</p>
</blockquote>
<pre><code class="language-js">// 使用柯里化解决上一节的问题
const checkAge = min =&gt; (age =&gt; age &gt; min)
const checkAge21 = checkAge(21)
checkAge21(22)
checkAge21(23)
checkAge21(25)
const checkAge22 = checkAge(22)
checkAge21(22)
</code></pre>
<p><code>checkAge</code>方法与上一节的实现多了一层<code>function</code>, 从举的例子也不难看出，这样的定义非常的灵活，拓展性也非常好。</p>
<blockquote>
<p>柯里化函数的特点</p>
</blockquote>
<p>传递给函数一部分参数，返回另一个函数去处理剩下的参数</p>
<blockquote>
<p>什么是柯里化</p>
</blockquote>
<p><code>柯里化函数</code>是一种“预加载”函数的方法，通过传递较少的参数，返回另一个函数，这个函数通过保留执行期的上下文<code>（闭包）</code>缓存了第一次传入的参数，是一种非常高效的编写函数的方法。</p>
<h3 id="3-函数组合">3. 函数组合</h3>
<blockquote>
<p>什么是函数组合</p>
</blockquote>
<p>需要多个函数有顺序的处理得到的结果，把这些函数合并成一个函数就是函数组合。</p>
<blockquote>
<p>通过例子认识函数组合</p>
</blockquote>
<pre><code class="language-js">const compose = (...fns) =&gt; (...args) =&gt; {
    const fnLength = fns.length
    if (fnLength === 0) return arg =&gt; arg
    if (fnLength === 1) return fns[0](...args)
    return fns.reduce((pre, current = arg =&gt; arg) =&gt; (pre(current(...args))))
}
function fn1(arr) {
    console.log(arr)
}

function fn2(arr) {
    return arr.splice(3)
}
compose(fn1)([1, 2, 3, 4])
</code></pre>
<p>上面定义了一个<code>compose</code>方法，这个方法把传入的所有方法组合起来，方法调用顺序从右向左。</p>
<h3 id="4-point-free">4. Point Free</h3>
<blockquote>
<p>什么是Point Free</p>
</blockquote>
<p>对象自带的防范转化成纯函数，不要命名转瞬即逝的中间变量，这样说可能有点抽象，下面的例子说明的更清楚。</p>
<blockquote>
<p>通过例子认识Point Free</p>
</blockquote>
<p><code>const f = str =&gt; str.toUpperCase().split(' ')</code>这段代码使用了str作为中间变量，这个中间变量除了让代码变得长一点以外毫无意义。</p>
<p>我们可以使用函数组合进行修改</p>
<pre><code class="language-js">const toUpperCase = str =&gt; str.toUpperCase()
const split = x =&gt; (str =&gt; str.split(x))
const f = compose(split(' '), toUpperCase)
f(&quot;test string&quot;)
</code></pre>
<p>这样的编程可以减少不必要的命名，让代码保存简洁和通用。</p>
<h3 id="5-声明式与命令式代码">5. 声明式与命令式代码</h3>
<blockquote>
<p>什么是声明式</p>
</blockquote>
<p>通过编写一条有一条指令去让计算机执行一些操作</p>
<blockquote>
<p>什么是命令式</p>
</blockquote>
<p>通过写表达式的方式来声明要做声明 不是通过一步一步指示</p>
<blockquote>
<p>通过例子认识声明式与命令式代码</p>
</blockquote>
<pre><code class="language-js">// 命令式
const persons  = []
for (let i = 0; i &lt; arr.length; i ++) {
    persons.push(arr[i])
}
// 声明式
const persons = arr.map(p =&gt; p)
</code></pre>
<h3 id="6-惰性求值">6. 惰性求值</h3>
<blockquote>
<p>什么是惰性求值</p>
</blockquote>
<p>一种将对函数或请求处理延迟到真正需要结果时进行的通用概念。有很多应用程序都采用了这种概念，有的非常明显，有些则不太明显。从惰性编程的角度来思考问题，可以帮您消除代码中不必要的计算。</p>
<blockquote>
<p>通过例子认识惰性求值</p>
</blockquote>
<pre><code class="language-js">// 原生js封装ajax
function ajax() {
    //1.创建xhr对象
    //创建xhr对象 - 非IE6
    if (window.XMLHttpRequest) {
        var xhr = new XMLHttpRequest();
    } else { //IE6及其以下版本浏览器
        var xhr = new ActiveXObject('Microsoft.XMLHTTP');
    }
    ...
}
</code></pre>
<p>上面通过原生js封装ajax理解惰性求值，如果我们上面不做任何的处理我们每次调用ajax这个方法的时候，方法内部都会做一次兼容处理，但是呢当第一次调用后，我们就知道了用户的浏览器是否支持ie，所以可以修改如下</p>
<pre><code class="language-js">// 原生js封装ajax
function ajax() {
    //1.创建xhr对象
    //创建xhr对象 - 非IE6
    if (window.XMLHttpRequest) {
        var xhr = new XMLHttpRequest();
    } else { //IE6及其以下版本浏览器
        var xhr = new ActiveXObject('Microsoft.XMLHTTP');
    }
    ajax = xhr
}
</code></pre>
<p>通过这样修改后，当调用一次后<code>ajax=xhr</code>，当第二次调用的时候，就不用去重新判断兼容处理，这样可以提升性能。</p>
<h3 id="7-高阶函数">7. 高阶函数</h3>
<blockquote>
<p>什么是高阶函数</p>
</blockquote>
<p>函数当作参数，把传入的函数做一个封装，然后返回这个封装的函数，达到更高成都的抽象。</p>
<blockquote>
<p>通过例子认识高阶函数</p>
</blockquote>
<pre><code class="language-js">function add(x, y, fn) {
    return fn(x) + fn(y)
}
add(2, 3, (n) =&gt; n * n)
</code></pre>
<p>这就是一个简单的高级函数，只要一个函数接收一个函数作为参数， 这种函数就可以称之为高阶函数。</p>
<h3 id="8-尾递归尾调用">8. 尾递归（尾调用）</h3>
<blockquote>
<p>什么是尾递归</p>
</blockquote>
<p>函数内部的最后一个动作是函数调用。该调用的返回值直接返回给函数。函数调用自身成为递归。如果尾调用自身，就成为尾递归。递归需要保存大量的调用记录, 很容易发生栈溢出错误，如果使用尾递归优化， 将递归变为循环， 那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。</p>
<blockquote>
<p>通过例子认识尾递归（尾调用）</p>
</blockquote>
<pre><code class="language-js">// 斐波那契数列 正常递归
function factorial(n) {
    if (n === 1) return 1
    return n * factorial(n - 1)
}

// 使用尾递归
function factorial(n, total) {
     if (n === 1) return total;
    return factorial(n - 1, n * total);
}
</code></pre>
<blockquote>
<p>尾递归的优点</p>
</blockquote>
<p>整个调用过程是线性的，调用一次后就会进入下一个栈，相关的数据信息跟随进入， 不保留在栈堆上，有效的防止堆栈溢出</p>
<h3 id="9-闭包">9. 闭包</h3>
<blockquote>
<p>什么是闭包?</p>
</blockquote>
<p>在某个块区域保留了父级以及父级以上的执行期上下文，这就是闭包，由于闭包网上有很多的资料，这里不做太多的赘述。</p>
<h3 id="10-容器范畴与函子funcctor">10. 容器（范畴）与函子（Funcctor）</h3>
<blockquote>
<p>什么是范畴</p>
</blockquote>
<ol>
<li>范畴就是容器，容器包含两样东西。值和值的变形关系（函数）</li>
<li>值的变形关系（函数）可以用于同一个容器的转换， 也可以用于将一个容器专程另一个容器。</li>
</ol>
<blockquote>
<p>什么是函子</p>
</blockquote>
<p>函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。他首先是一种范畴，换句话说，函子也是容器，他也包含了容器的两样东西，只不过他的变形关系可以依次作用于每一个值，将当前的容器变形成另一个容器。</p>
<p>函子是一个对于函数调用的抽象， 赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选中何时何地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等特性。</p>
<blockquote>
<p>通过例子认识函子</p>
</blockquote>
<p><strong>函子的特点</strong></p>
<ol>
<li>任何具有map方法的数据结构，都可以当作函子的实现。</li>
<li>函数式编程一般约定，函子（Functor）有一个of方法, 用来生成新 的容器。</li>
<li>函子（Functor）遵守一些特定规则的容器类型。</li>
<li>函子（Functor） 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等特性。</li>
</ol>
<p>根据上面的特点用代码实现</p>
<pre><code class="language-js">class Functor {
    constructor(x) {
        this.__value = x
    }
    // 一般约定，函子的标志就是容器具有map方法。该方法将容器 里面的每一个值，映射到另一个容器。
    map(f) {
        return Functor.of(f(this.__value))
    }
    // 函数式编程一般约定，函子（Functor）有一个of方法
    static of(x) {
        return new Functor(x)
    }
}

// 使用如下
Functor.of(2)
.map(x =&gt; x + 1)  // Functor(3)
.map(x =&gt; x * 2) // Functor(6)
</code></pre>
<p>上面代码中，Functor是一个函子，它的map方法接受函数f作为 参数，然后返回一个新的函子，里面包含的值是被f处理过的 (f(this.val))。<br>
函数式编程里面的运算，都是通过函子完成， 即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口(map方法)，各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。</p>
<h3 id="11-maybe函子">11. Maybe函子</h3>
<blockquote>
<p>什么是Maybe函子</p>
</blockquote>
<p>函子接受各种函数，处理容器内部的值。这里有一个问题，容器内部的值可能是一个空值，而外部函数未必有处理空值的机制，如果传入控制，很可能会报错。Maybe函子就是做这种预处理，让不管传入的值是什么都不会报错</p>
<blockquote>
<p>通过例子认识Maybe函子</p>
</blockquote>
<pre><code class="language-js">class Maybe {
    constructor(x) {
        this.__value = x
    }
    map(f) {
        return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value))
    }
    isNothing() {
        return this.__value === null || this.__value === undefined
    }
    static of(x) {
        return new Maybe(x)
    }
}
</code></pre>
<p>上面的例子map方法里多了一层判断，判断如果传进来的值是空的情况下不会去调用传进去的函数，因为空值没有任何的意义。</p>
<h3 id="12-错误处理-和-either">12. 错误处理 和 Either</h3>
<blockquote>
<p>什么是Either</p>
</blockquote>
<p>程序中常用条件运算符<code>if-else</code>, 但是在函数式编程里面，Either函子内部有两个值：<code>left（左值）</code> 和<code>right(右值)</code>。右值是正常情况下使用的值，左值是右值不存在的时候使用的默认值。</p>
<blockquote>
<p>通过例子认识Either</p>
</blockquote>
<pre><code class="language-js">class Either {
    constructor(left, right) {
        this.left = left
        this.right = right
    }
    map(f) {
        return this.right ?
            Either.of(this.left, f(this.right)) : Either.of(f(this.left), this.right)
    }
    static of(left, right) {
        return new Either(left, right)
    }
}
const add = x =&gt; x + 1
Either.of(1, 2).map(add) // Either(1, 3)
Either.of(1, null).map(add) // Either(2, null)
</code></pre>
<p>上面的例子和普通函子不太一样的地方就是传入的值是两个，然后map方法通过判断右值是否存在，如果右值（正常值）存在的情况是作用于右值，不存在则作用域左值。这样就达到了错误处理的功能，在<code>函数式编程</code>是没有<code>try-catch</code>的，Either可以代替<code>try-catch</code>。</p>
<h3 id="13-ap函子">13. AP函子</h3>
<blockquote>
<p>什么是AP函子</p>
</blockquote>
<p>函子里面包含的值是函数</p>
<blockquote>
<p>通过例子认识AP函子</p>
</blockquote>
<pre><code class="language-js">class Ap {
    constructor(x) {
        this.__value = x
    }
    ap(F) {
        return Ap.of(this.__value(F.__value))
    }
    map(f) {
        return Ap.of(f(this.__value))
    }
    static of(x) {
        return new Ap(x)
    }
}

Ap.of(x =&gt; x + 1).ap(Functor.of(2))
</code></pre>
<p>上面的例子里的有个ap函数，它与map方法不同，因为<code>Ap.of(x =&gt; x + 1)</code>里<code>__value</code>是个方法，所以这种函子成为AP函子</p>
<h3 id="14-io">14. IO</h3>
<blockquote>
<p>什么是IO</p>
</blockquote>
<p>在我们真正编程的时候，不可能达到我们的预期，我们一定会有不纯的操作，比如（IO、网络请求、dom操作），我们可以把这些不纯的操作包裹到一个函数内。</p>
<blockquote>
<p>普通的IO函子</p>
</blockquote>
<pre><code class="language-js">class IO {
    constructor(f) {
        this.__value = f
    }
    // 与其他函子的不同之处就是map方法
    map(f) {
        return IO.of(compose(f, this.__value)) // compose方法在前面的时候实现过
    }
    static of(f) {
        return new IO(f)
    }
}
</code></pre>
<h3 id="15-monad">15. Monad</h3>
<blockquote>
<p>什么是Monad</p>
</blockquote>
<ol>
<li>Maybe、Either、IO这三个强大的Functor在链式调用、惰性求值、错误捕获、输入输出都发挥着巨大的作用。但是在我们开发的时候仍然有问题：1. 处理不了嵌套的Functor 2. 处理不了一个由非纯函数或者异步的操作序列。Monad可以解决这两个问题</li>
<li>Monad是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个操作。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</li>
<li>Promise就是一种Monad。</li>
<li>Monad可以避开地狱嵌套，可以轻松地进行深度嵌套的函数式编程。</li>
</ol>
<blockquote>
<p>Monad的作用</p>
</blockquote>
<p>Monad函子总是返回一个单层的函子，它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了嵌套函子，他会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。</p>
<p>flagMap方法接受一个f，里面会实行josin方法，为了保证这个方法总是返回一个单层的函子，这就意味着嵌套的函子会被扁平。</p>
<blockquote>
<p>通过例子认识Monad函子</p>
</blockquote>
<pre><code class="language-js">class Monad {
    constructor(x) {
        this.__value = x
    }
    map(f) {
        return Monad.of(f(this.__value))
    }
    join() {
        return this.__value
    }
    flatMap(f) {
        return this.map(f).join()
    }
    static of(x) {
        return new Monad(x)
    }
}

</code></pre>
<p>Monad函子比普通的函子多了flatMap和join方法</p>
<blockquote>
<p>Monad与IO实现文件操作</p>
</blockquote>
<pre><code class="language-js">const fs = require(&quot;fs&quot;)
const _ = require(&quot;lodash&quot;) // 第三方方法库

class Functor {
  constructor(x) {
    this.__value = x
  }
  map(f) {
    return Functor.of(f(this.__value))
  }
  of(x) {
    return new Functor(x)
  }
}

class Monad extends Functor {
  join() {
    return this.__value
  }
  flatMap(f) {
    return this.map(f).join()
  }
}

class IO extends Monad {
  static of(__value) {
    return new IO(__value)
  }
  map(f) {
    // this.__value === print和读文件方法的组合后的方法
    // _.flowRight是lodash实现compose方法 flowRight代表的是方法从右向左执行
    return IO.of(_.flowRight(f, this.__value))
  }

  // 继承过来的方法 运行的时候请把下面两个方法注释 为了好理解才把它复制过来
  join() {
    // print和读文件方法的组合后的方法
    return this.__value
  }
  flatMap(f) {
    // this.map(f) === IO(print和读文件方法的组合后的方法)
    // this.map(f).join() === print和读文件方法的组合后的方法
    return this.map(f).join()
  }
}

const print = (x) =&gt; IO.of(() =&gt; {
    return x
})
const readFile = (filePath) =&gt; IO.of(() =&gt; fs.readFileSync(filePath, &quot;utf8&quot;))
const result = readFile(&quot;目标文件&quot;) // IO(() =&gt; fs.readFileSync(filePath, &quot;uft-8&quot;))
  .flatMap(print) // 组合后的方法

result().__value() // 这个__value是() =&gt; console.log(x)

// 如果想要链式调用 可以使用下面的方法
const result = readFile(&quot;目标文件&quot;) // IO(() =&gt; fs.readFileSync(filePath, &quot;uft-8&quot;))
  .flatMap(print)() // 返回IO函子
  .flatMap(print)()
</code></pre>
<p>上面这段代码的执行流程已经在代码中详细注释，请慢慢领悟下其中的奥秘。</p>
<p>最后，函数式编程的内容不仅只有这些，本文只列举常见和实用的东西。</p>

                </div>
                <div class="clear"></div>
              </section>
            </article>
            <div class="clear"></div>

            <section class="related section">
              
              <article class="prev grid-50 tablet-grid-50 grid-parent">
                <div class="thumb cover lazy loaded" style="background-image: url('https://raw.githubusercontent.com/zhourengui/blog-image/master/qa.png');"></div>
                 <a href="https://github.com/zhourengui/zhourengui.github.io/dan-yuan-ce-shi/" class="full-link"></a>
                 <div class="info">
                  <time datetime="2020-08-30">2020-08-30</time>
                  <h4 class="title white no-margin">QA测试</h4>
                </div>
                 <span class="epcl-button red">
                  <img src="https://github.com/zhourengui/zhourengui.github.io/media/images/left-arrow.svg" width="15" alt="Left Arrow">
                </span>
                <div class="overlay"></div>
              </article>
              
              

                <div class="clear"></div>
            </section>

              <div class="clear"></div>
              
            
              <div id="comments" class="bg-white hosted ">
                <div class="clear"></div>
<script>
jQuery(document).ready(function($){
    $('.vemoji-btn').text('😀');
    $("#comments").on('click', 'span.vat',function(){
        $(this).parent('div.vmeta').next("div.vcontent").after($("div.vwrap"));
        $('textarea#veditor').focus();
    })
    if(window.location.hash){
        var checkExist = setInterval(function() {
            if ($(window.location.hash).length) {
                $('html, body').animate({scrollTop: $(window.location.hash).offset().top-200}, 600);
                clearInterval(checkExist);
            }
        }, 100);
    }
})
</script>

              </div>
            

            </div>
          </div>
      </main>

          <footer id="footer" class="grid-container">
        <div class="widgets row gradient-effect">
            <div class="default-sidebar border-effect">
              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="tag_cloud-2" class="widget widget_epcl_posts_thumbs underline-effect">
                  <h4 class="widget-title title white bordered">最新文章</h4>
                  
                  
                  <article class="item post-0 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://github.com/zhourengui/zhourengui.github.io/dan-yuan-ce-shi/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://raw.githubusercontent.com/zhourengui/blog-image/master/qa.png');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2020-08-30">2020-08-30</time>
                      <h4 class="title usmall">
                        <a href="https://github.com/zhourengui/zhourengui.github.io/dan-yuan-ce-shi/">QA测试</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  <article class="item post-1 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://github.com/zhourengui/zhourengui.github.io/han-shu-shi-bian-cheng/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://raw.githubusercontent.com/zhourengui/blog-image/master/function-programming.png');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2020-08-28">2020-08-28</time>
                      <h4 class="title usmall">
                        <a href="https://github.com/zhourengui/zhourengui.github.io/han-shu-shi-bian-cheng/">函数式编程</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  <div class="clear"></div>
                </section>
              </div>

              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="tag_cloud-2" class="widget widget_tag_cloud underline-effect">
                  <h4 class="widget-title title white bordered">标签云</h4>
                  <div class="tagcloud">
                    
                      <a href="https://github.com/zhourengui/zhourengui.github.io/-bPu6JFhz/" class="ctag ctag-0 ctag--bPu6JFhz" aria-label="">QA</a>
                    
                      <a href="https://github.com/zhourengui/zhourengui.github.io/A6Q75Twsp/" class="ctag ctag-1 ctag-A6Q75Twsp" aria-label="">NodeJS</a>
                    
                      <a href="https://github.com/zhourengui/zhourengui.github.io/b02rvhSHe/" class="ctag ctag-2 ctag-b02rvhSHe" aria-label="">JavaScript</a>
                    
                  </div>
                  <div class="clear"></div>
                </section>
              </div>

              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="epcl_about-2" class="widget widget_epcl_about underline-effect">
                  <h4 class="widget-title title white bordered">关于我</h4>
                  <div class="avatar">
                    <a href="" class="translate-effect thumb"><span class="fullimage cover" style="background-image: url(https://github.com/zhourengui/zhourengui.github.io/images/avatar.png);"></span></a>
                  </div>
                  <div class="info">
                    <h4 class="title small author-name gradient-effect no-margin"><a href="">LittleBoy-前端爱好者</a></h4>
                    <p class="founder">一位前端爱好者的大前端养成记</p>
                    <div class="social">
                      
                          
                            <a href="https://github.com/zhourengui" class="translate-effect" target="_blank"><i class="fa fa-github"></i></a>
                        
                      
                        
                      
                        
                      
                        
                      
                        
                      
                    </div> 
                  </div>
                  <div class="clear"></div>
                  </section>
              </div>

            </div>
            <div class="clear"></div>
        </div>

        <div class="logo">
          <a href="https://github.com/zhourengui/zhourengui.github.io"><img src="/media/images/custom-footerLogo.png" alt=""></a>
        </div>
        <p class="published border-effect">
          ©2019 共 2 篇文章
          <br/>
          Theme <a href="https://gridea.dev/" target="_blank">「breek」</a> Powered by <a href="https://gridea.dev/" target="_blank">「Gridea」</a>
        </p>
        
        <a href="javascript:void(0)" id="back-to-top" class="epcl-button dark" style="display:none">
          <i class="fa fa-arrow"></i>
        </a>
    </footer>
    
    <div class="clear"></div>

        
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/valine/1.3.10/Valine.Pure.min.js"></script>
<script>
    new Valine({
        el: '#comments',
        appId: 'bEuEMACG0o7iNnryQQYgfLE2-gzGzoHsz' ,
        appKey: 'Xkv8kTC4SwEtYxpQs6EuyuSS',
        pageSize: 30,
        placeholder: '既然来了，那就留个痕迹吧~',
        visitor: true // 阅读量统计
    })
</script>
    

      
    <script src="https://github.com/zhourengui/zhourengui.github.io/media/js/functions-post.js"></script>

    </div>
    <!-- end: #wrapper -->
  </body>
</html>
