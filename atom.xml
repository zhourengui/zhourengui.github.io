<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/zhourengui/zhourengui.github.io</id>
    <title>LittleBoy-前端爱好者</title>
    <updated>2021-01-29T12:26:55.033Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://github.com/zhourengui/zhourengui.github.io"/>
    <link rel="self" href="https://github.com/zhourengui/zhourengui.github.io/atom.xml"/>
    <subtitle>一位前端爱好者的大前端养成记</subtitle>
    <logo>https://github.com/zhourengui/zhourengui.github.io/images/avatar.png</logo>
    <icon>https://github.com/zhourengui/zhourengui.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LittleBoy-前端爱好者</rights>
    <entry>
        <title type="html"><![CDATA[数据结构之字典]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-zi-dian/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-zi-dian/">
        </link>
        <updated>2021-01-29T12:24:12.000Z</updated>
        <content type="html"><![CDATA[<p>本篇文章可以收获的知识：</p>
<ul>
<li>什么是<code>字典</code></li>
<li><code>字典</code>的常用操作</li>
<li>三道<a href="https://leetcode-cn.com/">LeetCode</a>算法题巩固<code>字典</code></li>
<li>如何分析<code>时间复杂度</code>和<code>空间复杂度</code></li>
</ul>
<h3 id="什么是字典">什么是字典</h3>
<p><code>字典</code>与集合类似，字典也是一种存储唯一值的数据结构，但<code>字典</code>是以键值对的形式来存储，ES6中有字典，名为Map。</p>
<h3 id="字典的常用操作">字典的常用操作</h3>
<pre><code class="language-js">const m = new Map() // 字典
m.set(&quot;a&quot;, &quot;b&quot;) // 给字典添加元素
m.set(&quot;a&quot;, &quot;c&quot;) // 修改字典的某个元素
m.get(&quot;a&quot;) // 从字典中获取目标元素
m.delete(&quot;a&quot;) // 从字典中删除目标元素
m.clear() // 清空字典
</code></pre>
<h3 id="leetcode算法题题号349两个数组的交集">LeetCode算法题：题号349，<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">两个数组的交集</a></h3>
<p>解题思路：</p>
<ul>
<li>用字典建立一个映射关系，记录nums1的值</li>
<li>遍历nums2，找出nums1也有的值</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>新建一个字典，遍历nums1，填充字典</li>
<li>遍历nums2，遇到字典里的值选出来，并从字典中删除</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  const nums3 = []
  const m = new Map()
  nums1.forEach(i =&gt; m.set(i, true))
  nums2.forEach(i =&gt; {
    if (m.get(i)) {
      nums3.push(i);
      m.delete(i)
    }
  })
  return nums3;
};
</code></pre>
<p>因为代码中有个循环，循环次数是数组的长度，所以时间复杂度是O(n)，n是数组的长度。</p>
<p>因为代码中使用了map数据结构，长度最大是数组的长度，所以空间复杂度是O(n)，n是数组的长度。</p>
<h3 id="leetcode算法题题号1两数之和">LeetCode算法题：题号1，<a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></h3>
<p>解题思路：</p>
<ul>
<li>把nums当成已婚人士（成员中可能有自己的对象，也有可能对象不在这个nums中）。</li>
<li>把target当成寻找自己对象的目标</li>
<li>用字典建立一个房间，存储已婚人士的值和下标</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>用字典建立一个房间</li>
<li>遍历nums如果没有找到对象的保留在房间中，如果找到就结束</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  const m = new Map()
  for (let i = 0; i &lt; nums.length; i ++) {
    if (m.has(target - nums[i])) {
      return [m.get(target - nums[i]), i]
    }
    m.set(nums[i], i)
  }
};
</code></pre>
<p>因为代码有一个for循环体，循环次数最大是nums的长度，所以时间复杂度是O(n)，n是数组的长度。</p>
<p>因为代码中用到map数据结构，最大长度是数组的长度，所以空间复杂度是O(n)，n是数组的长度。</p>
<h3 id="leetcode算法题题号3无重复字符串的最长字串">LeetCode算法题：题号3，<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符串的最长字串</a></h3>
<p>解题思路：</p>
<ul>
<li>找出所有没有重复的字符的子串</li>
<li>找出长度最大的那个子串，返回其长度</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>用双指针维护一个滑动窗口，用来剪切子串</li>
<li>不断移动右指针，遇到重复字符，就把左指针移动到重复字符的下一位</li>
<li>过程中记录所有窗口的最大长度</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
  let l = 0
  let max = 0;
  const map = new Map()
  for (let r = 0; r &lt; s.length; r ++) {
    if (map.has(s[r]) &amp;&amp; map.get(s[r] &gt;= l)) {
      l = map.get(s[r]) + 1
    }
    max = Math.max(max, r - l + 1)
    map.add(s[r], r)
  }
};
</code></pre>
<h3 id="leetcode算法题题号76最小覆盖子串">LeetCode算法题：题号76，<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">最小覆盖子串</a></h3>
<p>解题思路：</p>
<ul>
<li>找出所有覆盖的子串</li>
<li>返回最小的子串</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>使用一前一后双指针维护一个窗口</li>
<li>不断的移动右指针，当窗口中包含目标子串的时候，移动左指针</li>
<li>当左指针对应的字符串在目标字符串中的时候，记录子串</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
  let l = 0
  let m = new Map()
  let str = &quot;&quot;
  let type = 0

  for (let i = 0; i &lt; t.length; i++) {
    m.set(t[i], 1)
  }
  for (let r = 0; r &lt; s.length; r++) {
    const c = s[r]
    if (m.has(c)) {
      m.set(c, m.get(c) - 1)
      m.get(c) === 0 &amp;&amp; (type += 1)
    }

    while (type === 3) {
      if (m.has(s[l])) {
        str = !str || r - l + 1 &lt; str.length ? s.substr(l, r + 1) : str
        m.set(s[l], m.get(s[l]) + 1)
        m.get(s[l]) === 1 &amp;&amp; (type -= 1)
      }
      l += 1
    }
  }
  return str
}
</code></pre>
<p>最后，希望读者可以通过本篇文章对<code>字典</code>有一定的认识和觉悟。。。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构之集合]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-ji-he/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-ji-he/">
        </link>
        <updated>2021-01-18T07:40:36.000Z</updated>
        <content type="html"><![CDATA[<p>本篇文章可以收获的知识：</p>
<ul>
<li>什么是<code>集合</code></li>
<li><code>集合</code>的使用场景</li>
<li>一道<a href="https://leetcode-cn.com/">LeetCode</a>算法题巩固<code>集合</code></li>
<li>如何分析<code>时间复杂度</code>和<code>空间复杂度</code></li>
<li>JavaScript中的<code>集合</code></li>
</ul>
<h3 id="什么是集合">什么是集合</h3>
<p><code>集合</code>是一种无序且唯一的数据结构，ES6中的集合，名为<code>Set</code></p>
<h3 id="集合的使用场景">集合的使用场景</h3>
<ul>
<li>
<p>数组去重</p>
<pre><code class="language-js">const a1 = [1, 1, 2, 2, 3, 4, 5];
const a2 = [...new Set(a1)]
</code></pre>
</li>
<li>
<p>判断元素是否存在集合中</p>
<pre><code class="language-js">const s = new Set([1, 2, 3, 4])
s.has(1) // 返回boolean
</code></pre>
</li>
<li>
<p>求两个集合的交集</p>
<pre><code class="language-js">const s1 = new Set([1, 2, 3, 4])
const s2 = new Set([2, 3])
const s3 = new Set([...s1].filter(i =&gt; s1.has(i)))
</code></pre>
</li>
</ul>
<h3 id="leetcode算法题题号349两个数组的交集">LeetCode算法题：题号349，<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">两个数组的交集</a></h3>
<p>解题思路：</p>
<ul>
<li>求交集且唯一</li>
<li>使用集合</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>使用集合对数组进行去重</li>
<li>遍历其中一个数据，判断另一个数据是否包含</li>
</ul>
<p>实现代码：</p>
<pre><code class="language-js">/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
  const s1 = new Set(nums1);
  const s2 = new Set(nums2);
  const res = [...s1].filter(i =&gt; s2.has(i))
  return res
};
</code></pre>
<p>因为代码有用到了filter，每一个元素都要进行过滤，循环次数最大可能是nums1的长度乘以nums2的长度，所以时间复杂度是O(n * m)，n是nums1的长度，m是nums2的长度。</p>
<p>因为代码中用到了set数据结构，长度最大是两个数组中最大的长度，所以空间复杂度是O(n)，n是数组的长度。</p>
<p>这道LeetCode的算法题的最优解法是使用字典数据结构解决，在<code>数据结构之字典</code>文章中也会提及。</p>
<h3 id="javascript中的集合">JavaScript中的集合</h3>
<pre><code class="language-js">// JavaScript中集合的常用操作
const s = new Set()
s.add(1) // 添加操作
s.delete(1) // 删除操作
s.size() // 获取集合的长度
s.has(1) // 判断集合中是否有当前元素

// JavaScript中集合的迭代
for(let item of m) {}
for(let item of m.keys()) {}
for(let item of m.values()) {}
for(let [key, value] of m.entries()) {} // key === value

// JavaScript中集合与数组互转
const a = Array.from(new Set([1, 2]))
const s1 = new Set(a)
</code></pre>
<p>最后，希望读者可以通过本篇文章对<code>集合</code>有一定的认识和觉悟。。。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构之链表]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-lian-biao/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-lian-biao/">
        </link>
        <updated>2021-01-18T06:50:43.000Z</updated>
        <content type="html"><![CDATA[<p>本篇文章可以收获的知识：</p>
<ul>
<li>什么是<code>链表</code></li>
<li><code>链表</code>的常用操作与数组的对比</li>
<li>四道<a href="https://leetcode-cn.com/">LeetCode</a>算法题巩固<code>链表</code></li>
<li>如何分析<code>时间复杂度</code>和<code>空间复杂度</code></li>
<li>详解JavaScript中的<code>原型链</code></li>
<li>详解<code>instanceof</code>的原理</li>
<li>使用链表指针获取<code>JSON</code> 的节点值</li>
</ul>
<h3 id="什么是链表">什么是链表</h3>
<p><code>链表</code>是由多个元素组成的列表，元素存储是不连续的，元素之间用<code>next</code>指针连在一起，在JavaScript中没有链表，使用Object来模拟链表的功能。</p>
<h3 id="链表的常用操作">链表的常用操作</h3>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */

const n1 = new ListNode(1) // 链表1
const n2 = new ListNode(2) // 链表2
const n3 = new ListNode(3) // 链表3
n1.next = n2 // 给n1链表，插入元素
n2.next = n3 // 给n2链表，插入元素
n1.next = n3 // 删除n2元素，一开始n1的指针指向n2的，让n1的指针指向n3就删除n2

// 遍历链表操作
// 思路
// 定义一个指针
// 循环遍历指针，访问当前指针，指针指向下一针，直到指针为空
let p = n1;
while(p) {
  console.log(p.val)
  p = p.next;
}
</code></pre>
<p>了解了链表的操作之后，我们会发现链表的新增元素和删除元素只需要修改某个指针就能实现需求，而数组在这些操作之后，需要移动元素来实现（除操作首尾元素），所以做增删操作的时候，链表的性能是比数据的性能高的。</p>
<h3 id="leetcode算法题题号237删除链表中的节点">LeetCode算法题：题号237，<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">删除链表中的节点</a></h3>
<p>其实这道题相对简单，做题人一开始的思路肯定是让传进来的node的上一个元素的next指向node的下一个元素就可以了，但是我们并不知道node的上一个元素，所以我们可以在node的下一个元素做文章。</p>
<p>解题思路：</p>
<ul>
<li>不能拿到node的上一个元素，只能拿到node的下一个元素</li>
<li>将node的元素替换成node的下一个元素</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>将node的下一个元素的值赋值给node</li>
<li>让node的下一个元素指向node的下下个元素</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
  node.val = node.next.val;
  node.next = node.next.next;
};
</code></pre>
<p>这道题因为没有循环体，没有额外的产生数据结构，所以时间复杂度和空间复杂度都是O(1)。</p>
<h3 id="leetcode算法题题号206反转链表">LeetCode算法题：题号206，<a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h3>
<h4 id="方法一正向反转指针">方法一，正向反转指针：</h4>
<p>解题思路：</p>
<ul>
<li>反转两个节点，将n+1的指针指向n</li>
<li>反转多个节点，重复上面的操作就能实现。</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>一定一前一后指针，遍历链表</li>
<li>反转指针</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  let p1 = null;
  let p2 = head
  while(p2) {
    const tmp = p2.next;
    p2.next = p1;
    p1 = p2;
    p2 = tmp
  }
  return p1;
};
</code></pre>
<p>因为代码中有个while循环体，循环的次数是传进来的链表长度，所以时间复杂度是O(n)，n是链表的长度。</p>
<p>因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。</p>
<h4 id="方法二反向反转指针">方法二，反向反转指针：</h4>
<p>解题思路：</p>
<ul>
<li>反向反转指针，从链表的尾指针开始反转指针</li>
<li>这个场景非常适合递归来实现</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>两个节点的反转，让当前指针的下下指针等于当前指针，然后将当前的下个指针等于null，解决闭环问题。</li>
<li>重复上一步骤</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  if (head === null || head.next === null) {
    return head;
  }
  const newHead = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  return newHead;
};
</code></pre>
<p>因为代码中是使用递归实现的，需要对链表的每个节点进行反转操作，所以时间复杂度是O(n)，n是链表的长度。</p>
<p>代码中虽然没有产生额外的数据结构，但是这里使用递归，递归的空间复杂度主要取决于递归调用栈的空间，也就是链表的长度，所以空间复杂度是O(n)。</p>
<h3 id="leetcode算法题题号83删除排序链表中的重复元素">LeetCode算法题：题号83，<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h3>
<p>解题思路：</p>
<ul>
<li>给定的链表是有序的</li>
<li>当前指针的值等于下一指针的值时，删除下一个指针。</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>遍历链表，当前指针的值等于下一指针的值时，将当前指针的指向下下个指针。</li>
<li>遍历结束后，返回链表的头部。</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
  let p = head;
  while(p &amp;&amp; p.next) {
    if (p.val === p.next.val) {
      p.next = p.next.next;
    } else {
      p = p.next;
    }
  }
  return head;
};
</code></pre>
<p>因为代码中有个while循环体，循环的次数是链表的长度，所以时间复杂度是O(n)，n是链表的长度。</p>
<p>因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。</p>
<h3 id="leetcode算法题题号141环形链表">LeetCode算法题：题号141，<a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></h3>
<p>解题思路：</p>
<ul>
<li>把这个场景想像成操场上跑步，跑的快的人，在某个时间会再遇到跑得快的人。</li>
<li>定义一快一慢指针，如果再某个时间两个指针能相遇，说明有环。</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>定义一快一慢指针</li>
<li>如果在跑的过程在能遇到，返回true，如果快指针为null或者下一针为null，说明没有环，返回false</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
	let slowP = head;
  let fastP = head;
  while(fastP &amp;&amp; fastP.next) {
    slowP = slowP.next;
    fastP = fastP.next.next;
    if (slowP === fastP) {
      return true;
    }
  }
  return false;
};
</code></pre>
<p>因为代码中有个while循环体，循环的次数最大的链表的长度，所以时间复杂度是O(n)，n是链表的长度。</p>
<p>因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。</p>
<h3 id="javascript中的原型链">JavaScript中的原型链</h3>
<h4 id="原型">原型</h4>
<p><code>原型</code>是实例对象的共有祖先，通俗的讲，构造函数有<code>prototype</code>属性，由这个构造函数构造出来的实例可以访问到<code>prototype</code>里的属性。</p>
<pre><code class="language-js">function Person() {}
Person.prototype.name = &quot;nickname&quot;

const p = new Person();
p.name; // nickname
</code></pre>
<h4 id="原型链">原型链</h4>
<p>原型链本质上是链表，通过<code>__proto__</code>属性进行连接，每个对象都有<code>__proto__</code>属性，如果访问的属性不存在的时候，会沿着对象的<code>__proto__</code>属性去寻找，直到为<code>null</code>，<code>__proto__</code>指向构造函数的<code>prototype</code>对象，也就是<code>原型</code>。</p>
<pre><code class="language-js">const n = Number(1)
n.__proto__ = Number.prototype
Number.prototype.__proto__ = Object.prototype
Object.prototype.__proto__ = null

const o = Object.create({})
o.__proto__ = Object.prototype
Object.prototype.__proto__ = null

// 数组、布尔、字符串也如此
...
...
...
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/prototype.jpeg" alt="原型链图解" loading="lazy"></figure>
<h3 id="instanceof的原理">Instanceof的原理</h3>
<p>记住一句话，如果<code>A instanceof B</code>为true，说明在A的原型链上可以找到B的原型。</p>
<p>实现<code>instanceof</code>的代码：</p>
<pre><code class="language-js">// 思路
// 定义一个指针
// 遍历A的原型链，如果A的原型链上有B的原型，返回true
// 遍历完之后，说明找不到，但会false
const coInstanceof = (A, B) =&gt; {
  let p = A
  while(p) {
    if (p.__proto__ === B.prototype) {
      return true
    }
    p = p.__proto__
  }
  return false
}
</code></pre>
<h3 id="使用链表指针获取json的节点值">使用链表指针获取JSON的节点值</h3>
<pre><code class="language-js">const json = {
  a: { b: { c: 1 } },
  d: { e: 2 },
}
const path = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
let p = json
path.forEach(i =&gt; {
  p = p[i]
  console.log(`${i}：${JSON.stringify(p)}`)
})

// 日志输出
// a: { b: { c: 1 } }
// b: { c: 1 }
// c: 1
</code></pre>
<p>最后，希望读者可以通过本篇文章对<code>链表</code>有一定的认识和觉悟。。。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构之队列]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-dui-lie/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-dui-lie/">
        </link>
        <updated>2021-01-15T08:09:56.000Z</updated>
        <content type="html"><![CDATA[<p>本篇文章可以收获的知识：</p>
<ul>
<li>什么是<code>队列</code></li>
<li><code>队列</code>的常用操作</li>
<li><code>队列</code>的使用场景</li>
<li>一道<a href="https://leetcode-cn.com/">LeetCode</a>算法题巩固<code>队列</code></li>
<li>如何分析<code>时间复杂度</code>和<code>空间复杂度</code></li>
</ul>
<h3 id="什么是队列">什么是队列</h3>
<p><code>队列</code>是一个先进先出的数据结构，JavaScirpt中没有队列，但可以使用Array实现队列的所有功能。</p>
<h3 id="队列的常用操作">队列的常用操作</h3>
<pre><code class="language-js">const queue = [] // 队列
queue.push(1) // 入队（enqueue）
queue.shift() // 出队（dequeue）
</code></pre>
<h3 id="队列的使用场景">队列的使用场景</h3>
<ul>
<li>
<p>食堂排队打饭</p>
<p>食堂排队打饭都不陌生，先排队的学生可以先打到饭，符合<code>队列</code>的特点。</p>
</li>
<li>
<p>JavaScript异步任务队列</p>
<p>JavaScript是单线程的，无法同时处理异步任务中的并发任务，使用任务队列先后处理异步任务</p>
</li>
<li>
<p>计算最近请求次数</p>
<p>一个请求队列[[], [1], [100], [3001], [3002]],计算[t-3000, t]的请求次数，首先新请求t先入队，不在这个区间的出队。后面也会通过一道<a href="https://leetcode-cn.com/problems/number-of-recent-calls/">LeetCode</a>算法题巩固<code>队列</code>的知识。</p>
</li>
</ul>
<p>遇到这些相似的问题，都可以优先考虑使用<code>队列</code>来解决问题。</p>
<h3 id="leetcode算法题题号933最近的请求次数">LeetCode算法题：题号933，<a href="https://leetcode-cn.com/problems/number-of-recent-calls/">最近的请求次数</a></h3>
<p>解题思路：</p>
<ul>
<li>越早发出的请求，越靠前</li>
<li>符合先进先出的特点，考虑使用队列。</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>新请求，入队</li>
<li>不在[t - 3000, t]区间内的成员出队</li>
<li>最后队列的长度就是最近的请求次数</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">var RecentCounter = function() {
  this.q = [];
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function(t) {
  this.q.push(t);
  while(t - 3000 &gt; this.q[0]) {
    this.q.shift();
  }
  return this.q.length;
};

/**
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */
</code></pre>
<h3 id="分析时间复杂度和空间复杂度">分析时间复杂度和空间复杂度</h3>
<p>因为代码中有个while循环体，循环的次数最大是ping的次数，所以时间复杂度是O(n)，n是ping的次数。</p>
<p>因为代码中用到了队列，最大的长度是3000，所以空间复杂度是O(n)，n最大是3000。</p>
<p>最后，希望读者可以通过本篇文章对<code>队列</code>有一定的认识和觉悟。。。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构之栈]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-zhan/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-zhan/">
        </link>
        <updated>2021-01-15T02:46:59.000Z</updated>
        <content type="html"><![CDATA[<p>本篇文章可以收获的知识：</p>
<ul>
<li>什么是<code>栈</code></li>
<li><code>栈</code>的常用操作</li>
<li><code>栈</code>的使用场景</li>
<li>一道<a href="https://leetcode-cn.com/">LeetCode</a>算法题巩固<code>栈</code></li>
<li>如何分析<code>时间复杂度</code>和<code>空间复杂度</code></li>
</ul>
<h3 id="什么是栈">什么是栈</h3>
<p><code>栈</code>是一个后进先出的数据结构，在JavaScript中没有栈，但是可以使用Array来实现栈的所有功能。</p>
<h3 id="栈的常用操作">栈的常用操作</h3>
<pre><code class="language-js">const stack = [] // 栈
stack.push(1) // 入栈
const item = stack.pop() // 出栈
</code></pre>
<h3 id="栈的使用场景">栈的使用场景</h3>
<ul>
<li>
<p>十进制转二进制</p>
<p>可以从图中可以看到，我们如果按照顺序求出来的商是00111001，但是十进制转二进制得出来的结果是10011100，明显有后进先出的意思，所以遇到十进制转二进制的问题的时候，使用栈是最适合的。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/decimal2binary.png" alt="十进制转二进制" loading="lazy"></figure>
</li>
<li>
<p>有效的括号</p>
<p>在我们开发中经常也会用到括号，例如<code>([])</code>，这样的括号会发现，<code>(</code>是先进的，<code>[</code>是后进的，但是<code>]</code>是先出的，这就符合栈的<code>后进先出的特点</code>，所以遇到有效括号这类的问题的时候，使用栈是最合适的。后面也会通过一道<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a>LeetCode算法题来巩固栈的知识。</p>
</li>
<li>
<p>函数调用堆栈</p>
<p>可以通过下面的代码进行断点进行调试，我们会发现我们先调用fn1，但是最后执行结束的是fn1</p>
<pre><code class="language-js">const fn1 = () =&gt; {
  fn2()
}

const fn2 = () =&gt; {
  fn3()
}

const fn3 = () =&gt; {}

fn1()
</code></pre>
</li>
</ul>
<h3 id="leetcode算法题题号20有效的括号">LeetCode算法题：题号20，<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></h3>
<p>解题思路：</p>
<ul>
<li>对于没有闭合的左括号而言，越靠后的左括号，对应的右括号越靠前</li>
<li>满足后进先出的特点</li>
</ul>
<p>解题步骤：</p>
<ul>
<li>新建一个栈</li>
<li>判断字符串的长度是否是偶数，奇数直接判定为不合法</li>
<li>扫描字符串，遇到左括号入栈，遇到和栈顶括号类型匹配的右括号就出栈，类型不匹配直接判定为不合法</li>
<li>遍历结束后，栈为空代表合法，不为空代表不合法</li>
</ul>
<p>代码实现：</p>
<pre><code class="language-js">/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  if (s.length % 2 === 1) { return false; }
 	const stack = [];
  const m = new Map();
  m.set(&quot;(&quot;, &quot;)&quot;);
  m.set(&quot;{&quot;, &quot;}&quot;);
  m.set(&quot;[&quot;, &quot;]&quot;);
  for (let i = 0; i &lt; s.length; i ++) {
    if (m.has(s[i])) {
      stack.push(s[i]);
    } else {
      if (m.get(stack[stack.length - 1]) !== s[i]) {
        return false
      }
      stack.pop()
    }
  }
  return stack.length === 0;
};
</code></pre>
<h3 id="分析时间复杂度和空间复杂度">分析时间复杂度和空间复杂度：</h3>
<p>因为代码中有一个for循环，循环的次数可能是传进来的字符串长度，所以时间复杂度是O(n)，n就是传进来的字符串长度。</p>
<p>代码中定义了两个数据结构，<code>Array</code>和<code>Map</code>，因为<code>Array</code>并不会线性的增长所以是O(n)，<code>Map</code>是O(n)，所以最终的空间复杂度是O(n)，n是传进来的字符串长度。</p>
<p>最后，希望读者可以通过本篇文章对<code>栈</code>有一定的认识和觉悟。。。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法介绍]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/shu-ju-yu-jie-gou-suan-fa-jie-shao/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/shu-ju-yu-jie-gou-suan-fa-jie-shao/">
        </link>
        <updated>2021-01-14T06:19:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="在学习数据结构与算法之前必须知道的几个概念">在学习数据结构与算法之前必须知道的几个概念：</h3>
<p><code>什么是数据结构</code>：</p>
<p>为了解决问题，会将数据用特定的方式存储起来，存储的方式不同就会导致不同的算法处理，当然我们希望算法的效率越快越好，那么我们就需要考虑数据如何保存，这就是数据结构。</p>
<p>通俗的讲数据结构就是计算机存储、组织数据的方式，就像是锅碗瓢盆，它们都是来存放东西的。</p>
<p><code>什么是算法</code>：</p>
<p>一系列解决问题的清晰<code>指令</code>，就像是厨房里的食谱，有特定的制作教程，根据这个教程就可以做出相应的菜。</p>
<p><code>数据结构与算法的关系</code>：</p>
<p>数据结构为算法提供服务，算法围绕数据结构操作。</p>
<h3 id="如何判断一个算法是否可取">如何判断一个算法是否可取</h3>
<p>在作者身边的有一个真实的示例，一位后端工程师说：“昨天看到一个某某的算法，但是我觉得这个算法不太好...”。</p>
<p>这位后端工程师判断一个<code>算法</code>是否可行单凭直觉，这样的判断肯定是不可取的，正确的判断方式是通过<code>时间复杂度</code>和<code>空间复杂度</code>。</p>
<h3 id="认识时间复杂度">认识时间复杂度</h3>
<ul>
<li>
<p><code>时间复杂度</code>，定性描述该算法的运行时间，通俗讲就是一个算法的循环次数。</p>
</li>
<li>
<p><code>时间复杂度</code>的表示用一个函数 O 表示，比如 O(1)、O(n)、O(logN)...，表示<code>时间复杂度</code>的时候，不需要确却计算出这个数值。</p>
</li>
<li>
<p>两个<code>时间复杂度</code>相加时，取最大即可，例：O(1) + O(n) = O(n)</p>
</li>
<li>
<p>两个<code>时间复杂度</code>相乘时，相乘即可，例：O(n) * O(logN) = O(n * logN)</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/time-complexity.png" alt="时间复杂度" loading="lazy"></figure>
<ul>
<li>它们的关系是：n! &gt; 2^n &gt; n^2 &gt; nlogN &gt; n &gt; √n &gt; logN &gt; 1</li>
</ul>
<h3 id="认识空间复杂度">认识空间复杂度</h3>
<ul>
<li>
<p><code>空间复杂度</code>，对一个算法在运行过程中临时占用存储空间大小的度量。</p>
</li>
<li>
<p><code>空间复杂度</code>的表示用一个函数 O 表示，比如 O(1)、O(n)、O(n^2)...。</p>
</li>
</ul>
<h3 id="认识每个数据结构">认识每个数据结构</h3>
<ul>
<li>
<p><a href="/shu-ju-jie-gou-zhi-zhan/">栈（Stack）</a>：一个后进先出的数据结构，JavaScript 中并没有栈，通过 Array 来实现栈的功能，通过方法<code>push</code>、<code>pop</code>来实现入栈和出栈。</p>
</li>
<li>
<p><a href="/shu-ju-jie-gou-zhi-dui-lie/">队列（Queue）</a>：一个先进先出的数据结构，JavaScript 中没有队列，通过 Array 来实现队列的功能，通过方法<code>push</code>、<code>shift</code>来实现入队(<code>enqueue</code>)和出队(<code>dequeue</code>)。</p>
</li>
<li>
<p><a href="/shu-ju-jie-gou-zhi-lian-biao/">链表（LinkedList）</a>：一个由多个元素组成的列表，元素存储是不连续，通过<code>next</code>指针连在一起，JavaScript 中没有链表，通过 Object 来实现链表的功能。</p>
</li>
<li>
<p><a href="/shu-ju-jie-gou-zhi-ji-he/">集合（Set）</a>：一个<code>无序</code>且<code>唯一</code>的数据结构，ES6 中的集合, 名<code>Set</code>。</p>
</li>
<li>
<p><code>字典（Map）</code>：一个用<code>键值对</code>存储<code>唯一值</code>的数据结构，ES6 中的字典，名<code>Map</code></p>
</li>
<li>
<p><code>树（Tree）</code>：一种分层数据的抽象模型，JavaScript 中没有树，通过 Array 和 Object 构建树。</p>
</li>
<li>
<p><code>图（graph）</code>：一种网络结构的抽象模型，是一组由边连接的节点，JavaScript 中没有图，通过 Array 和 Object 构建图。</p>
</li>
<li>
<p><code>堆（Heap）</code>：一种特殊的完全二叉树，所有的节点大于等于（最大堆）或小于等于（最小堆）它的子节点，JavaScript 中没有堆，通过 Array 表示堆。</p>
</li>
</ul>
<h3 id="认识常见算法">认识常见算法</h3>
<ul>
<li>
<p>链表的遍历、删除链表节点</p>
</li>
<li>
<p>树和图的深度/广度优先遍历</p>
</li>
<li>
<p>搜索排序</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>顺序搜索</li>
<li>二分搜索</li>
</ul>
</li>
</ul>
<h3 id="认识常见算法设计思想">认识常见算法设计思想</h3>
<ul>
<li>分而治之</li>
<li>动态规划</li>
<li>贪心算法</li>
<li>回溯算法</li>
</ul>
<p>最后，希望读者可以通过本篇文章对<code>数据与结构</code>有一定的认识和觉悟。。。。。。</p>
]]></content>
    </entry>
</feed>