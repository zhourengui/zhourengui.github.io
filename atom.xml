<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/zhourengui/zhourengui.github.io</id>
    <title>LittleBoy-前端爱好者</title>
    <updated>2021-01-14T07:08:00.034Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://github.com/zhourengui/zhourengui.github.io"/>
    <link rel="self" href="https://github.com/zhourengui/zhourengui.github.io/atom.xml"/>
    <subtitle>一位前端爱好者的大前端养成记</subtitle>
    <logo>https://github.com/zhourengui/zhourengui.github.io/images/avatar.png</logo>
    <icon>https://github.com/zhourengui/zhourengui.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LittleBoy-前端爱好者</rights>
    <entry>
        <title type="html"><![CDATA[数据结构与算法介绍]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/shu-ju-yu-jie-gou-suan-fa-jie-shao/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/shu-ju-yu-jie-gou-suan-fa-jie-shao/">
        </link>
        <updated>2021-01-14T06:19:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="在学习数据结构与算法之前必须知道的几个概念">在学习<code>数据结构与算法</code>之前必须知道的几个概念：</h3>
<p><code>什么是数据结构</code>：</p>
<p>为了解决问题，会将数据用特定的方式存储起来，存储的方式不同就会导致不同的算法处理，当然我们希望算法的效率越快越好，那么我们就需要考虑数据如何保存，这就是数据结构。</p>
<p>通俗的讲数据结构就是计算机存储、组织数据的方式，就像是锅碗瓢盆，它们都是来存放东西的。</p>
<p><code>什么是算法</code>：</p>
<p>一系列解决问题的清晰<code>指令</code>，就像是厨房里的食谱，有特定的制作教程，根据这个教程就可以做出相应的菜。</p>
<p><code>数据结构与算法的关系</code>：</p>
<p>数据结构为算法提供服务，算法围绕数据结构操作。</p>
<h3 id="如何判断一个算法是否可取">如何判断一个<code>算法</code>是否可取</h3>
<p>在作者身边的有一个真实的示例，一位后端工程师说：“昨天看到一个某某的算法，但是我觉得这个算法不太好...”。</p>
<p>这位后端工程师判断一个<code>算法</code>是否可行单凭直觉，这样的判断肯定是不可取的，正确的判断方式是通过<code>时间复杂度</code>和<code>空间复杂度</code>。</p>
<h3 id="认识时间复杂度">认识<code>时间复杂度</code></h3>
<ul>
<li>
<p><code>时间复杂度</code>，定性描述该算法的运行时间，通俗讲就是一个算法的循环次数。</p>
</li>
<li>
<p><code>时间复杂度</code>的表示用一个函数 O 表示，比如 O(1)、O(n)、O(logN)...，表示<code>时间复杂度</code>的时候，不需要确却计算出这个数值。</p>
</li>
<li>
<p>两个<code>时间复杂度</code>相加时，取最大即可，例：O(1) + O(n) = O(n)</p>
</li>
<li>
<p>两个<code>时间复杂度</code>相乘时，相乘即可，例：O(n) * O(logN) = O(n * logN)</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/time-complexity.png" alt="时间复杂度" loading="lazy"></figure>
<ul>
<li>它们的关系是：n! &gt; 2^n &gt; n^2 &gt; nlogN &gt; n &gt; √n &gt; logN &gt; 1</li>
</ul>
<h3 id="认识空间复杂度">认识<code>空间复杂度</code></h3>
<ul>
<li>
<p><code>空间复杂度</code>，对一个算法在运行过程中临时占用存储空间大小的度量。</p>
</li>
<li>
<p><code>空间复杂度</code>的表示用一个函数 O 表示，比如 O(1)、O(n)、O(n^2)...。</p>
</li>
</ul>
<h3 id="认识每个数据结构">认识每个数据结构</h3>
<ul>
<li>
<p><code>栈（Stack）</code>：一个后进先出的数据结构，JavaScript 中并没有栈，通过 Array 来实现栈的功能，通过方法<code>push</code>、<code>pop</code>来实现入栈和出栈。</p>
</li>
<li>
<p><code>队列（Queue）</code>：一个先进先出的数据结构，JavaScript 中没有队列，通过 Array 来实现队列的功能，通过方法<code>push</code>、<code>shift</code>来实现入队(<code>enqueue</code>)和出队(<code>dequeue</code>)。</p>
</li>
<li>
<p><code>链表（LinkedList）</code>：一个由多个元素组成的列表，元素存储是不连续，通过<code>next</code>指针连在一起，JavaScript 中没有链表，通过 Object 来实现链表的功能。</p>
</li>
<li>
<p><code>集合（Set）</code>：一个<code>无序</code>且<code>唯一</code>的数据结构，ES6 中的集合, 名<code>Set</code>。</p>
</li>
<li>
<p><code>字典（Map）</code>：一个用<code>键值对</code>存储<code>唯一值</code>的数据结构，ES6 中的字典，名<code>Map</code></p>
</li>
<li>
<p><code>树（Tree）</code>：一种分层数据的抽象模型，JavaScript 中没有树，通过 Array 和 Object 构建树。</p>
</li>
<li>
<p><code>图（graph）</code>：一种网络结构的抽象模型，是一组由边连接的节点，JavaScript 中没有图，通过 Array 和 Object 构建图。</p>
</li>
<li>
<p><code>堆（Heap）</code>：一种特殊的完全二叉树，所有的节点大于等于（最大堆）或小于等于（最小堆）它的子节点，JavaScript 中没有堆，通过 Array 表示堆。</p>
</li>
</ul>
<h3 id="认识常见算法">认识常见算法</h3>
<ul>
<li>
<p>链表的遍历、删除链表节点</p>
</li>
<li>
<p>树和图的深度/广度优先遍历</p>
</li>
<li>
<p>搜索排序</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>顺序搜索</li>
<li>二分搜索</li>
</ul>
</li>
</ul>
<h3 id="认识常见算法设计思想">认识常见<code>算法设计思想</code></h3>
<ul>
<li>分而治之</li>
<li>动态规划</li>
<li>贪心算法</li>
<li>回溯算法</li>
</ul>
<p>最后，希望读者可以通过本篇文章对<code>数据与结构</code>有一定的认识和觉悟。。。。。。</p>
]]></content>
    </entry>
</feed>