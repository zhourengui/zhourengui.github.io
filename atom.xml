<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/zhourengui/zhourengui.github.io</id>
    <title>LittleBoy-前端爱好者</title>
    <updated>2020-09-07T09:46:42.030Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://github.com/zhourengui/zhourengui.github.io"/>
    <link rel="self" href="https://github.com/zhourengui/zhourengui.github.io/atom.xml"/>
    <subtitle>一位前端爱好者的大前端养成记</subtitle>
    <logo>https://github.com/zhourengui/zhourengui.github.io/images/avatar.png</logo>
    <icon>https://github.com/zhourengui/zhourengui.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, LittleBoy-前端爱好者</rights>
    <entry>
        <title type="html"><![CDATA[手写call、apply、bind]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/shou-xie-callapplybind/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/shou-xie-callapplybind/">
        </link>
        <updated>2020-09-07T09:38:07.000Z</updated>
        <content type="html"><![CDATA[<p>前言：</p>
<p>手写call、apply、bind是前端面试必问的问题，但是也不用当太当心，因为实现起来也并不算太难。</p>
<p><code>call</code>、<code>apply</code>、<code>bind</code>都可以修改一个函数执行时候的this指向，虽然用法上略有差异，但是在实现的思想上如出一辙。</p>
<p>在实现之前，必须要知道这三个方法是如何使用的：</p>
<pre><code class="language-js">const obj = {
    language: &quot;javascript&quot;
}
function fn(...arg) {
    console.log(&quot;The current language is &quot; + this.language)
    console.log(arg)
}
fn() // The current language is undefined，[]
fn.call(obj, &quot;javascript&quot;, &quot;java&quot;, &quot;c++&quot;) // &quot;The current language is javascript&quot;，[&quot;javascript&quot;, &quot;java&quot;, &quot;c++&quot;]
fn.apply(obj, [&quot;javascript&quot;, &quot;java&quot;, &quot;c++&quot;]) // &quot;The current language is javascript&quot;，[&quot;javascript&quot;, &quot;java&quot;, &quot;c++&quot;]
const bindFn = fn.bind(obj, &quot;javascript&quot;, &quot;java&quot;, &quot;c++&quot;)
bindFn() // &quot;The current language is javascript&quot;，[&quot;javascript&quot;, &quot;java&quot;, &quot;c++&quot;]
new bindFn() // The current language is undefined，[&quot;javascript&quot;, &quot;java&quot;, &quot;c++&quot;]
</code></pre>
<p>从上面的代码明显的发现，<code>call</code>、<code>apply</code>、<code>bind</code>可以修改函数执行时内部的this指向，并且还能传参数到函数中。三者的使用方式都是通过函数点的方式使用，说明这三个方法都是在原型上(Function.prototype)。<code>call</code>与<code>apply</code>不同之处就是传递的参数方式不同。最大的不同就是<code>bind</code>，<code>bind</code>有两种用法，如果返回的函数当成普通函数调用的时候，里面的this还是传进去的obj，但是<code>new</code>的时候，函数内部的this指向<code>window</code>，返回值则是<code>new</code>的实例。</p>
<p>了解了这些知识后我们就可以撸代码。。。</p>
<h2 id="一-functionprototypecall实现">一. Function.prototype.call实现</h2>
<p>从上面可以知道，call的第一个参数是修改函数内部的this指向，从第二个起则是传到函数的参数。</p>
<pre><code class="language-js">Function.prototype.call = function(context = window) {
    // 创建一个唯一值 防止context或者window有相同的key
    const symbol = Symbol()
    context[symbol] = this // 这里的this是调用者 也就是函数
    const ret = context[symbol](...Array.from(arguments).slice(1))
    delete context[symbol]  // 删除我们添加的属性 不修改传进来的对象或者污染全局变量
    return ret
}

function fn() {
    console.log(this.name)
}
fn.call({name: &quot;Little Boy&quot;}, &quot;arg1&quot;, &quot;arg2&quot;) // Little Boy
</code></pre>
<p>看到这里很多小伙伴肯定有很多疑问：为什么要用到Symbol，为什么要在context上挂载一个调用者函数，接下来就一一来解答。</p>
<p>首先先来看这段代码：</p>
<pre><code class="language-js">const obj = {
    name: &quot;Little Boy&quot;,
    fn: function() {
        console.log(this.name)
    }
}
obj.fn() // Little Boy
</code></pre>
<p>这段代码的意思就是对象点的形式去调用函数，this是指向当前对象的（如果这里还不明白的小伙伴，需要对<code>this</code>的指向好好复习了），那么利用这个套路我们就可以实现<code>call</code>，使用对象点的方式修改函数运行时内部的<code>this</code>指向，这就是为什么要在<code>context</code>上挂载一个调用者函数，既然要在<code>context</code>上挂载一个函数那么就必须要保证key唯一，因为<code>Symbol</code>可以生成一个唯一的值，所以这里用到了<code>Symbol</code>。</p>
<h2 id="二-functionprototypeapply实现">二. Function.prototype.apply实现</h2>
<p>如果看懂了<code>call</code>是如何实现了之后，<code>apply</code>就很好实现了，因为它们两者不同的地方就是传递的参数不同。</p>
<pre><code class="language-js">Function.prototype.apply = function(context = window) {
    // 创建一个唯一值 防止context或者window有相同的key
    const symbol = Symbol()
    context[symbol] = this // 这里的this是调用者 也就是函数
    const args = arguments[1] || []
    const ret = context[symbol](...args)
    delete context[symbol] // 删除我们添加的属性 不修改传进来的对象或者污染全局变量
    return ret
}

function fn() {
    console.log(this.name)
}

fn.apply({name: &quot;Little Boy&quot;}, []) // Little Boy
</code></pre>
<h2 id="三-functionprototypebind实现">三. Function.prototype.bind实现</h2>
<p><code>bind</code>的方法有两种用法，一种是直接调用，另一种是<code>new</code>的方式调用。实现代码如下：</p>
<pre><code class="language-js">Function.prototype.bind = function(context = window) {
    // 创建一个唯一值 防止context或者window有相同的key
    const symbol = Symbol()
    context[symbol] = this // 这里的this是调用者 也就是函数
    const firstArgs = Array.from(arguments).slice(1) // 获取第一次调用的参数
    return function() {
        const secondArgs = Array.from(arguments) // 获取第二次传入的参数
        const fn = context[symbol] // 获取调用函数
       return this === window ? context[symbol](...[...firstArgs, ...secondArgs]) : fn(...[...firstArgs, ...secondArgs])
    }
}
const obj = {
    language: &quot;javascript&quot;
}

function fn(...arg) {
    console.log(&quot;The current language is &quot; + this.language)
    console.log(arg)
}
const newFn = fn.bind(obj, 1, 2)
newFn(3, 4) // The current language is javascript，[1, 2, 3, 4]
new newFn(3, 4) // The current language is undefined，{}
</code></pre>
<p>代码看到这里，疑问也会非常的多，大概有如下问题：</p>
<ol>
<li><code>bind</code>函数内部<code>this === widnow</code>为什么要这样判断，判断依据是上面。</li>
<li><code>bind</code>函数内部的<code>fn</code>，为什么要赋值给<code>fn</code>后再调用呢。</li>
</ol>
<p>首先第一个问题，如果不<code>new</code>的情况下，函数内部的<code>this = window</code>的（这个是this指向问题，如果有问题请补充这方面的知识），<code>new</code>的话，函数内部的<code>this</code>是等于实例的（这个是原型与原型链的文体局，如果有问题请自行补充这方面的知识）。但是这样为什么要做判断呢，因为两种情况返回的是不同的，不<code>new</code>的情况下是返回函数的返回值，<code>new</code>的情况下是返回实例，这就是为什么<code>bind</code>里面要做这样的判断。</p>
<p>第二个问题，我们使用bind会发现，<code>new</code>的时候函数内部的<code>this</code>是指向<code>window</code>的（注意这里是函数内部的<code>this</code>，第一个问题的<code>this</code>是<code>bind</code>里面的），那这个<code>fn</code>就是我想达到<code>this</code>指向<code>window</code>的目的（这个是this指向问题，如果有问题请补充这方面的知识）。</p>
<p>最后，希望这篇文章帮助大家对<code>call</code>、<code>apply</code>、<code>bind</code>的理解。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6元编程]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/es6-yuan-bian-cheng/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/es6-yuan-bian-cheng/">
        </link>
        <updated>2020-09-07T03:32:58.000Z</updated>
        <content type="html"><![CDATA[<p>前言：</p>
<p>很多小伙伴都致力于项目中的业务，这些业务并不会接触到元编程或者说可以使用其他的编写方式来代替这种元编程，元编程就是对js编程，对编程语言的编程，这样说可能有点抽象，简单的说就是js没有提供的方法，但是js预留了接口让我们自己去实现功能，这就是元编程。</p>
<h2 id="一-元编程之symboltoprimitive">一. 元编程之Symbol.toPrimitive</h2>
<p><code>Symbol.toPrimitive</code>是ES6新增的属性，它是对象的一个属性，它指向一个方法。这个对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。什么意思呢，看例子：</p>
<pre><code class="language-js">let obj = {
    [Symbol.toPrimitive](hint) {
        switch(hint) {
            case 'number': // 该场合需要转成数值
                return 100
            case 'string': // 该场合需要转成字符串
                return 'str'
            case 'default': // 该场合可以转成数值也可以转成字符串
                return 'default'
            default: // 只有上面三种情况 其他情况报错
                throw Error()
        }
    }
}

2 * obj // 200
3 + obj // '3default'
obj == 'default' // true
String(obj) // 'str'
</code></pre>
<p>我们来看上面的例子， <code>2 * obj</code>由于js乘法运算需要隐式类型转换成<code>Number(2) * Number(obj)</code>，所以<code>2 * 100 = 200</code>，<code>3 + obj</code>与<code>obj == 'default'</code>原理一样，obj可以是数值也可以是字符串，最后一个没有隐式转换很容易就理解。</p>
<p>了解了<code>Symbol.toPrimitive</code>怎么使用了之后，有这么一个需求：变量num，它即等于1，即等于2，即等于3。在正常的js中我们是无法实现的，但是有了js给我们预留的接口之后，我们就可以实现想要的功能。</p>
<p>实现如下：</p>
<pre><code class="language-js">let num = {
    [Symbol.toPrimitive]: ((i) =&gt; () =&gt; ++i)(0)
}
if (num == 1 &amp;&amp; num == 2 &amp;&amp; num == 3) {
    console.log(&quot;进来了&quot;) // 这里是可以看到输出结果的
}
</code></pre>
<h2 id="二-元编程之tco_enabled">二. 元编程之TCO_ENABLED</h2>
<p>在了解<code>TCO_ENABLED</code>之前先了解什么是尾递归，尾递归相对于传统的递归来说，性能更好，性能更好体现在尾递归是不断的调用自身，并将上一次得到的值传递给下一次调用，这个过程是线性的，尾递归只需要保存一个调用记录，不容易会发生栈溢出的风险。而传统递归需要保存大量的调用记录，很容易发生栈溢出错误。</p>
<p>虽然尾递归对于性能优化来说是一个不错的选择，但是目前的浏览器中并没有开启尾递归，原因就是使用了尾递归了之后，假设在某一个环节发生错误的时候我们是捕获不到的，因为它没有保留一个调用栈（call stack），在ES6/ES7就已经通过了这个提案，但是浏览器默认没有支持。</p>
<p>虽然浏览器默认没有帮我们打开尾递归支持，但是js也给我们预留了接口去开启尾递归，只需要在代码中添加<code>TCO_ENABLED=true</code>就开启了尾递归优化。</p>
<h2 id="三-元编程之proxy">三. 元编程之Proxy</h2>
<p><code>Proxy</code>可以理解成，在目标对象之前架设了一层“拦截”，外界对该对象进行访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。通过例子认识Proxy：</p>
<pre><code class="language-js">const obj = {
    name: &quot;Little Boy&quot;
}
const proxy = new Proxy(obj, {
    set: function(target, propKey, value) {
        if (propKey === 'name' &amp;&amp; typeof value !== 'string') {
            throw Error(&quot;name 属性必须是字符串&quot;)
        }
    }
})
proxy.name = 123 // Uncaught Error: name 属性必须是字符串
</code></pre>
<p>上面的例子是给对象obj做了一层代理，在set方法里有个判断是如果修改的key是name并且值不是字符串的时候就会抛出错误。</p>
<p>如果想要深入了解Proxy是如何使用的，可以查看阮一峰的《ECMAScript 6 入门》<a href="https://es6.ruanyifeng.com/#docs/proxy">https://es6.ruanyifeng.com/#docs/proxy</a>。</p>
<h2 id="四-元编程之reflect">四. 元编程之Reflect</h2>
<p><code>Reflect</code>也称为反射，将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。<code>Reflect</code>对象上的方法与普通对象上的方法不同的地方就是：它返回的结果并不会报错，而是返回一个布尔值代表调用成功与否。</p>
<p><code>Reflect</code>是纯粹的元编程，直接被底层代理走，但是在<code>Reflect</code>对象可以用的方法目前还是非常的少。我们使用<code>reflect-meta</code><a href="https://www.npmjs.com/package/reflect-metadata">https://www.npmjs.com/package/reflect-metadata</a>，简单的例子认识<code>Reflect</code>：</p>
<p>因为<code>Reflect</code>默认方法很少，所以这里使用<code>reflect-meta</code>，使用之前请使用<code>npm</code>安装<code>reflect-meta</code></p>
<pre><code class="language-js">require(&quot;reflect-metadata&quot;)
class C {
  methods() {}
}
// 在methods添加一个name的属性，值为Little Boy
Reflect.defineMetadata(&quot;name&quot;, &quot;Little Boy&quot;, C.prototype, &quot;methods&quot;)
let obj = new C()
// 在methods获取name属性
let name = Reflect.getMetadata(&quot;name&quot;, obj, &quot;methods&quot;)
console.log(name) // Little Boy
</code></pre>
<p>这个例子是在拓展类的方法，但是我们要知道的是，在类中拓展方法，面向对象的语言中是不允许去操作类中的东西的，在js中虽然可以，但是不建议，建议使用上面这种方式去拓展类中的方法。</p>
<p>想要更深入的了解<code>Reflect</code>，可以查看阮一峰的《ECMAScript 6 入门》<a href="https://es6.ruanyifeng.com/#docs/reflect">https://es6.ruanyifeng.com/#docs/reflect</a>。</p>
<p>最后，希望小伙伴们对元编程有一个新的了解。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript-面试题（一）]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/mian-shi-ti/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/mian-shi-ti/">
        </link>
        <updated>2020-09-04T02:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="常见面试题">常见面试题</h1>
<h3 id="1-请写出如下代码输出值-考察作用域">1. 请写出如下代码输出值。（考察作用域）</h3>
<pre><code class="language-js">console.log(a);
console.log(typeof fn(a));
var flag = true;
if (!flag) {
    var a = 1;
}
if (flag) {
    function fn(a) {
        fn = a;
        console.log(&quot;fn1&quot;);
    }
} else {
    function fn(a) {
        fn = a;
        console.log(&quot;fn2&quot;);
    }
}
</code></pre>
<p>答案是：undefined、报错（<code>fn is not a function</code>）</p>
<p>第一个答案相对简单点，因为<code>var a = 1</code>这里变量提升所以输出的时候<code>a=undefined</code>。<br>
第二个输出答对的人相对较少，因为认为方法也会提升，方法是会提升，但是需要注意方法是放在哪个地方。<strong>在块级作用域的地方声明函数，等于var fn = function() {}, 那么var fn会被提升，fn被提升后是undefined，并非是function</strong>，所以第二个是输出<code>fn is not a function</code>。<strong>在严格模式下，如果在<code>if-else</code>下声明方法是会报错的。</strong></p>
<p>拓展题：</p>
<pre><code class="language-js">function fn1() {
    // fn2 = undefined
    // fn3 = undefined
    if (false) {
        function fn2() {
            console.log(&quot;fn2: false&quot;)
        }
    } else {
        var fn3 = function fn2() {
            fn2 = 3
        }
    }
    console.log(typeof fn2)
    fn3()
    console.log(typeof fn2)
}
fn1()
</code></pre>
<p>这里会输出两个undefined，在上面我们已经提到了在块级作用域声明函数，等于<code>var fn = funciton() {}</code>，然后进入if判断，<code>fn3 = function fn2() {...}</code>，然后第一个输出undefined没有任何的问题，然后执行fn3， fn3方法里面<code>fn2 = 3</code>，但是非常可惜这个赋值并没有生效，因为fn2是函数名，在内部是不能被覆盖的，所以外边的fn2依然是undefined。</p>
<h3 id="2-请写出如下代码输出值-考察this指向">2. 请写出如下代码输出值。（考察this指向）</h3>
<pre><code class="language-js">function fn() {
    console.log(this.length);
}
var obj = {
    length: 5,
    method: function() {
        &quot;use strict&quot;;
        fn();
        arguments[0]()
    }
}
const result = obj.method.bind(null);
result(fn, 1);
</code></pre>
<p>答案是：0、2</p>
<p>先不看上面代码是如何执行的，首先<code>bind</code>可以修改函数内部的this指向，但是当bind第一个参数传的是null的时候，这种绑定方式叫做<code>软绑</code>，意思就是说绑了更没绑都一样，方法内部的this还是不变。第二个就是&quot;use strict&quot;严格模式，严格模式的特点就是在这个区域内<code>this = null</code>（使用bind，apply，call传入的第一个参数不为null除外），所以<code>obj.method</code>方法内部的<code>this = null</code>。</p>
<p>然后我们在看这道题，执行<code>fn()</code>，因为没有人去调用它，所以默认是全局调用，那方法里面的this就指向<code>window</code>，<code>window.length</code>等于页面iframe的数量，所以输出0。然后就是<code>arguments[0]()</code>，arguments[0]是参数穿进去的fn，然后因为这个方法是arguments调用的，所以这个函数的this就是arguments，所以第二个输出2。</p>
<p>拓展题：</p>
<pre><code class="language-js">function test(p1, p2, p3) {
    console.log(this.length);
    console.log(this.callee.length); // 这里callee是fn
}

function fn(p) {
    arguments[0](10, 20, 30, 40, 50);
}
fn(test, 10, 20, 30);
</code></pre>
<p>答案是：4、1</p>
<p>看代码之前，有几个东西需要知道的是，<code>fn.length === 形参个数</code>， <code>window.length === 页面iframe的个数</code>。</p>
<p>那么这道题就非常的简单了，因为test方法的this是指向了<code>arguments</code>， 所以arguments.length = 4，输出的是4，第二个是fn.length，等于形参个数1。</p>
<h3 id="3-变量会被gc回收吗考察垃圾回收机制">3. 变量会被GC回收吗?（考察垃圾回收机制）</h3>
<pre><code class="language-js">function test() {
    var a = 10;
    return function() {
        eval(&quot;&quot;);
    }
}
test()();
</code></pre>
<p>答案是：不会</p>
<p>一般情况下，返回的方法里面如果没有用到的参数会被立即回收，里面用到的参数会被保留在这个方法的执行期上下文（lexical envirmoent）。<br>
特殊的三种情况：<br>
下面的这些情况都会将执行期的上下文全部保留，即使没有使用过的依然会被保留。</p>
<ol>
<li>eval：因为系统并没有对eval里面执行的代码进行判断处理。解决办法就是<code>eval</code>修改成<code>window.eval</code></li>
<li>with：因为系统并不知道with传入的对象是否包含对应的字段。所以with方法尽量不要用。</li>
<li>Function：Function的使用方法有两种，参数是非字符串的时候，会立即执行参数里面的东西，里面的变量是当前执行的执行期上下文，如果是字符串，返回的是一个方法，调用的时候里面的变量是全局的，系统并没有对这个进行优化，系统也不知道用没有用到上一层定义的变量，所以将执行期的上下文全部保留。</li>
</ol>
<pre><code class="language-js">function test() {
    const a = 100
    return function() {
        new Function(console.log(a)) // 100
        new Function(&quot;console.log(a)&quot;)() // 报错 a is not defined
    }
}
test()()
</code></pre>
<ol start="4">
<li>try-catch: 欺骗了执行期上下文，延长了作用域链条。</li>
</ol>
<h3 id="4-请写出如下代码输出值-考察原型与原型链">4. 请写出如下代码输出值。（考察原型与原型链）</h3>
<pre><code class="language-js">Object.prototype.a = 'a';
Function.prototype.a = 'a1';
function Person() {};
var person = new Person();
console.log('person.a: ' + person.a);
console.log(person.__proto__.__proto__.constructor.constructor.constructor);
</code></pre>
<p>答案是：person.a：a，function Function() {}</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/prototype.jpeg" alt="" loading="lazy"></figure>
<p>在看这道题之前需要知道的知识点：</p>
<ol>
<li>只有构造函数才有<code>prototype</code>。</li>
<li>构造函数和实例都有<code>__proto__</code>。</li>
<li>构造函数是没有<code>constructor</code>的，只有构造函数的原型才有<code>constructor</code>。</li>
<li>构造函数都是由<code>Function</code>构造出来的。</li>
</ol>
<p>接下来解释这道题的答案（<strong>边看讲解边看配图</strong>）：<br>
第一个：<code>person</code>是<code>Person的实例</code>，那访问<code>person.a</code>因为<code>person</code>并没有a属性，所以上<code>person.__proto__</code>找a，<code>person.__proto__= Person.prototype</code>， 但是<code>Person.prototype</code>也没有a属性，那么就上<code>Person.prototype.__proto__</code>找a，<code>Person.prototype.__proto__ = Object.prototype</code>，所以第一个输出的是a。</p>
<p>第二个：</p>
<pre><code class="language-js">person.__proto__ = Person.prototype
person.__proto__.__proto__ = Person.prototype.__proto__ = Object.prototype
person.__proto__.__proto__.constructor = Object.prototype.constructor = function Object() {}
person.__proto__.__proto__.constructor.constructor = function Object() {}.constructor = function Object() {}.__proto__.constructor = Function.prototype.constructor = function Function() {}
person.__proto__.__proto__.constructor.constructor = function Function() {}.constructor = function Function() {}.__proto__.constructor = Function.prototype.constructor = function Function() {}
</code></pre>
<p>所以答案是<code>function Function() {}</code></p>
<p>未完待续。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[QA测试]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/qa-test/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/qa-test/">
        </link>
        <updated>2020-08-30T12:49:50.000Z</updated>
        <content type="html"><![CDATA[<p>前言：</p>
<p>在开发的过程中，除了代码本身，测试也是重要的一环。测试可以验证代码的正确性，保证项目的稳定性，在项目上线的时候保证不出差错。在开发项目的时候会使用<code>console.log</code>进行测试，这种做法效率不能得到保证，也不能做到自动化测试的优势。测试可以保证重构，由于产品迭代速度很快，迭代后必然存在代码重构的过程，如果有大量的测试用例，就可以大胆的进行重构。</p>
<p>本文将介绍单元测试（Unit Test）、端到端测试（E2E Test）、UI测试、服务端测试（Server Test），例子相对简单，如果想要深入学习可以到对应的官网查看文档，本文也会将对应的官网地址附上。</p>
<h2 id="一-环境搭建">一. 环境搭建</h2>
<p>本篇文章是在node.js环境下进行测试，如果不懂node.js的知识也无关紧要，只需要安装node.js的环境即可。</p>
<blockquote>
<p>Mac下nodejs环境安装</p>
</blockquote>
<p>第一步打开Mac终端，输入<code>brew --version</code>，如果输出类似<code>Homebrew 2.2.16</code>版本文本的话，请继续往下看，否则点击<a href="https://brew.sh/index_zh-cn">https://brew.sh/index_zh-cn</a>安装<code>Homebrew</code></p>
<p>第二步在终端输入<code>brew install node</code>， 等待安装完后，在终端输入<code>node --version</code>出现<code>v12.18.3</code>这样的版本文本的话，说明已经安装成功。</p>
<blockquote>
<p>Window下nodejs环境安装</p>
</blockquote>
<p>请前往<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>下载nodejs安装包，建议下载<code>LTS</code>， 目前最新稳定版本是<code>v12.18.x</code>, 等待安装完后，在终端输入<code>node --version</code>出现<code>v12.18.3</code>这样的版本文本的话，说明已经安装成功。</p>
<h2 id="二-单元测试unit-test">二. 单元测试（Unit Test）</h2>
<blockquote>
<p>什么是单元测试</p>
</blockquote>
<p>通俗的讲就是对你在应用中写的方法或者是类中的某个方法添加测试用例，保证传入的任何值和预期得到的结果一致。</p>
<blockquote>
<p>单元测试实践</p>
</blockquote>
<p>第一步：需要创建一个空的文件夹，然后在这个文件夹的根目录下运行<code>npm init -y</code>。</p>
<p>执行<code>npm init -y</code>的可能会时候出现<img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/npm-init-y-error.jpeg" alt="" loading="lazy">，说明文件夹的名称不符合要求。可以通过修改文件的名称或者执行<code>npm init</code>初始化项目。</p>
<p>第二步：这个案例中使用的断言库<code>jasmine</code>, 测试环境<code>karma</code>, 无头浏览器<code>PhantomJS</code>，测试报表<code>karma-coverage</code>。</p>
<p>在项目的根目录下执行，<code>npm install karma karma-jasmine jasmine-core karma-phantomjs-launcher karma-coverage --save-dev</code></p>
<p>第三步：在项目根目录下创建<code>karma.conf.js</code>文件，这个文件的作用就是当我们在执行测试的时候，程序会默认的根据这个配置执行。</p>
<p>需要更详细的配置请上<a href="http://karma-runner.github.io/5.0/config/configuration-file.html">http://karma-runner.github.io/5.0/config/configuration-file.html</a></p>
<pre><code class="language-js">module.exports = function (config) {
  config.set({
    // 基础路径，用在files，exclude属性上
    basePath: &quot;&quot;,
    // 使用的断言库
    frameworks: [&quot;jasmine&quot;],
    // 载入浏览器的文件
    files: [&quot;./tests/unit/*.js&quot;],
    // 排除文件列表
    // exclude: [&quot;node_modules&quot;],
    // 预处理
    // 可用的预处理: https://npmjs.org/browse/keyword/karma-preprocessor
    preprocessors: {
      &quot;./tests/unit/**/*.js&quot;: [&quot;coverage&quot;],
    },
    //  使用测试结果报告者
    //  可能的值: &quot;dots&quot;, &quot;progress&quot;
    //  可用的报告者：https://npmjs.org/browse/keyword/karma-reporter
    reporters: [&quot;progress&quot;, &quot;coverage&quot;],
    // 服务端口号
    port: 9876,
    // 启用或禁用输出报告或者日志中的颜色
    colors: true,
    // 日志等级
    // 可能的值: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,
    // 启用或禁用自动检测文件变化进行测试
    autoWatch: false,
    // 测试启动的浏览器
    browsers: [&quot;PhantomJS&quot;],
    // 无头浏览器需要改为true
    singleRun: true,
    // 并发级别（启动的浏览器数）
    concurrency: Infinity,
    // coverage报表设置
    // https://www.npmjs.com/package/karma-coverage
    coverageReporter: {
      type: &quot;html&quot;,
      dir: &quot;./docs/coverage/&quot;,
    },
  })
}
</code></pre>
<p>第四步：在项目创建需要的测试文件，单元测试的文件放到了根目录下的tests文件下的unit文件</p>
<p>├── 根目录<br>
├── docs<br>
├── package-lock.json<br>
├── package.json<br>
├── tests<br>
│  └── unit<br>
│      ├── index.js<br>
│      └── index.spec.js<br>
└── yarn.lock</p>
<p>在<code>index.js</code>文件中写入需要测试的方法：</p>
<pre><code class="language-js">function add(x) {
  if (x === 3) {
    return 4
  }
  return Number(x) + 1
}
</code></pre>
<p>在<code>index.spec.js</code>中编写测试用例：</p>
<pre><code class="language-js">describe(&quot;测试工具函数的add方法&quot;, function() {
    it(&quot;参数为数字的时候&quot;, function () {
    expect(add(1)).toBe(2)
  })

  it(&quot;参数为字符串的时候&quot;, function () {
    expect(add(&quot;1&quot;)).toBe(2)
  })
})
</code></pre>
<p>第五步：测试写的方法是否有问题，并且测试的覆盖率是否达到100%</p>
<p>在<code>package.json</code>文件的<code>scripts</code>节点添加<code>&quot;test:unit&quot;: &quot;karma start&quot;</code></p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;unit-test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;test:unit&quot;: &quot;karma start&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;jasmine-core&quot;: &quot;^3.6.0&quot;,
    &quot;karma&quot;: &quot;^5.2.0&quot;,
    &quot;karma-jasmine&quot;: &quot;^4.0.1&quot;,
    &quot;karma-phantomjs-launcher&quot;: &quot;^1.0.4&quot;
  }
}

</code></pre>
<p>然后在根目录下执行<code>npm run test:unit</code>。</p>
<p><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/unit-test-success.png" alt="" loading="lazy">说明测试通过。如果有红色的报错信息，说明你的测试预期的结果不一致。</p>
<p>第六步：虽然测试通过了，但是有个问题是，在add方法中有个if没有测试到。我们不可能通过肉眼去查看我们有哪个部分没有测到，所以需要从测试报表中查看。</p>
<p>在我们执行了第五步后文件目录如下：<br>
├── 根目录<br>
├── docs<br>
│   └── coverage<br>
│       └── PhantomJS\ 2.1.1\ (Mac\ OS\ 0.0.0)<br>
│           ├── base.css<br>
│           ├── block-navigation.js<br>
│           ├── favicon.png<br>
│           ├── index.html<br>
│           ├── index.js.html<br>
│           ├── index.spec.js.html<br>
│           ├── prettify.css<br>
│           ├── prettify.js<br>
│           ├── sort-arrow-sprite.png<br>
│           └── sorter.js<br>
├── karma.conf.js<br>
├── package-lock.json<br>
├── package.json<br>
├── tests<br>
│   └── unit<br>
│       ├── index.js<br>
│       └── index.spec.js<br>
└── yarn.lock</p>
<p>我们打开docs/coverage/PhantomJS\ 2.1.1\ (Mac\ OS\ 0.0.0)/index.html文件，然后就可以在网页上查看测试的覆盖率如下：</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/coverage-nopass.png" alt="" loading="lazy"></figure>
<p>我们可以看到index.js文件的覆盖率达到了66.6%，然后点击网页的index.js进去，网页会告诉我们哪个位置没有测试到：<br>
<img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/coverage-nopass-location.png" alt="" loading="lazy"></p>
<p>第七步：根据没有测试到的位置添加测试用例，这里就不再演示。</p>
<p>案例源码：<a href="https://github.com/zhourengui/blog-example/tree/master/QA%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88Unit%20Test%EF%BC%89">https://github.com/zhourengui/blog-example/tree/master/QA测试/单元测试（Unit Test）</a></p>
<p><code>jasmine</code>官方文档<a href="https://jasmine.github.io/api/edge/global">https://jasmine.github.io/api/edge/global</a></p>
<h2 id="三端到端测试e2e-test">三.端到端测试（E2E Test）</h2>
<blockquote>
<p>什么是端到端测试</p>
</blockquote>
<p>一般公司测试页面都是人工去点击页面上的东西，如果点不出bug就说明没有问题，这种做法相对于做自动化测试来说减少了编写代码的时间，但是并不能达到测试的最终目的，所以为了上线后项目的稳定性，我们不得不去做这种端到端的自动化测试。</p>
<blockquote>
<p>端到端测试实践</p>
</blockquote>
<p>第一步：请参照单元测试（Unit Test）第一步。</p>
<p>第二步：打开终端，路径切换到创建的文件根目录下，执行<code>npm install selenium-webdriver</code>。</p>
<p>第三步：下载对应的无头浏览器脚本。（这里以Chrome为例）。</p>
<p>Chrome下载地址：<a href="http://chromedriver.storage.googleapis.com/index.html?path=85.0.4183.87/">http://chromedriver.storage.googleapis.com/index.html?path=85.0.4183.87/</a></p>
<p>其他浏览器可查看：<a href="https://www.npmjs.com/package/selenium-webdriver">https://www.npmjs.com/package/selenium-webdriver</a>找到对应的浏览器。</p>
<p>下载完后有一个脚本文件，将脚本文件放到我们项目的根目录下。</p>
<p>第四步：在项目创建需要的测试文件，端到端测试的文件放到了根目录下的tests文件下的e2e文件</p>
<p>├── 根目录<br>
├── README.md<br>
├── chromedriver<br>
├── docs<br>
├── package.json<br>
├── tests<br>
│   └── e2e<br>
│       ├── browser.js<br>
│       ├── toast.js<br>
│       └── wait.js<br>
├── yarn-error.log<br>
└── yarn.lock</p>
<p>第五步：添加测试命令</p>
<p>修改<code>package.json</code>文件的<code>scripts</code>节点</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;e2e-test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;e2e:browser&quot;: &quot;node ./tests/e2e/browser.js&quot;,
    &quot;e2e:wait&quot;: &quot;node ./tests/e2e/wait.js&quot;,
    &quot;e2e:toast&quot;: &quot;node ./tests/e2e/toast.js&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;selenium-webdriver&quot;: &quot;^4.0.0-alpha.7&quot;
  }
}
</code></pre>
<p>第五步：编写测试脚本</p>
<pre><code class="language-html">&lt;!-- 这段代码是下面测试脚本使用iframe的例子 --&gt;
&lt;div id=&quot;modal&quot;&gt;
    &lt;iframe id=&quot;buttonframe&quot; name=&quot;myframe&quot;  src=&quot;https://seleniumhq.github.io&quot;&gt;
        &lt;button&gt;Click here&lt;/button&gt;
    &lt;/iframe&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">// browser.js 这个文件里面的方法都是对浏览器的操作
const { Builder, By } = require(&quot;selenium-webdriver&quot;)
const fs = require(&quot;fs&quot;)

;(async () =&gt; {
  let driver = await new Builder().forBrowser(&quot;chrome&quot;).build() // 打开无头浏览器
  try {
    // 浏览器导航
    await driver.get(&quot;https://www.baidu.com&quot;) // 跳转到目标地址
    const currentUrl = await driver.getCurrentUrl() // 获取当前url地址
    // currentUrl = https://www.baidu.com
    await driver.navigate().back() // 浏览器的后退按钮
    await driver.navigate().forward() // 浏览器的前进按钮
    await driver.navigate().refresh() // 浏览器刷新
    const pageTitle = await driver.getTitle() // 获取页面标题
    // pageTitle = 百度一下，你就知道
    const windowHandle = await driver.getWindowHandle() // 每个window窗口都有一个唯一标识 这个方法是获取页面标识
    // widnowHandle = CDwindow-7EF1E8C65D989D8EB7DE9190B4B8A7E1
    await driver.switchTo().newWindow(&quot;tab&quot;) // 创建新标签
    await driver.switchTo().newWindow(&quot;window&quot;) // 创建新的window窗口
    // await driver.close() // 关闭窗口
    await driver.switchTo().window(windowHandle) // 切换窗口

    // Iframe操作 因为这部分是模拟的 如果不注释会报错 可以根据实际情况修改
    // 进入Iframe内部 下面的方法选其一
    // 方法一 使用标签获取
    // const iframe = driver.findElement(By.css(&quot;#modal &gt; iframe&quot;))
    // await driver.switchTo().frame(iframe)
    // await driver.findElement(By.css(&quot;button&quot;)).click()
    // // 方法二 使用name或者id 推荐使用这个
    // await driver.switchTo().frame(&quot;buttonframe&quot;)
    // await driver.switchTo().frame(&quot;myframe&quot;)
    // await driver.findElement(By.css(&quot;button&quot;)).click()
    // // 方法三
    // await driver.switchTo().frame(1)

    // await driver.switchTo().defaultContent() // 退出iframe

    // window管理
    const { width, height, x, y } = await driver.manage().window().getRect() // 获取窗口的宽高 位置
    // width=1200 height=927 x=22 y=45
    await driver
      .manage()
      .window()
      .setRect({ width: 1024, height: 768, x: 100, y: 100 }) // 设定窗口大小和位置

    await driver.manage().window().maximize() // 窗口最大化
    await driver.manage().window().minimize() // 窗口最小化
    await driver.manage().window().fullscreen() // 全屏窗口

    const screenEncodeString = driver.takeScreenshot() // 截屏
    // await fs.writeFileSync(&quot;./image.png&quot;, screenEncodeString, &quot;base64&quot;) 可以将截到的数据写入一个文件中

    await driver.get(&quot;https://www.baidu.com&quot;)
    const ele = await driver.findElement(By.id(&quot;lg&quot;)) // 获取元素
    const eleEncodedString = await ele.takeScreenshot(true) // 截取获取到的元素
    await fs.writeFileSync(&quot;./image.png&quot;, eleEncodedString, &quot;base64&quot;) // 写入文件

    // await driver.wait(() =&gt; {}, 3000) // 这个是让程序等待3秒 因为没有这个整个过程太快了所以可以打开这个注释。
  } finally {
    await driver.quit() // 退出浏览器
  }
})()
</code></pre>
<p>到这里就可以测试上面编写的浏览器的脚本，在项目根目录执行<code>npm run e2e:browser</code></p>
<pre><code class="language-js">// await.js 是对等待方法的讲解
const { Builder, until, By } = require(&quot;selenium-webdriver&quot;)
const assert = require(&quot;assert&quot;)
// 这个文件是等待的方法
// Selenium客户可以使用命令式，程序性语言进行显式等待。
// 它们允许您的代码暂停程序执行或冻结线程，直到传递给它的条件解决为止。
// 以一定的频率调用该条件，直到等待超时超时为止。这意味着只要条件返回虚假值，它将一直尝试并等待。
;(async () =&gt; {
  let driver = await new Builder().forBrowser(&quot;chrome&quot;).build() // 打开无头浏览器
  try {
    await driver.get(&quot;https://www.baidu.com&quot;)
    // 因为等待将不会吞没找不到元素时引发的此类元素错误，所以条件将重试直到找到元素。然后它将使用返回值WebElement，并将其传递回我们的脚本。
    // 如果条件失败，例如从未达到该条件的真实返回值，则等待将抛出/引发一个错误/异常，称为超时错误。
    let ele = await driver.wait(until.elementLocated(By.css(&quot;p&quot;)), 10000)
    let foo = await ele.getText()
    assert(foo == &quot;Hello from JavaScript&quot;)
  } finally {
    await driver.quit() // 退出浏览器
  }
})()

</code></pre>
<p>到这里就可以测试上面编写的等待方法的脚本，在项目根目录执行<code>npm run e2e:wait</code></p>
<pre><code class="language-js">// toast.js 这个文件里面的东西是如何模拟浏览器弹窗 点击确认按钮 点击关闭按钮 提示信息等
const { Builder, until, By } = require(&quot;selenium-webdriver&quot;)
// 这个文件里面的东西是如何模拟浏览器弹窗 点击确认按钮 点击关闭按钮 提示信息等
;(async () =&gt; {
  let driver = await new Builder().forBrowser(&quot;chrome&quot;).build() // 打开无头浏览器
  try {
    await driver.get(&quot;https://www.baidu.com&quot;) // 跳转到目标地址
    await driver.findElement(By.className(&quot;qrcode-layer&quot;)).click() // 这个是模拟点击后出现弹窗
    // 要想继续走下去必须到弹出的网页的console面板 alert(xxx)不然一直卡在这
    await driver.wait(until.alertIsPresent()) // 这个地方会监听网页上是否有弹窗
    let alert = await driver.switchTo().alert()
    let alertText = await alert.getText()
    await alert.sendKeys(&quot;Selenium&quot;) // 这个东西是用在window.promt 替换占位符文本 想要验证这个必须在网页的控制台输入window.promt()
    await alert.accept() // 这个是模拟点击确认按钮
    await alert.dismiss() // 这个是模拟点击取消按钮
    await driver.wait(() =&gt; {}, 10000)
  } finally {
    await driver.quit() // 退出浏览器
  }
})()
</code></pre>
<p>到这里就可以测试上面编写的弹窗方法的脚本，在项目根目录执行<code>npm run e2e:toast</code></p>
<p>案例源码：<a href="https://github.com/zhourengui/blog-example/tree/master/QA%E6%B5%8B%E8%AF%95/%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%8B%E8%AF%95%EF%BC%88E2E%20Test%EF%BC%89">https://github.com/zhourengui/blog-example/tree/master/QA测试/端到端测试（E2E Test）</a></p>
<p>这里就举例了常用的例子，如果想要深入的了解其他api可以到<code>selenium</code>官网<a href="https://www.selenium.dev/documentation/en/">https://www.selenium.dev/documentation/en/</a></p>
<h2 id="四-ui测试ui-test">四. UI测试（UI Test）</h2>
<blockquote>
<p>什么是UI测试</p>
</blockquote>
<p>UI测试是为了测试前端写的页面是否还原了设计稿，UI测试可以测出1px的像素差，阴影等，再也不用管UI设计师BB（赞美）这里没对齐那里没对齐，这里差了1像素的废话。</p>
<blockquote>
<p>UI测试实践</p>
</blockquote>
<p>第一步：参考单元测试的第一步。</p>
<p>第二步：全局安装<code>backstopjs</code>, 在终端执行<code>npm install -g backstopjs</code>,这个过程有点久。</p>
<p>第三步：在创建文件的根目录下执行<code>backstop init</code>, 这时候会生成<code>backstop_data</code>和<code>backstop.json</code>两个文件。</p>
<p>第四步：这个UI测试不需要编写测试的脚本，只需要配置和把需要对比的图片放到指定目录，接下来就是配置教程。</p>
<pre><code class="language-json">// backstop.json 请注意的是 json不允许注释，这里为了讲述必要的字段配置加的注释
{
  &quot;id&quot;: &quot;Tencent Mobile Map&quot;,
  &quot;viewports&quot;: [ // 这里是配置需要测试的尺寸 我这里选中iphone6的尺寸
    {
      &quot;label&quot;: &quot;phone6&quot;,
      &quot;width&quot;: 375,
      &quot;height&quot;: 667
    },
  ],
  &quot;onBeforeScript&quot;: &quot;puppet/onBefore.js&quot;, // 这个脚本会去找 backstop_data/engine_scripts/puppet/onBefore.js
  &quot;onReadyScript&quot;: &quot;puppet/onReady.js&quot;, // 这个脚本会去找 backstop_data/engine_scripts/puppet/onReady.js
  &quot;scenarios&quot;: [ // 配置要匹配的页面
    {
      &quot;label&quot;: &quot;BackstopJS Homepage&quot;,
      &quot;cookiePath&quot;: &quot;backstop_data/engine_scripts/cookies.json&quot;, // 这个会去找 backstop_data/engine_scripts/cookiePath.json 如果网页需要cookie的使用可以通过这个配置
      &quot;url&quot;: &quot;https://map.qq.com/m/&quot;, // 这里用的是腾讯地图页面
      &quot;referenceUrl&quot;: &quot;&quot;,
      &quot;readyEvent&quot;: &quot;&quot;,
      &quot;readySelector&quot;: &quot;&quot;,
      &quot;delay&quot;: 0,
      &quot;hideSelectors&quot;: [],
      &quot;removeSelectors&quot;: [],
      &quot;hoverSelector&quot;: &quot;&quot;,
      &quot;clickSelector&quot;: &quot;&quot;,
      &quot;postInteractionWait&quot;: 0,
      &quot;selectors&quot;: [],
      &quot;selectorExpansion&quot;: true,
      &quot;expect&quot;: 0,
      &quot;misMatchThreshold&quot; : 0.1,
      &quot;requireSameDimensions&quot;: true
    }
  ],
  &quot;paths&quot;: {
    &quot;bitmaps_reference&quot;: &quot;backstop_data/bitmaps_reference&quot;, // 需要对比的图片 这里就是存放ui做的图
    &quot;bitmaps_test&quot;: &quot;backstop_data/bitmaps_test&quot;,
    &quot;engine_scripts&quot;: &quot;backstop_data/engine_scripts&quot;, // 引擎脚本路径 不要修改
    &quot;html_report&quot;: &quot;./docs/backstop_data/html_report&quot;, // 报表存放路径
    &quot;ci_report&quot;: &quot;backstop_data/ci_report&quot; // ci报表存放路径
  },
  &quot;report&quot;: [&quot;browser&quot;],
  &quot;engine&quot;: &quot;puppeteer&quot;,
  &quot;engineOptions&quot;: {
    &quot;args&quot;: [&quot;--no-sandbox&quot;]
  },
  &quot;asyncCaptureLimit&quot;: 5,
  &quot;asyncCompareLimit&quot;: 50,
  &quot;debug&quot;: false,
  &quot;debugWindow&quot;: false
}
</code></pre>
<p>到这里就可以在项目根目录执行<code>backstop test</code>,这时候会弹出个窗口，如果没有弹出可以点开<code>docs/backstop_data/html_report/index.html</code>。<br>
如图：</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/backstop-html_report.png" alt="" loading="lazy"></figure>
<p>可以有红色的报错，这个报错是因为我们还没有把对比的图放到指定的位置上, <code>/backstop_data/bitmaps_reference/TencentMobileMap_BackstopJS_Homepage_0_document_0_phone6.png</code>文件路径一定要跟网页上的一致，包括图片的文件名。</p>
<p>添加后，重新在根目录执行<code>backstop test</code></p>
<p>如图：</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/backstop-html_report1.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/backstop-html_report2.png" alt="" loading="lazy"></figure>
<p>图中可以看到，设计稿和网页上的diff，如果有问题找到相应的位置修改。</p>
<p>案例源码：<a href="https://github.com/zhourengui/blog-example/tree/master/QA%E6%B5%8B%E8%AF%95/UI%E6%B5%8B%E8%AF%95%EF%BC%88UI%20Test%EF%BC%89">https://github.com/zhourengui/blog-example/tree/master/QA测试/UI测试（UI Test）</a></p>
<p>实际项目中肯定会比这复杂得多，更多配置请到backstopjs官网查看<a href="https://github.com/garris/BackstopJS">https://github.com/garris/BackstopJS</a></p>
<h2 id="服务端测试server-test">服务端测试（Server Test）</h2>
<blockquote>
<p>什么是服务端测试</p>
</blockquote>
<p>测试接口返回的数据是否跟预期的一致。这里使用到<code>mocha</code>断言库，报表使用<code>mochawesome</code>。</p>
<blockquote>
<p>服务端测试实践</p>
</blockquote>
<p>第一步：参照单元测试的第一步。</p>
<p>第二步：编写一个简单的接口, 在根目录下创建<code>server.js</code>, 并在根目录下执行<code>npm install express</code></p>
<pre><code class="language-js">const express = require(&quot;express&quot;)
const app = express()
app.get(&quot;/test&quot;, (req, res) =&gt;
  res.json({ code: 0, payload: null, message: null })
)
app.listen(3000, () =&gt; {
  console.log(&quot;server starting 3000&quot;)
})
module.exports = app
</code></pre>
<p>然后在项目根目录下执行<code>node server.js</code></p>
<p>第三步：在项目根目录下创建tests/index.spec.js文件，然后编写测试用例。并在项目根目录下执行<code>npm install supertest mobcha mochawesome</code>, <code>supertest</code>这个插件是做代理的。<code>mobcha</code>是用来断言的。<code>mochawesome</code>测试后的报表。</p>
<pre><code class="language-js">// index.spec.js
const superagent = require(&quot;supertest&quot;)
const app = require(&quot;../server&quot;)

describe(&quot;接口测试&quot;, function () {
  it(&quot;test接口测试&quot;, function (done) {
    superagent(app.listen())
      .get(&quot;/test&quot;)
      .expect(200)
      .expect(&quot;Content-Type&quot;, /json/)
      .end(function (err, res) {
        err &amp;&amp; done(err)
        let flag = false
        const dataKey = Object.keys(res.data)
        flag = !(dataKey.includes(&quot;payload&quot;) &amp;&amp; dataKey.includes(&quot;code&quot;))
        flag ? new Error(&quot;数据接口字段返回不准确&quot;) : done()
      })
  })
})
</code></pre>
<p>第四步：编写tests/index.js启动脚本</p>
<pre><code class="language-js">// /tests/index.js
const Mocha = require(&quot;mocha&quot;)
var mocha = new Mocha({
  reporter: &quot;mochawesome&quot;,
  reporterOptions: {
    reportDir: &quot;./docs/mochawesome-report&quot;,
    // quiet: true
  },
})
mocha.addFile(&quot;./tests/index.spec.js&quot;)
mocha.run(function () {
  process.exit()
})

</code></pre>
<p>然后执行node ./tests.index.js，然后会在根目录下生成./docs/mochawesome-report报表，点击html文件就可以查看报表了。<br>
如图：</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/zhourengui/blog-image/master/server-test.png" alt="" loading="lazy"></figure>
<p>案例源码<a href="https://github.com/zhourengui/blog-example/tree/master/QA%E6%B5%8B%E8%AF%95/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%8B%E8%AF%95%EF%BC%88Server%20Test%EF%BC%89">https://github.com/zhourengui/blog-example/tree/master/QA测试/服务端测试（Server Test）</a></p>
<p>实例的开发中肯定是比这个复杂得多，如果有其他的需求，请前往<code>mocha</code><a href="https://mochajs.org/">https://mochajs.org/</a>查看api。</p>
<p>最后，希望这篇文章对您有帮助。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数式编程]]></title>
        <id>https://github.com/zhourengui/zhourengui.github.io/han-shu-shi-bian-cheng/</id>
        <link href="https://github.com/zhourengui/zhourengui.github.io/han-shu-shi-bian-cheng/">
        </link>
        <updated>2020-08-28T09:00:29.000Z</updated>
        <content type="html"><![CDATA[<p>前言：</p>
<p><code>函数式编程</code>是编程范式中的一种，是一种典型的编程思想和方法。其他的编程范式还包括<code>面向对象编程</code>、<code>逻辑编程</code>等。</p>
<p><code>函数式编程</code>不是用函数来编程， 也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数。运算过程尽量写成一系列嵌套的函数调用。</p>
<p><code>函数式编程</code>只是范畴论的运算方法，跟数理逻辑、微积分、 行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。为什么函数式编程要求函数必须是纯的，不能有副作用?因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。</p>
<p>为什么要学习<code>函数式编程</code> ? 函数式编程的最大的特点就是<code>纯</code>， 没有任何的副作用，没有任何的依赖，对于代码的review，重构起着重大的作用。（当看过一个耦合度非常高的项目的时候，你会发现函数式编程之美）</p>
<h2 id="一-函数式编程的特点">一. 函数式编程的特点</h2>
<ol>
<li>函数与其他数据类型一样， 可以赋值给其他变量，也可以是参数，传入另一个函数，或者是别的函数的返回值。</li>
<li>只用<code>表达式</code>，不用<code>语句</code></li>
<li>没有<code>副作用</code></li>
<li>不修改状态</li>
<li>函数运行只靠参数</li>
</ol>
<h2 id="二-深入学习函数式编程">二. 深入学习函数式编程</h2>
<h3 id="1-纯函数">1. 纯函数</h3>
<blockquote>
<p>纯函数的特点</p>
</blockquote>
<ol>
<li>相同的输入，会得到相同的输出</li>
<li>没有任何的副作用</li>
<li>不依赖外部环境的状态</li>
</ol>
<blockquote>
<p>通过例子认识纯函数</p>
</blockquote>
<pre><code class="language-js">// 举一个是纯函数的例子：  
const arr = [1, 2, 3, 4, 5]
arr.slice(0, 3) // [1, 2, 3]
arr.slice(0, 3) // [1, 2, 3]
arr.slice(0, 3) // [1, 2, 3]
arr.slice(0, 3) // [1, 2, 3]
</code></pre>
<p><code>slice</code>传入的相同的参数，输出都是相同的，没有任何的依赖，没有任何的副作用（arr数组没有变化），说明<code>Array.ptototype.slice</code>是个纯函数</p>
<pre><code class="language-js">// 举一个不是纯函数的例子：
const minAge = 20
const checkAge = age =&gt; age &gt; minAge
</code></pre>
<p>由于<code>checkAge</code>方法依赖了minAge这个变量，所以<code>checkAge</code>不是纯函数，可以将<code>checkAge</code>修改成<code>const checkage = age =&gt; age &gt; 20</code>。</p>
<blockquote>
<p>问题思考？</p>
</blockquote>
<p>假如需要另一个函数判断传入的年龄是否是大于21，大于22。。。 那不得不重写一个方法，这样一个最大的问题就是拓展性不好。下一节的<code>柯里化函数</code>可以得到答案。</p>
<h3 id="2-柯里化函数">2. 柯里化函数</h3>
<blockquote>
<p>☝️上一节的答案</p>
</blockquote>
<pre><code class="language-js">// 使用柯里化解决上一节的问题
const checkAge = min =&gt; (age =&gt; age &gt; min)
const checkAge21 = checkAge(21)
checkAge21(22)
checkAge21(23)
checkAge21(25)
const checkAge22 = checkAge(22)
checkAge21(22)
</code></pre>
<p><code>checkAge</code>方法与上一节的实现多了一层<code>function</code>, 从举的例子也不难看出，这样的定义非常的灵活，拓展性也非常好。</p>
<blockquote>
<p>柯里化函数的特点</p>
</blockquote>
<p>传递给函数一部分参数，返回另一个函数去处理剩下的参数</p>
<blockquote>
<p>什么是柯里化</p>
</blockquote>
<p><code>柯里化函数</code>是一种“预加载”函数的方法，通过传递较少的参数，返回另一个函数，这个函数通过保留执行期的上下文<code>（闭包）</code>缓存了第一次传入的参数，是一种非常高效的编写函数的方法。</p>
<h3 id="3-函数组合">3. 函数组合</h3>
<blockquote>
<p>什么是函数组合</p>
</blockquote>
<p>需要多个函数有顺序的处理得到的结果，把这些函数合并成一个函数就是函数组合。</p>
<blockquote>
<p>通过例子认识函数组合</p>
</blockquote>
<pre><code class="language-js">const compose = (...fns) =&gt; (...args) =&gt; {
    const fnLength = fns.length
    if (fnLength === 0) return arg =&gt; arg
    if (fnLength === 1) return fns[0](...args)
    return fns.reduce((pre, current = arg =&gt; arg) =&gt; (pre(current(...args))))
}
function fn1(arr) {
    console.log(arr)
}

function fn2(arr) {
    return arr.splice(3)
}
compose(fn1)([1, 2, 3, 4])
</code></pre>
<p>上面定义了一个<code>compose</code>方法，这个方法把传入的所有方法组合起来，方法调用顺序从右向左。</p>
<h3 id="4-point-free">4. Point Free</h3>
<blockquote>
<p>什么是Point Free</p>
</blockquote>
<p>对象自带的防范转化成纯函数，不要命名转瞬即逝的中间变量，这样说可能有点抽象，下面的例子说明的更清楚。</p>
<blockquote>
<p>通过例子认识Point Free</p>
</blockquote>
<p><code>const f = str =&gt; str.toUpperCase().split(' ')</code>这段代码使用了str作为中间变量，这个中间变量除了让代码变得长一点以外毫无意义。</p>
<p>我们可以使用函数组合进行修改</p>
<pre><code class="language-js">const toUpperCase = str =&gt; str.toUpperCase()
const split = x =&gt; (str =&gt; str.split(x))
const f = compose(split(' '), toUpperCase)
f(&quot;test string&quot;)
</code></pre>
<p>这样的编程可以减少不必要的命名，让代码保存简洁和通用。</p>
<h3 id="5-声明式与命令式代码">5. 声明式与命令式代码</h3>
<blockquote>
<p>什么是声明式</p>
</blockquote>
<p>通过编写一条有一条指令去让计算机执行一些操作</p>
<blockquote>
<p>什么是命令式</p>
</blockquote>
<p>通过写表达式的方式来声明要做声明 不是通过一步一步指示</p>
<blockquote>
<p>通过例子认识声明式与命令式代码</p>
</blockquote>
<pre><code class="language-js">// 命令式
const persons  = []
for (let i = 0; i &lt; arr.length; i ++) {
    persons.push(arr[i])
}
// 声明式
const persons = arr.map(p =&gt; p)
</code></pre>
<h3 id="6-惰性求值">6. 惰性求值</h3>
<blockquote>
<p>什么是惰性求值</p>
</blockquote>
<p>一种将对函数或请求处理延迟到真正需要结果时进行的通用概念。有很多应用程序都采用了这种概念，有的非常明显，有些则不太明显。从惰性编程的角度来思考问题，可以帮您消除代码中不必要的计算。</p>
<blockquote>
<p>通过例子认识惰性求值</p>
</blockquote>
<pre><code class="language-js">// 原生js封装ajax
function ajax() {
    //1.创建xhr对象
    //创建xhr对象 - 非IE6
    if (window.XMLHttpRequest) {
        var xhr = new XMLHttpRequest();
    } else { //IE6及其以下版本浏览器
        var xhr = new ActiveXObject('Microsoft.XMLHTTP');
    }
    ...
}
</code></pre>
<p>上面通过原生js封装ajax理解惰性求值，如果我们上面不做任何的处理我们每次调用ajax这个方法的时候，方法内部都会做一次兼容处理，但是呢当第一次调用后，我们就知道了用户的浏览器是否支持ie，所以可以修改如下</p>
<pre><code class="language-js">// 原生js封装ajax
function ajax() {
    //1.创建xhr对象
    //创建xhr对象 - 非IE6
    if (window.XMLHttpRequest) {
        var xhr = new XMLHttpRequest();
    } else { //IE6及其以下版本浏览器
        var xhr = new ActiveXObject('Microsoft.XMLHTTP');
    }
    ajax = xhr
}
</code></pre>
<p>通过这样修改后，当调用一次后<code>ajax=xhr</code>，当第二次调用的时候，就不用去重新判断兼容处理，这样可以提升性能。</p>
<h3 id="7-高阶函数">7. 高阶函数</h3>
<blockquote>
<p>什么是高阶函数</p>
</blockquote>
<p>函数当作参数，把传入的函数做一个封装，然后返回这个封装的函数，达到更高成都的抽象。</p>
<blockquote>
<p>通过例子认识高阶函数</p>
</blockquote>
<pre><code class="language-js">function add(x, y, fn) {
    return fn(x) + fn(y)
}
add(2, 3, (n) =&gt; n * n)
</code></pre>
<p>这就是一个简单的高级函数，只要一个函数接收一个函数作为参数， 这种函数就可以称之为高阶函数。</p>
<h3 id="8-尾递归尾调用">8. 尾递归（尾调用）</h3>
<blockquote>
<p>什么是尾递归</p>
</blockquote>
<p>函数内部的最后一个动作是函数调用。该调用的返回值直接返回给函数。函数调用自身成为递归。如果尾调用自身，就成为尾递归。递归需要保存大量的调用记录, 很容易发生栈溢出错误，如果使用尾递归优化， 将递归变为循环， 那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。</p>
<blockquote>
<p>通过例子认识尾递归（尾调用）</p>
</blockquote>
<pre><code class="language-js">// 斐波那契数列 正常递归
function factorial(n) {
    if (n === 1) return 1
    return n * factorial(n - 1)
}

// 使用尾递归
function factorial(n, total) {
     if (n === 1) return total;
    return factorial(n - 1, n * total);
}
</code></pre>
<blockquote>
<p>尾递归的优点</p>
</blockquote>
<p>整个调用过程是线性的，调用一次后就会进入下一个栈，相关的数据信息跟随进入， 不保留在栈堆上，有效的防止堆栈溢出</p>
<h3 id="9-闭包">9. 闭包</h3>
<blockquote>
<p>什么是闭包?</p>
</blockquote>
<p>在某个块区域保留了父级以及父级以上的执行期上下文，这就是闭包，由于闭包网上有很多的资料，这里不做太多的赘述。</p>
<h3 id="10-容器范畴与函子funcctor">10. 容器（范畴）与函子（Funcctor）</h3>
<blockquote>
<p>什么是范畴</p>
</blockquote>
<ol>
<li>范畴就是容器，容器包含两样东西。值和值的变形关系（函数）</li>
<li>值的变形关系（函数）可以用于同一个容器的转换， 也可以用于将一个容器专程另一个容器。</li>
</ol>
<blockquote>
<p>什么是函子</p>
</blockquote>
<p>函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。他首先是一种范畴，换句话说，函子也是容器，他也包含了容器的两样东西，只不过他的变形关系可以依次作用于每一个值，将当前的容器变形成另一个容器。</p>
<p>函子是一个对于函数调用的抽象， 赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选中何时何地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等特性。</p>
<blockquote>
<p>通过例子认识函子</p>
</blockquote>
<p><strong>函子的特点</strong></p>
<ol>
<li>任何具有map方法的数据结构，都可以当作函子的实现。</li>
<li>函数式编程一般约定，函子（Functor）有一个of方法, 用来生成新 的容器。</li>
<li>函子（Functor）遵守一些特定规则的容器类型。</li>
<li>函子（Functor） 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等特性。</li>
</ol>
<p>根据上面的特点用代码实现</p>
<pre><code class="language-js">class Functor {
    constructor(x) {
        this.__value = x
    }
    // 一般约定，函子的标志就是容器具有map方法。该方法将容器 里面的每一个值，映射到另一个容器。
    map(f) {
        return Functor.of(f(this.__value))
    }
    // 函数式编程一般约定，函子（Functor）有一个of方法
    static of(x) {
        return new Functor(x)
    }
}

// 使用如下
Functor.of(2)
.map(x =&gt; x + 1)  // Functor(3)
.map(x =&gt; x * 2) // Functor(6)
</code></pre>
<p>上面代码中，Functor是一个函子，它的map方法接受函数f作为 参数，然后返回一个新的函子，里面包含的值是被f处理过的 (f(this.val))。<br>
函数式编程里面的运算，都是通过函子完成， 即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口(map方法)，各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。</p>
<h3 id="11-maybe函子">11. Maybe函子</h3>
<blockquote>
<p>什么是Maybe函子</p>
</blockquote>
<p>函子接受各种函数，处理容器内部的值。这里有一个问题，容器内部的值可能是一个空值，而外部函数未必有处理空值的机制，如果传入控制，很可能会报错。Maybe函子就是做这种预处理，让不管传入的值是什么都不会报错</p>
<blockquote>
<p>通过例子认识Maybe函子</p>
</blockquote>
<pre><code class="language-js">class Maybe {
    constructor(x) {
        this.__value = x
    }
    map(f) {
        return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value))
    }
    isNothing() {
        return this.__value === null || this.__value === undefined
    }
    static of(x) {
        return new Maybe(x)
    }
}
</code></pre>
<p>上面的例子map方法里多了一层判断，判断如果传进来的值是空的情况下不会去调用传进去的函数，因为空值没有任何的意义。</p>
<h3 id="12-错误处理-和-either">12. 错误处理 和 Either</h3>
<blockquote>
<p>什么是Either</p>
</blockquote>
<p>程序中常用条件运算符<code>if-else</code>, 但是在函数式编程里面，Either函子内部有两个值：<code>left（左值）</code> 和<code>right(右值)</code>。右值是正常情况下使用的值，左值是右值不存在的时候使用的默认值。</p>
<blockquote>
<p>通过例子认识Either</p>
</blockquote>
<pre><code class="language-js">class Either {
    constructor(left, right) {
        this.left = left
        this.right = right
    }
    map(f) {
        return this.right ?
            Either.of(this.left, f(this.right)) : Either.of(f(this.left), this.right)
    }
    static of(left, right) {
        return new Either(left, right)
    }
}
const add = x =&gt; x + 1
Either.of(1, 2).map(add) // Either(1, 3)
Either.of(1, null).map(add) // Either(2, null)
</code></pre>
<p>上面的例子和普通函子不太一样的地方就是传入的值是两个，然后map方法通过判断右值是否存在，如果右值（正常值）存在的情况是作用于右值，不存在则作用域左值。这样就达到了错误处理的功能，在<code>函数式编程</code>是没有<code>try-catch</code>的，Either可以代替<code>try-catch</code>。</p>
<h3 id="13-ap函子">13. AP函子</h3>
<blockquote>
<p>什么是AP函子</p>
</blockquote>
<p>函子里面包含的值是函数</p>
<blockquote>
<p>通过例子认识AP函子</p>
</blockquote>
<pre><code class="language-js">class Ap {
    constructor(x) {
        this.__value = x
    }
    ap(F) {
        return Ap.of(this.__value(F.__value))
    }
    map(f) {
        return Ap.of(f(this.__value))
    }
    static of(x) {
        return new Ap(x)
    }
}

Ap.of(x =&gt; x + 1).ap(Functor.of(2))
</code></pre>
<p>上面的例子里的有个ap函数，它与map方法不同，因为<code>Ap.of(x =&gt; x + 1)</code>里<code>__value</code>是个方法，所以这种函子成为AP函子</p>
<h3 id="14-io">14. IO</h3>
<blockquote>
<p>什么是IO</p>
</blockquote>
<p>在我们真正编程的时候，不可能达到我们的预期，我们一定会有不纯的操作，比如（IO、网络请求、dom操作），我们可以把这些不纯的操作包裹到一个函数内。</p>
<blockquote>
<p>普通的IO函子</p>
</blockquote>
<pre><code class="language-js">class IO {
    constructor(f) {
        this.__value = f
    }
    // 与其他函子的不同之处就是map方法
    map(f) {
        return IO.of(compose(f, this.__value)) // compose方法在前面的时候实现过
    }
    static of(f) {
        return new IO(f)
    }
}
</code></pre>
<h3 id="15-monad">15. Monad</h3>
<blockquote>
<p>什么是Monad</p>
</blockquote>
<ol>
<li>Maybe、Either、IO这三个强大的Functor在链式调用、惰性求值、错误捕获、输入输出都发挥着巨大的作用。但是在我们开发的时候仍然有问题：1. 处理不了嵌套的Functor 2. 处理不了一个由非纯函数或者异步的操作序列。Monad可以解决这两个问题</li>
<li>Monad是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个操作。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</li>
<li>Promise就是一种Monad。</li>
<li>Monad可以避开地狱嵌套，可以轻松地进行深度嵌套的函数式编程。</li>
</ol>
<blockquote>
<p>Monad的作用</p>
</blockquote>
<p>Monad函子总是返回一个单层的函子，它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了嵌套函子，他会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。</p>
<p>flagMap方法接受一个f，里面会实行josin方法，为了保证这个方法总是返回一个单层的函子，这就意味着嵌套的函子会被扁平。</p>
<blockquote>
<p>通过例子认识Monad函子</p>
</blockquote>
<pre><code class="language-js">class Monad {
    constructor(x) {
        this.__value = x
    }
    map(f) {
        return Monad.of(f(this.__value))
    }
    join() {
        return this.__value
    }
    flatMap(f) {
        return this.map(f).join()
    }
    static of(x) {
        return new Monad(x)
    }
}

</code></pre>
<p>Monad函子比普通的函子多了flatMap和join方法</p>
<blockquote>
<p>Monad与IO实现文件操作</p>
</blockquote>
<pre><code class="language-js">const fs = require(&quot;fs&quot;)
const _ = require(&quot;lodash&quot;) // 第三方方法库

class Functor {
  constructor(x) {
    this.__value = x
  }
  map(f) {
    return Functor.of(f(this.__value))
  }
  of(x) {
    return new Functor(x)
  }
}

class Monad extends Functor {
  join() {
    return this.__value
  }
  flatMap(f) {
    return this.map(f).join()
  }
}

class IO extends Monad {
  static of(__value) {
    return new IO(__value)
  }
  map(f) {
    // this.__value === print和读文件方法的组合后的方法
    // _.flowRight是lodash实现compose方法 flowRight代表的是方法从右向左执行
    return IO.of(_.flowRight(f, this.__value))
  }

  // 继承过来的方法 运行的时候请把下面两个方法注释 为了好理解才把它复制过来
  join() {
    // print和读文件方法的组合后的方法
    return this.__value
  }
  flatMap(f) {
    // this.map(f) === IO(print和读文件方法的组合后的方法)
    // this.map(f).join() === print和读文件方法的组合后的方法
    return this.map(f).join()
  }
}

const print = (x) =&gt; IO.of(() =&gt; {
    return x
})
const readFile = (filePath) =&gt; IO.of(() =&gt; fs.readFileSync(filePath, &quot;utf8&quot;))
const result = readFile(&quot;目标文件&quot;) // IO(() =&gt; fs.readFileSync(filePath, &quot;uft-8&quot;))
  .flatMap(print) // 组合后的方法

result().__value() // 这个__value是() =&gt; console.log(x)

// 如果想要链式调用 可以使用下面的方法
const result = readFile(&quot;目标文件&quot;) // IO(() =&gt; fs.readFileSync(filePath, &quot;uft-8&quot;))
  .flatMap(print)() // 返回IO函子
  .flatMap(print)()
</code></pre>
<p>上面这段代码的执行流程已经在代码中详细注释，请慢慢领悟下其中的奥秘。</p>
<p>最后，函数式编程的内容不仅只有这些，本文只列举常见和实用的东西。</p>
]]></content>
    </entry>
</feed>