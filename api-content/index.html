{"posts":[{"title":"JavaScript-面试题（一）","content":"常见面试题 1. 请写出如下代码输出值。（考察作用域） console.log(a); console.log(typeof fn(a)); var flag = true; if (!flag) { var a = 1; } if (flag) { function fn(a) { fn = a; console.log(&quot;fn1&quot;); } } else { function fn(a) { fn = a; console.log(&quot;fn2&quot;); } } 答案是：undefined、报错（fn is not a function） 第一个答案相对简单点，因为var a = 1这里变量提升所以输出的时候a=undefined。 第二个输出答对的人相对较少，因为认为方法也会提升，方法是会提升，但是需要注意方法是放在哪个地方。在块级作用域的地方声明函数，等于var fn = function() {}, 那么var fn会被提升，fn被提升后是undefined，并非是function，所以第二个是输出fn is not a function。在严格模式下，如果在if-else下声明方法是会报错的。 拓展题： function fn1() { // fn2 = undefined // fn3 = undefined if (false) { function fn2() { console.log(&quot;fn2: false&quot;) } } else { var fn3 = function fn2() { fn2 = 3 } } console.log(typeof fn2) fn3() console.log(typeof fn2) } fn1() 这里会输出两个undefined，在上面我们已经提到了在块级作用域声明函数，等于var fn = funciton() {}，然后进入if判断，fn3 = function fn2() {...}，然后第一个输出undefined没有任何的问题，然后执行fn3， fn3方法里面fn2 = 3，但是非常可惜这个赋值并没有生效，因为fn2是函数名，在内部是不能被覆盖的，所以外边的fn2依然是undefined。 2. 请写出如下代码输出值。（考察this指向） function fn() { console.log(this.length); } var obj = { length: 5, method: function() { &quot;use strict&quot;; fn(); arguments[0]() } } const result = obj.method.bind(null); result(fn, 1); 答案是：0、2 先不看上面代码是如何执行的，首先bind可以修改函数内部的this指向，但是当bind第一个参数传的是null的时候，这种绑定方式叫做软绑，意思就是说绑了更没绑都一样，方法内部的this还是不变。第二个就是&quot;use strict&quot;严格模式，严格模式的特点就是在这个区域内this = null（使用bind，apply，call传入的第一个参数不为null除外），所以obj.method方法内部的this = null。 然后我们在看这道题，执行fn()，因为没有人去调用它，所以默认是全局调用，那方法里面的this就指向window，window.length等于页面iframe的数量，所以输出0。然后就是arguments[0]()，arguments[0]是参数穿进去的fn，然后因为这个方法是arguments调用的，所以这个函数的this就是arguments，所以第二个输出2。 拓展题： function test(p1, p2, p3) { console.log(this.length); console.log(this.callee.length); // 这里callee是fn } function fn(p) { arguments[0](10, 20, 30, 40, 50); } fn(test, 10, 20, 30); 答案是：4、1 看代码之前，有几个东西需要知道的是，fn.length === 形参个数， window.length === 页面iframe的个数。 那么这道题就非常的简单了，因为test方法的this是指向了arguments， 所以arguments.length = 4，输出的是4，第二个是fn.length，等于形参个数1。 3. 变量会被GC回收吗?（考察垃圾回收机制） function test() { var a = 10; return function() { eval(&quot;&quot;); } } test()(); 答案是：不会 一般情况下，返回的方法里面如果没有用到的参数会被立即回收，里面用到的参数会被保留在这个方法的执行期上下文（lexical envirmoent）。 特殊的三种情况： 下面的这些情况都会将执行期的上下文全部保留，即使没有使用过的依然会被保留。 eval：因为系统并没有对eval里面执行的代码进行判断处理。解决办法就是eval修改成window.eval with：因为系统并不知道with传入的对象是否包含对应的字段。所以with方法尽量不要用。 Function：Function的使用方法有两种，参数是非字符串的时候，会立即执行参数里面的东西，里面的变量是当前执行的执行期上下文，如果是字符串，返回的是一个方法，调用的时候里面的变量是全局的，系统并没有对这个进行优化，系统也不知道用没有用到上一层定义的变量，所以将执行期的上下文全部保留。 function test() { const a = 100 return function() { new Function(console.log(a)) // 100 new Function(&quot;console.log(a)&quot;)() // 报错 a is not defined } } test()() try-catch: 欺骗了执行期上下文，延长了作用域链条。 4. 请写出如下代码输出值。（考察原型与原型链） Object.prototype.a = 'a'; Function.prototype.a = 'a1'; function Person() {}; var person = new Person(); console.log('person.a: ' + person.a); console.log(person.__proto__.__proto__.constructor.constructor.constructor); 答案是：person.a：a，function Function() {} 在看这道题之前需要知道的知识点： 只有构造函数才有prototype。 构造函数和实例都有__proto__。 构造函数是没有constructor的，只有构造函数的原型才有constructor。 构造函数都是由Function构造出来的。 接下来解释这道题的答案（边看讲解边看配图）： 第一个：person是Person的实例，那访问person.a因为person并没有a属性，所以上person.__proto__找a，person.__proto__= Person.prototype， 但是Person.prototype也没有a属性，那么就上Person.prototype.__proto__找a，Person.prototype.__proto__ = Object.prototype，所以第一个输出的是a。 第二个： person.__proto__ = Person.prototype person.__proto__.__proto__ = Person.prototype.__proto__ = Object.prototype person.__proto__.__proto__.constructor = Object.prototype.constructor = function Object() {} person.__proto__.__proto__.constructor.constructor = function Object() {}.constructor = function Object() {}.__proto__.constructor = Function.prototype.constructor = function Function() {} person.__proto__.__proto__.constructor.constructor = function Function() {}.constructor = function Function() {}.__proto__.constructor = Function.prototype.constructor = function Function() {} 所以答案是function Function() {} 未完待续。。。 ","link":"https://github.com/zhourengui/zhourengui.github.io/mian-shi-ti/"},{"title":"QA测试","content":"前言： 在开发的过程中，除了代码本身，测试也是重要的一环。测试可以验证代码的正确性，保证项目的稳定性，在项目上线的时候保证不出差错。在开发项目的时候会使用console.log进行测试，这种做法效率不能得到保证，也不能做到自动化测试的优势。测试可以保证重构，由于产品迭代速度很快，迭代后必然存在代码重构的过程，如果有大量的测试用例，就可以大胆的进行重构。 本文将介绍单元测试（Unit Test）、端到端测试（E2E Test）、UI测试、服务端测试（Server Test），例子相对简单，如果想要深入学习可以到对应的官网查看文档，本文也会将对应的官网地址附上。 一. 环境搭建 本篇文章是在node.js环境下进行测试，如果不懂node.js的知识也无关紧要，只需要安装node.js的环境即可。 Mac下nodejs环境安装 第一步打开Mac终端，输入brew --version，如果输出类似Homebrew 2.2.16版本文本的话，请继续往下看，否则点击https://brew.sh/index_zh-cn安装Homebrew 第二步在终端输入brew install node， 等待安装完后，在终端输入node --version出现v12.18.3这样的版本文本的话，说明已经安装成功。 Window下nodejs环境安装 请前往https://nodejs.org/en/下载nodejs安装包，建议下载LTS， 目前最新稳定版本是v12.18.x, 等待安装完后，在终端输入node --version出现v12.18.3这样的版本文本的话，说明已经安装成功。 二. 单元测试（Unit Test） 什么是单元测试 通俗的讲就是对你在应用中写的方法或者是类中的某个方法添加测试用例，保证传入的任何值和预期得到的结果一致。 单元测试实践 第一步：需要创建一个空的文件夹，然后在这个文件夹的根目录下运行npm init -y。 执行npm init -y的可能会时候出现，说明文件夹的名称不符合要求。可以通过修改文件的名称或者执行npm init初始化项目。 第二步：这个案例中使用的断言库jasmine, 测试环境karma, 无头浏览器PhantomJS，测试报表karma-coverage。 在项目的根目录下执行，npm install karma karma-jasmine jasmine-core karma-phantomjs-launcher karma-coverage --save-dev 第三步：在项目根目录下创建karma.conf.js文件，这个文件的作用就是当我们在执行测试的时候，程序会默认的根据这个配置执行。 需要更详细的配置请上http://karma-runner.github.io/5.0/config/configuration-file.html module.exports = function (config) { config.set({ // 基础路径，用在files，exclude属性上 basePath: &quot;&quot;, // 使用的断言库 frameworks: [&quot;jasmine&quot;], // 载入浏览器的文件 files: [&quot;./tests/unit/*.js&quot;], // 排除文件列表 // exclude: [&quot;node_modules&quot;], // 预处理 // 可用的预处理: https://npmjs.org/browse/keyword/karma-preprocessor preprocessors: { &quot;./tests/unit/**/*.js&quot;: [&quot;coverage&quot;], }, // 使用测试结果报告者 // 可能的值: &quot;dots&quot;, &quot;progress&quot; // 可用的报告者：https://npmjs.org/browse/keyword/karma-reporter reporters: [&quot;progress&quot;, &quot;coverage&quot;], // 服务端口号 port: 9876, // 启用或禁用输出报告或者日志中的颜色 colors: true, // 日志等级 // 可能的值: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG logLevel: config.LOG_INFO, // 启用或禁用自动检测文件变化进行测试 autoWatch: false, // 测试启动的浏览器 browsers: [&quot;PhantomJS&quot;], // 无头浏览器需要改为true singleRun: true, // 并发级别（启动的浏览器数） concurrency: Infinity, // coverage报表设置 // https://www.npmjs.com/package/karma-coverage coverageReporter: { type: &quot;html&quot;, dir: &quot;./docs/coverage/&quot;, }, }) } 第四步：在项目创建需要的测试文件，单元测试的文件放到了根目录下的tests文件下的unit文件 ├── 根目录 ├── docs ├── package-lock.json ├── package.json ├── tests │ └── unit │ ├── index.js │ └── index.spec.js └── yarn.lock 在index.js文件中写入需要测试的方法： function add(x) { if (x === 3) { return 4 } return Number(x) + 1 } 在index.spec.js中编写测试用例： describe(&quot;测试工具函数的add方法&quot;, function() { it(&quot;参数为数字的时候&quot;, function () { expect(add(1)).toBe(2) }) it(&quot;参数为字符串的时候&quot;, function () { expect(add(&quot;1&quot;)).toBe(2) }) }) 第五步：测试写的方法是否有问题，并且测试的覆盖率是否达到100% 在package.json文件的scripts节点添加&quot;test:unit&quot;: &quot;karma start&quot; { &quot;name&quot;: &quot;unit-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;test:unit&quot;: &quot;karma start&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;jasmine-core&quot;: &quot;^3.6.0&quot;, &quot;karma&quot;: &quot;^5.2.0&quot;, &quot;karma-jasmine&quot;: &quot;^4.0.1&quot;, &quot;karma-phantomjs-launcher&quot;: &quot;^1.0.4&quot; } } 然后在根目录下执行npm run test:unit。 说明测试通过。如果有红色的报错信息，说明你的测试预期的结果不一致。 第六步：虽然测试通过了，但是有个问题是，在add方法中有个if没有测试到。我们不可能通过肉眼去查看我们有哪个部分没有测到，所以需要从测试报表中查看。 在我们执行了第五步后文件目录如下： ├── 根目录 ├── docs │ └── coverage │ └── PhantomJS\\ 2.1.1\\ (Mac\\ OS\\ 0.0.0) │ ├── base.css │ ├── block-navigation.js │ ├── favicon.png │ ├── index.html │ ├── index.js.html │ ├── index.spec.js.html │ ├── prettify.css │ ├── prettify.js │ ├── sort-arrow-sprite.png │ └── sorter.js ├── karma.conf.js ├── package-lock.json ├── package.json ├── tests │ └── unit │ ├── index.js │ └── index.spec.js └── yarn.lock 我们打开docs/coverage/PhantomJS\\ 2.1.1\\ (Mac\\ OS\\ 0.0.0)/index.html文件，然后就可以在网页上查看测试的覆盖率如下： 我们可以看到index.js文件的覆盖率达到了66.6%，然后点击网页的index.js进去，网页会告诉我们哪个位置没有测试到： 第七步：根据没有测试到的位置添加测试用例，这里就不再演示。 案例源码：https://github.com/zhourengui/blog-example/tree/master/QA测试/单元测试（Unit Test） jasmine官方文档https://jasmine.github.io/api/edge/global 三.端到端测试（E2E Test） 什么是端到端测试 一般公司测试页面都是人工去点击页面上的东西，如果点不出bug就说明没有问题，这种做法相对于做自动化测试来说减少了编写代码的时间，但是并不能达到测试的最终目的，所以为了上线后项目的稳定性，我们不得不去做这种端到端的自动化测试。 端到端测试实践 第一步：请参照单元测试（Unit Test）第一步。 第二步：打开终端，路径切换到创建的文件根目录下，执行npm install selenium-webdriver。 第三步：下载对应的无头浏览器脚本。（这里以Chrome为例）。 Chrome下载地址：http://chromedriver.storage.googleapis.com/index.html?path=85.0.4183.87/ 其他浏览器可查看：https://www.npmjs.com/package/selenium-webdriver找到对应的浏览器。 下载完后有一个脚本文件，将脚本文件放到我们项目的根目录下。 第四步：在项目创建需要的测试文件，端到端测试的文件放到了根目录下的tests文件下的e2e文件 ├── 根目录 ├── README.md ├── chromedriver ├── docs ├── package.json ├── tests │ └── e2e │ ├── browser.js │ ├── toast.js │ └── wait.js ├── yarn-error.log └── yarn.lock 第五步：添加测试命令 修改package.json文件的scripts节点 { &quot;name&quot;: &quot;e2e-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;e2e:browser&quot;: &quot;node ./tests/e2e/browser.js&quot;, &quot;e2e:wait&quot;: &quot;node ./tests/e2e/wait.js&quot;, &quot;e2e:toast&quot;: &quot;node ./tests/e2e/toast.js&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;selenium-webdriver&quot;: &quot;^4.0.0-alpha.7&quot; } } 第五步：编写测试脚本 &lt;!-- 这段代码是下面测试脚本使用iframe的例子 --&gt; &lt;div id=&quot;modal&quot;&gt; &lt;iframe id=&quot;buttonframe&quot; name=&quot;myframe&quot; src=&quot;https://seleniumhq.github.io&quot;&gt; &lt;button&gt;Click here&lt;/button&gt; &lt;/iframe&gt; &lt;/div&gt; // browser.js 这个文件里面的方法都是对浏览器的操作 const { Builder, By } = require(&quot;selenium-webdriver&quot;) const fs = require(&quot;fs&quot;) ;(async () =&gt; { let driver = await new Builder().forBrowser(&quot;chrome&quot;).build() // 打开无头浏览器 try { // 浏览器导航 await driver.get(&quot;https://www.baidu.com&quot;) // 跳转到目标地址 const currentUrl = await driver.getCurrentUrl() // 获取当前url地址 // currentUrl = https://www.baidu.com await driver.navigate().back() // 浏览器的后退按钮 await driver.navigate().forward() // 浏览器的前进按钮 await driver.navigate().refresh() // 浏览器刷新 const pageTitle = await driver.getTitle() // 获取页面标题 // pageTitle = 百度一下，你就知道 const windowHandle = await driver.getWindowHandle() // 每个window窗口都有一个唯一标识 这个方法是获取页面标识 // widnowHandle = CDwindow-7EF1E8C65D989D8EB7DE9190B4B8A7E1 await driver.switchTo().newWindow(&quot;tab&quot;) // 创建新标签 await driver.switchTo().newWindow(&quot;window&quot;) // 创建新的window窗口 // await driver.close() // 关闭窗口 await driver.switchTo().window(windowHandle) // 切换窗口 // Iframe操作 因为这部分是模拟的 如果不注释会报错 可以根据实际情况修改 // 进入Iframe内部 下面的方法选其一 // 方法一 使用标签获取 // const iframe = driver.findElement(By.css(&quot;#modal &gt; iframe&quot;)) // await driver.switchTo().frame(iframe) // await driver.findElement(By.css(&quot;button&quot;)).click() // // 方法二 使用name或者id 推荐使用这个 // await driver.switchTo().frame(&quot;buttonframe&quot;) // await driver.switchTo().frame(&quot;myframe&quot;) // await driver.findElement(By.css(&quot;button&quot;)).click() // // 方法三 // await driver.switchTo().frame(1) // await driver.switchTo().defaultContent() // 退出iframe // window管理 const { width, height, x, y } = await driver.manage().window().getRect() // 获取窗口的宽高 位置 // width=1200 height=927 x=22 y=45 await driver .manage() .window() .setRect({ width: 1024, height: 768, x: 100, y: 100 }) // 设定窗口大小和位置 await driver.manage().window().maximize() // 窗口最大化 await driver.manage().window().minimize() // 窗口最小化 await driver.manage().window().fullscreen() // 全屏窗口 const screenEncodeString = driver.takeScreenshot() // 截屏 // await fs.writeFileSync(&quot;./image.png&quot;, screenEncodeString, &quot;base64&quot;) 可以将截到的数据写入一个文件中 await driver.get(&quot;https://www.baidu.com&quot;) const ele = await driver.findElement(By.id(&quot;lg&quot;)) // 获取元素 const eleEncodedString = await ele.takeScreenshot(true) // 截取获取到的元素 await fs.writeFileSync(&quot;./image.png&quot;, eleEncodedString, &quot;base64&quot;) // 写入文件 // await driver.wait(() =&gt; {}, 3000) // 这个是让程序等待3秒 因为没有这个整个过程太快了所以可以打开这个注释。 } finally { await driver.quit() // 退出浏览器 } })() 到这里就可以测试上面编写的浏览器的脚本，在项目根目录执行npm run e2e:browser // await.js 是对等待方法的讲解 const { Builder, until, By } = require(&quot;selenium-webdriver&quot;) const assert = require(&quot;assert&quot;) // 这个文件是等待的方法 // Selenium客户可以使用命令式，程序性语言进行显式等待。 // 它们允许您的代码暂停程序执行或冻结线程，直到传递给它的条件解决为止。 // 以一定的频率调用该条件，直到等待超时超时为止。这意味着只要条件返回虚假值，它将一直尝试并等待。 ;(async () =&gt; { let driver = await new Builder().forBrowser(&quot;chrome&quot;).build() // 打开无头浏览器 try { await driver.get(&quot;https://www.baidu.com&quot;) // 因为等待将不会吞没找不到元素时引发的此类元素错误，所以条件将重试直到找到元素。然后它将使用返回值WebElement，并将其传递回我们的脚本。 // 如果条件失败，例如从未达到该条件的真实返回值，则等待将抛出/引发一个错误/异常，称为超时错误。 let ele = await driver.wait(until.elementLocated(By.css(&quot;p&quot;)), 10000) let foo = await ele.getText() assert(foo == &quot;Hello from JavaScript&quot;) } finally { await driver.quit() // 退出浏览器 } })() 到这里就可以测试上面编写的等待方法的脚本，在项目根目录执行npm run e2e:wait // toast.js 这个文件里面的东西是如何模拟浏览器弹窗 点击确认按钮 点击关闭按钮 提示信息等 const { Builder, until, By } = require(&quot;selenium-webdriver&quot;) // 这个文件里面的东西是如何模拟浏览器弹窗 点击确认按钮 点击关闭按钮 提示信息等 ;(async () =&gt; { let driver = await new Builder().forBrowser(&quot;chrome&quot;).build() // 打开无头浏览器 try { await driver.get(&quot;https://www.baidu.com&quot;) // 跳转到目标地址 await driver.findElement(By.className(&quot;qrcode-layer&quot;)).click() // 这个是模拟点击后出现弹窗 // 要想继续走下去必须到弹出的网页的console面板 alert(xxx)不然一直卡在这 await driver.wait(until.alertIsPresent()) // 这个地方会监听网页上是否有弹窗 let alert = await driver.switchTo().alert() let alertText = await alert.getText() await alert.sendKeys(&quot;Selenium&quot;) // 这个东西是用在window.promt 替换占位符文本 想要验证这个必须在网页的控制台输入window.promt() await alert.accept() // 这个是模拟点击确认按钮 await alert.dismiss() // 这个是模拟点击取消按钮 await driver.wait(() =&gt; {}, 10000) } finally { await driver.quit() // 退出浏览器 } })() 到这里就可以测试上面编写的弹窗方法的脚本，在项目根目录执行npm run e2e:toast 案例源码：https://github.com/zhourengui/blog-example/tree/master/QA测试/端到端测试（E2E Test） 这里就举例了常用的例子，如果想要深入的了解其他api可以到selenium官网https://www.selenium.dev/documentation/en/ 四. UI测试（UI Test） 什么是UI测试 UI测试是为了测试前端写的页面是否还原了设计稿，UI测试可以测出1px的像素差，阴影等，再也不用管UI设计师BB（赞美）这里没对齐那里没对齐，这里差了1像素的废话。 UI测试实践 第一步：参考单元测试的第一步。 第二步：全局安装backstopjs, 在终端执行npm install -g backstopjs,这个过程有点久。 第三步：在创建文件的根目录下执行backstop init, 这时候会生成backstop_data和backstop.json两个文件。 第四步：这个UI测试不需要编写测试的脚本，只需要配置和把需要对比的图片放到指定目录，接下来就是配置教程。 // backstop.json 请注意的是 json不允许注释，这里为了讲述必要的字段配置加的注释 { &quot;id&quot;: &quot;Tencent Mobile Map&quot;, &quot;viewports&quot;: [ // 这里是配置需要测试的尺寸 我这里选中iphone6的尺寸 { &quot;label&quot;: &quot;phone6&quot;, &quot;width&quot;: 375, &quot;height&quot;: 667 }, ], &quot;onBeforeScript&quot;: &quot;puppet/onBefore.js&quot;, // 这个脚本会去找 backstop_data/engine_scripts/puppet/onBefore.js &quot;onReadyScript&quot;: &quot;puppet/onReady.js&quot;, // 这个脚本会去找 backstop_data/engine_scripts/puppet/onReady.js &quot;scenarios&quot;: [ // 配置要匹配的页面 { &quot;label&quot;: &quot;BackstopJS Homepage&quot;, &quot;cookiePath&quot;: &quot;backstop_data/engine_scripts/cookies.json&quot;, // 这个会去找 backstop_data/engine_scripts/cookiePath.json 如果网页需要cookie的使用可以通过这个配置 &quot;url&quot;: &quot;https://map.qq.com/m/&quot;, // 这里用的是腾讯地图页面 &quot;referenceUrl&quot;: &quot;&quot;, &quot;readyEvent&quot;: &quot;&quot;, &quot;readySelector&quot;: &quot;&quot;, &quot;delay&quot;: 0, &quot;hideSelectors&quot;: [], &quot;removeSelectors&quot;: [], &quot;hoverSelector&quot;: &quot;&quot;, &quot;clickSelector&quot;: &quot;&quot;, &quot;postInteractionWait&quot;: 0, &quot;selectors&quot;: [], &quot;selectorExpansion&quot;: true, &quot;expect&quot;: 0, &quot;misMatchThreshold&quot; : 0.1, &quot;requireSameDimensions&quot;: true } ], &quot;paths&quot;: { &quot;bitmaps_reference&quot;: &quot;backstop_data/bitmaps_reference&quot;, // 需要对比的图片 这里就是存放ui做的图 &quot;bitmaps_test&quot;: &quot;backstop_data/bitmaps_test&quot;, &quot;engine_scripts&quot;: &quot;backstop_data/engine_scripts&quot;, // 引擎脚本路径 不要修改 &quot;html_report&quot;: &quot;./docs/backstop_data/html_report&quot;, // 报表存放路径 &quot;ci_report&quot;: &quot;backstop_data/ci_report&quot; // ci报表存放路径 }, &quot;report&quot;: [&quot;browser&quot;], &quot;engine&quot;: &quot;puppeteer&quot;, &quot;engineOptions&quot;: { &quot;args&quot;: [&quot;--no-sandbox&quot;] }, &quot;asyncCaptureLimit&quot;: 5, &quot;asyncCompareLimit&quot;: 50, &quot;debug&quot;: false, &quot;debugWindow&quot;: false } 到这里就可以在项目根目录执行backstop test,这时候会弹出个窗口，如果没有弹出可以点开docs/backstop_data/html_report/index.html。 如图： 可以有红色的报错，这个报错是因为我们还没有把对比的图放到指定的位置上, /backstop_data/bitmaps_reference/TencentMobileMap_BackstopJS_Homepage_0_document_0_phone6.png文件路径一定要跟网页上的一致，包括图片的文件名。 添加后，重新在根目录执行backstop test 如图： 图中可以看到，设计稿和网页上的diff，如果有问题找到相应的位置修改。 案例源码：https://github.com/zhourengui/blog-example/tree/master/QA测试/UI测试（UI Test） 实际项目中肯定会比这复杂得多，更多配置请到backstopjs官网查看https://github.com/garris/BackstopJS 服务端测试（Server Test） 什么是服务端测试 测试接口返回的数据是否跟预期的一致。这里使用到mocha断言库，报表使用mochawesome。 服务端测试实践 第一步：参照单元测试的第一步。 第二步：编写一个简单的接口, 在根目录下创建server.js, 并在根目录下执行npm install express const express = require(&quot;express&quot;) const app = express() app.get(&quot;/test&quot;, (req, res) =&gt; res.json({ code: 0, payload: null, message: null }) ) app.listen(3000, () =&gt; { console.log(&quot;server starting 3000&quot;) }) module.exports = app 然后在项目根目录下执行node server.js 第三步：在项目根目录下创建tests/index.spec.js文件，然后编写测试用例。并在项目根目录下执行npm install supertest mobcha mochawesome, supertest这个插件是做代理的。mobcha是用来断言的。mochawesome测试后的报表。 // index.spec.js const superagent = require(&quot;supertest&quot;) const app = require(&quot;../server&quot;) describe(&quot;接口测试&quot;, function () { it(&quot;test接口测试&quot;, function (done) { superagent(app.listen()) .get(&quot;/test&quot;) .expect(200) .expect(&quot;Content-Type&quot;, /json/) .end(function (err, res) { err &amp;&amp; done(err) let flag = false const dataKey = Object.keys(res.data) flag = !(dataKey.includes(&quot;payload&quot;) &amp;&amp; dataKey.includes(&quot;code&quot;)) flag ? new Error(&quot;数据接口字段返回不准确&quot;) : done() }) }) }) 第四步：编写tests/index.js启动脚本 // /tests/index.js const Mocha = require(&quot;mocha&quot;) var mocha = new Mocha({ reporter: &quot;mochawesome&quot;, reporterOptions: { reportDir: &quot;./docs/mochawesome-report&quot;, // quiet: true }, }) mocha.addFile(&quot;./tests/index.spec.js&quot;) mocha.run(function () { process.exit() }) 然后执行node ./tests.index.js，然后会在根目录下生成./docs/mochawesome-report报表，点击html文件就可以查看报表了。 如图： 案例源码https://github.com/zhourengui/blog-example/tree/master/QA测试/服务端测试（Server Test） 实例的开发中肯定是比这个复杂得多，如果有其他的需求，请前往mochahttps://mochajs.org/查看api。 最后，希望这篇文章对您有帮助。 ","link":"https://github.com/zhourengui/zhourengui.github.io/qa-test/"},{"title":"函数式编程","content":"前言： 函数式编程是编程范式中的一种，是一种典型的编程思想和方法。其他的编程范式还包括面向对象编程、逻辑编程等。 函数式编程不是用函数来编程， 也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数。运算过程尽量写成一系列嵌套的函数调用。 函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、 行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。为什么函数式编程要求函数必须是纯的，不能有副作用?因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。 为什么要学习函数式编程 ? 函数式编程的最大的特点就是纯， 没有任何的副作用，没有任何的依赖，对于代码的review，重构起着重大的作用。（当看过一个耦合度非常高的项目的时候，你会发现函数式编程之美） 一. 函数式编程的特点 函数与其他数据类型一样， 可以赋值给其他变量，也可以是参数，传入另一个函数，或者是别的函数的返回值。 只用表达式，不用语句 没有副作用 不修改状态 函数运行只靠参数 二. 深入学习函数式编程 1. 纯函数 纯函数的特点 相同的输入，会得到相同的输出 没有任何的副作用 不依赖外部环境的状态 通过例子认识纯函数 // 举一个是纯函数的例子： const arr = [1, 2, 3, 4, 5] arr.slice(0, 3) // [1, 2, 3] arr.slice(0, 3) // [1, 2, 3] arr.slice(0, 3) // [1, 2, 3] arr.slice(0, 3) // [1, 2, 3] slice传入的相同的参数，输出都是相同的，没有任何的依赖，没有任何的副作用（arr数组没有变化），说明Array.ptototype.slice是个纯函数 // 举一个不是纯函数的例子： const minAge = 20 const checkAge = age =&gt; age &gt; minAge 由于checkAge方法依赖了minAge这个变量，所以checkAge不是纯函数，可以将checkAge修改成const checkage = age =&gt; age &gt; 20。 问题思考？ 假如需要另一个函数判断传入的年龄是否是大于21，大于22。。。 那不得不重写一个方法，这样一个最大的问题就是拓展性不好。下一节的柯里化函数可以得到答案。 2. 柯里化函数 ☝️上一节的答案 // 使用柯里化解决上一节的问题 const checkAge = min =&gt; (age =&gt; age &gt; min) const checkAge21 = checkAge(21) checkAge21(22) checkAge21(23) checkAge21(25) const checkAge22 = checkAge(22) checkAge21(22) checkAge方法与上一节的实现多了一层function, 从举的例子也不难看出，这样的定义非常的灵活，拓展性也非常好。 柯里化函数的特点 传递给函数一部分参数，返回另一个函数去处理剩下的参数 什么是柯里化 柯里化函数是一种“预加载”函数的方法，通过传递较少的参数，返回另一个函数，这个函数通过保留执行期的上下文（闭包）缓存了第一次传入的参数，是一种非常高效的编写函数的方法。 3. 函数组合 什么是函数组合 需要多个函数有顺序的处理得到的结果，把这些函数合并成一个函数就是函数组合。 通过例子认识函数组合 const compose = (...fns) =&gt; (...args) =&gt; { const fnLength = fns.length if (fnLength === 0) return arg =&gt; arg if (fnLength === 1) return fns[0](...args) return fns.reduce((pre, current = arg =&gt; arg) =&gt; (pre(current(...args)))) } function fn1(arr) { console.log(arr) } function fn2(arr) { return arr.splice(3) } compose(fn1)([1, 2, 3, 4]) 上面定义了一个compose方法，这个方法把传入的所有方法组合起来，方法调用顺序从右向左。 4. Point Free 什么是Point Free 对象自带的防范转化成纯函数，不要命名转瞬即逝的中间变量，这样说可能有点抽象，下面的例子说明的更清楚。 通过例子认识Point Free const f = str =&gt; str.toUpperCase().split(' ')这段代码使用了str作为中间变量，这个中间变量除了让代码变得长一点以外毫无意义。 我们可以使用函数组合进行修改 const toUpperCase = str =&gt; str.toUpperCase() const split = x =&gt; (str =&gt; str.split(x)) const f = compose(split(' '), toUpperCase) f(&quot;test string&quot;) 这样的编程可以减少不必要的命名，让代码保存简洁和通用。 5. 声明式与命令式代码 什么是声明式 通过编写一条有一条指令去让计算机执行一些操作 什么是命令式 通过写表达式的方式来声明要做声明 不是通过一步一步指示 通过例子认识声明式与命令式代码 // 命令式 const persons = [] for (let i = 0; i &lt; arr.length; i ++) { persons.push(arr[i]) } // 声明式 const persons = arr.map(p =&gt; p) 6. 惰性求值 什么是惰性求值 一种将对函数或请求处理延迟到真正需要结果时进行的通用概念。有很多应用程序都采用了这种概念，有的非常明显，有些则不太明显。从惰性编程的角度来思考问题，可以帮您消除代码中不必要的计算。 通过例子认识惰性求值 // 原生js封装ajax function ajax() { //1.创建xhr对象 //创建xhr对象 - 非IE6 if (window.XMLHttpRequest) { var xhr = new XMLHttpRequest(); } else { //IE6及其以下版本浏览器 var xhr = new ActiveXObject('Microsoft.XMLHTTP'); } ... } 上面通过原生js封装ajax理解惰性求值，如果我们上面不做任何的处理我们每次调用ajax这个方法的时候，方法内部都会做一次兼容处理，但是呢当第一次调用后，我们就知道了用户的浏览器是否支持ie，所以可以修改如下 // 原生js封装ajax function ajax() { //1.创建xhr对象 //创建xhr对象 - 非IE6 if (window.XMLHttpRequest) { var xhr = new XMLHttpRequest(); } else { //IE6及其以下版本浏览器 var xhr = new ActiveXObject('Microsoft.XMLHTTP'); } ajax = xhr } 通过这样修改后，当调用一次后ajax=xhr，当第二次调用的时候，就不用去重新判断兼容处理，这样可以提升性能。 7. 高阶函数 什么是高阶函数 函数当作参数，把传入的函数做一个封装，然后返回这个封装的函数，达到更高成都的抽象。 通过例子认识高阶函数 function add(x, y, fn) { return fn(x) + fn(y) } add(2, 3, (n) =&gt; n * n) 这就是一个简单的高级函数，只要一个函数接收一个函数作为参数， 这种函数就可以称之为高阶函数。 8. 尾递归（尾调用） 什么是尾递归 函数内部的最后一个动作是函数调用。该调用的返回值直接返回给函数。函数调用自身成为递归。如果尾调用自身，就成为尾递归。递归需要保存大量的调用记录, 很容易发生栈溢出错误，如果使用尾递归优化， 将递归变为循环， 那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。 通过例子认识尾递归（尾调用） // 斐波那契数列 正常递归 function factorial(n) { if (n === 1) return 1 return n * factorial(n - 1) } // 使用尾递归 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } 尾递归的优点 整个调用过程是线性的，调用一次后就会进入下一个栈，相关的数据信息跟随进入， 不保留在栈堆上，有效的防止堆栈溢出 9. 闭包 什么是闭包? 在某个块区域保留了父级以及父级以上的执行期上下文，这就是闭包，由于闭包网上有很多的资料，这里不做太多的赘述。 10. 容器（范畴）与函子（Funcctor） 什么是范畴 范畴就是容器，容器包含两样东西。值和值的变形关系（函数） 值的变形关系（函数）可以用于同一个容器的转换， 也可以用于将一个容器专程另一个容器。 什么是函子 函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。他首先是一种范畴，换句话说，函子也是容器，他也包含了容器的两样东西，只不过他的变形关系可以依次作用于每一个值，将当前的容器变形成另一个容器。 函子是一个对于函数调用的抽象， 赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选中何时何地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等特性。 通过例子认识函子 函子的特点 任何具有map方法的数据结构，都可以当作函子的实现。 函数式编程一般约定，函子（Functor）有一个of方法, 用来生成新 的容器。 函子（Functor）遵守一些特定规则的容器类型。 函子（Functor） 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等特性。 根据上面的特点用代码实现 class Functor { constructor(x) { this.__value = x } // 一般约定，函子的标志就是容器具有map方法。该方法将容器 里面的每一个值，映射到另一个容器。 map(f) { return Functor.of(f(this.__value)) } // 函数式编程一般约定，函子（Functor）有一个of方法 static of(x) { return new Functor(x) } } // 使用如下 Functor.of(2) .map(x =&gt; x + 1) // Functor(3) .map(x =&gt; x * 2) // Functor(6) 上面代码中，Functor是一个函子，它的map方法接受函数f作为 参数，然后返回一个新的函子，里面包含的值是被f处理过的 (f(this.val))。 函数式编程里面的运算，都是通过函子完成， 即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口(map方法)，各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。 11. Maybe函子 什么是Maybe函子 函子接受各种函数，处理容器内部的值。这里有一个问题，容器内部的值可能是一个空值，而外部函数未必有处理空值的机制，如果传入控制，很可能会报错。Maybe函子就是做这种预处理，让不管传入的值是什么都不会报错 通过例子认识Maybe函子 class Maybe { constructor(x) { this.__value = x } map(f) { return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value)) } isNothing() { return this.__value === null || this.__value === undefined } static of(x) { return new Maybe(x) } } 上面的例子map方法里多了一层判断，判断如果传进来的值是空的情况下不会去调用传进去的函数，因为空值没有任何的意义。 12. 错误处理 和 Either 什么是Either 程序中常用条件运算符if-else, 但是在函数式编程里面，Either函子内部有两个值：left（左值） 和right(右值)。右值是正常情况下使用的值，左值是右值不存在的时候使用的默认值。 通过例子认识Either class Either { constructor(left, right) { this.left = left this.right = right } map(f) { return this.right ? Either.of(this.left, f(this.right)) : Either.of(f(this.left), this.right) } static of(left, right) { return new Either(left, right) } } const add = x =&gt; x + 1 Either.of(1, 2).map(add) // Either(1, 3) Either.of(1, null).map(add) // Either(2, null) 上面的例子和普通函子不太一样的地方就是传入的值是两个，然后map方法通过判断右值是否存在，如果右值（正常值）存在的情况是作用于右值，不存在则作用域左值。这样就达到了错误处理的功能，在函数式编程是没有try-catch的，Either可以代替try-catch。 13. AP函子 什么是AP函子 函子里面包含的值是函数 通过例子认识AP函子 class Ap { constructor(x) { this.__value = x } ap(F) { return Ap.of(this.__value(F.__value)) } map(f) { return Ap.of(f(this.__value)) } static of(x) { return new Ap(x) } } Ap.of(x =&gt; x + 1).ap(Functor.of(2)) 上面的例子里的有个ap函数，它与map方法不同，因为Ap.of(x =&gt; x + 1)里__value是个方法，所以这种函子成为AP函子 14. IO 什么是IO 在我们真正编程的时候，不可能达到我们的预期，我们一定会有不纯的操作，比如（IO、网络请求、dom操作），我们可以把这些不纯的操作包裹到一个函数内。 普通的IO函子 class IO { constructor(f) { this.__value = f } // 与其他函子的不同之处就是map方法 map(f) { return IO.of(compose(f, this.__value)) // compose方法在前面的时候实现过 } static of(f) { return new IO(f) } } 15. Monad 什么是Monad Maybe、Either、IO这三个强大的Functor在链式调用、惰性求值、错误捕获、输入输出都发挥着巨大的作用。但是在我们开发的时候仍然有问题：1. 处理不了嵌套的Functor 2. 处理不了一个由非纯函数或者异步的操作序列。Monad可以解决这两个问题 Monad是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个操作。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。 Promise就是一种Monad。 Monad可以避开地狱嵌套，可以轻松地进行深度嵌套的函数式编程。 Monad的作用 Monad函子总是返回一个单层的函子，它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了嵌套函子，他会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。 flagMap方法接受一个f，里面会实行josin方法，为了保证这个方法总是返回一个单层的函子，这就意味着嵌套的函子会被扁平。 通过例子认识Monad函子 class Monad { constructor(x) { this.__value = x } map(f) { return Monad.of(f(this.__value)) } join() { return this.__value } flatMap(f) { return this.map(f).join() } static of(x) { return new Monad(x) } } Monad函子比普通的函子多了flatMap和join方法 Monad与IO实现文件操作 const fs = require(&quot;fs&quot;) const _ = require(&quot;lodash&quot;) // 第三方方法库 class Functor { constructor(x) { this.__value = x } map(f) { return Functor.of(f(this.__value)) } of(x) { return new Functor(x) } } class Monad extends Functor { join() { return this.__value } flatMap(f) { return this.map(f).join() } } class IO extends Monad { static of(__value) { return new IO(__value) } map(f) { // this.__value === print和读文件方法的组合后的方法 // _.flowRight是lodash实现compose方法 flowRight代表的是方法从右向左执行 return IO.of(_.flowRight(f, this.__value)) } // 继承过来的方法 运行的时候请把下面两个方法注释 为了好理解才把它复制过来 join() { // print和读文件方法的组合后的方法 return this.__value } flatMap(f) { // this.map(f) === IO(print和读文件方法的组合后的方法) // this.map(f).join() === print和读文件方法的组合后的方法 return this.map(f).join() } } const print = (x) =&gt; IO.of(() =&gt; { return x }) const readFile = (filePath) =&gt; IO.of(() =&gt; fs.readFileSync(filePath, &quot;utf8&quot;)) const result = readFile(&quot;目标文件&quot;) // IO(() =&gt; fs.readFileSync(filePath, &quot;uft-8&quot;)) .flatMap(print) // 组合后的方法 result().__value() // 这个__value是() =&gt; console.log(x) // 如果想要链式调用 可以使用下面的方法 const result = readFile(&quot;目标文件&quot;) // IO(() =&gt; fs.readFileSync(filePath, &quot;uft-8&quot;)) .flatMap(print)() // 返回IO函子 .flatMap(print)() 上面这段代码的执行流程已经在代码中详细注释，请慢慢领悟下其中的奥秘。 最后，函数式编程的内容不仅只有这些，本文只列举常见和实用的东西。 ","link":"https://github.com/zhourengui/zhourengui.github.io/han-shu-shi-bian-cheng/"}]}