{"posts":[{"title":"常用算法思想","content":"本篇文章可以收获的知识： 什么是分而治之 什么是动态规划 什么是贪心算法 什么是回溯算法 九道LeetCode算法题巩固常用算法思想 如何分析时间复杂度和空间复杂度 分而治之 分而治之是一种算法设计思想，不是数据结构也不是一种算法，它将一个问题分成多个和原问题相似的小问题，再将结构合并以解决原来的问题。 在排序算法中，归并排序和快速排序使用的就是分而治之的思想，归并排序：分：把数组从中间一分为二，解：递归地对两个子数组进行排序，合：合并有序子数组，快速排序：分：选基准，按基准把数组分成两个子数组，解：递归地对两个子数组进行快速排序，合：对两个子数组进行合并。 动态规划 动态规划是一种算法设计思想，不是数据结构也不是一种算法，它将一个问题分解为相互重叠的子问题，通过反复求解子问题，来解决原来的问题。 使用动态规划解决斐波那契数列问题：1、定义子问题：F(n) = F(n - 1) + f(n - 2)，2、反复执行：从2循环到n，执行公示。 动态规划和分而治之的区别：子问题是独立的是分而治之，子问题是重叠的是动态规划。 贪心算法 贪心算法是一种算法设计思想，不是数据结构也不是一种算法，期盼通过每个阶段的局部最优选择，从而达到全局的最优，但是结果并不一定是最优的。 通过一个例子认识贪心算法： // 零钱兑换 const coins = [1, 2, 5] const amount = 11 // 11 = 5 + 5 + 1 // 输出的是3，这个时候的贪心算法满足最优结果 const coins = [1, 3, 4] const amount = 6 // 输出3 // 6 = 4 + 1 + 1 // 这时候贪心算法不是最优解 通过上面的例子，不难知道贪心算法得到的结果并不一定是最优解，但是并不能说贪心算法不能用，在某些场景下是可以使用贪心算法的，后面的算法题中会有贪心算法的解决方案。 回溯算法 回溯算法是一种算法设计思想，不是数据结构也不是一种算法，是一种渐进式寻找并构建问题解决方式的策略，会从一个可能的动作开始解决问题，如果不行，就会回溯并选择另一个动作，直到将问题解决。 什么问题适合用回溯算法：有很多路，这些路里，有死路，也有出路，通常需要递归来模拟所有的路。 通过文字理解算法思想有点难理解，下面通过算法题来深入了解算法思想的使用。 LeetCode算法题：题号100，相同的树 解题思路： 两个树：根结点相同，左子树相同，右子树相同 符合：“分、解、合”特性 考虑使用分而治之 解题步骤： 分：获取两个树的左子树和右子树 解：递归地判断两个树的左子树是否相同，右子树是否相同 合：将上述结果合并，如果根结点也相同，树就相同 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */ var isSameTree = function (p, q) { const isSame = (t1, t2) =&gt; { if (!t1 &amp;&amp; !t2) { return true } if ( t1 &amp;&amp; t2 &amp;&amp; t1.val === t2.val &amp;&amp; isSameTree(t1.left, t2.left) &amp;&amp; isSameTree(t1.right, t2.right) ) { return true } return false } return isSame(p, q) } 代码中使用了递归，递归的次数最大是树的节点树，所以时间复杂度是O(n)，n是树的节点树。 代码中虽然没有定义线性增长的数据结构，但是有递归，递归的堆栈最大是树的高度，树均匀分布的情况下是logn，所以空间复杂度是O(n)或者是O(logn)。 LeetCode算法题：题号101，对称二叉树 解题思路： 转化为：左子树和右子树是否镜像 分解为：左子树的左节点是否和右子树的右节点镜像并且左子树的右节点是否和右子树的左节点镜像 符合分、解、合特性，使用分而治之 解题步骤： 分：获取树的左子树和右子树 解：递归地判断左子树的左节点是否和右子树的右节点镜像并且左子树的右节点是否和右子树的左节点镜像 合：如果上述都成立，且根节点相同，两个树就镜像 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isSymmetric = function (root) { if (!root) { return true } const isMirror = (left, right) =&gt; { if (!left &amp;&amp; !right) { return true } if ( left &amp;&amp; right &amp;&amp; left.val === right.val &amp;&amp; isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left) ) { return true } return false } return isMirror(root.left, root.right) } 代码中使用了递归，递归的最大次数是树的节点树，所以时间复杂度是O(n)，n是树的节点树。 代码中虽然没有使用线性增长的数据结构，但是使用了递归，递归的调用堆栈最大是树的高度，树均匀分布的情况下是logn，所以空间复杂度是O(n)或者O(logn)。 LeetCode算法题：题号226，翻转二叉树 解题思路： 先翻转左右子树，再将子树换个位置 符合“分、解、合”特性 考虑使用分而治之 解题步骤： 分：获取左右子树 解：递归地翻转左右子树 将翻转后的左右子树换个位置放到根结点上 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var invertTree = function (root) { if (!root) return null return { val: root.val, left: invertTree(root.right), right: invertTree(root.left), } } 代码中使用了递归，递归的最大次数是树的节点树，所以时间复杂度是O(n)，n是树的节点树。 代码中虽然没有使用线性增长的数据结构，但是使用了递归，递归的调用堆栈最大是树的高度，树均匀分布的情况下是logn，所以空间复杂度是O(n)或者O(logn)。 LeetCode算法题：题号70， 爬楼梯 解题思路： 第n阶可以在第n - 1阶爬1个台阶，或者在n - 2阶爬2个台阶 F(n) = F(n - 1) + F(n - 2) 使用动态规划 解题步骤： 定义子问题：F(n) = F(n - 1) + F(n - 2) 反复执行：从2循环到n，执行上述公式 代码实现： /** * @param {number} n * @return {number} */ var climbStairs = function (n) { if (n &lt;= 1) { return 1 } let dp0 = 0 let dp1 = 1 for (let i = 1; i &lt;= n; i++) { const tmp = dp0 dp0 = dp1 dp1 = tmp + dp1 } return dp1 } 代码中使用了for循环，循环的次数是n，所以时间复杂度是O(n)。 代码中没有用到线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号198，打家劫舍 实现思路： f(k) = 从前k个房屋中能偷窃到的最大金额 ak = 第k个房屋的金额 f(k) = Math.max(ak + f(k - 2), f(k - 1)) 考虑使用动态规划 解题步骤： 定义子问题：f(k) = Math.max(ak + f(k - 2), f(k - 1)) 反复执行：从数组的第二位循环到n，执行上述公式 代码实现： /** * @param {number[]} nums * @return {number} */ var rob = function (nums) { if (!nums.length) return 0 let dp0 = 0 let dp1 = nums[0] for (let i = 1; i &lt; nums.length; i++) { const dp2 = Math.max(nums[i] + dp0, dp1) dp0 = dp1 dp1 = dp2 } return dp1 } 代码中使用了for循环，循环的次数是数组的长度减2，所以时间复杂度是O(n)。 代码中没有用到线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号455，分发饼干 解题思路： 局部最优：既能满足孩子，还消耗的饼干最少 先将“较小的饼干”分给“胃口最小”的孩子 考虑使用贪心算法 解题步骤： 对饼干数组和胃口数组进行升序 遍历饼干数组，找到能满足胃口最小的孩子的饼干 遍历结束后返回返回结果 代码实现： /** * @param {number[]} g * @param {number[]} s * @return {number} */ var findContentChildren = function (g, s) { const sortFn = (a, b) =&gt; a - b g.sort(sortFn) s.sort(sortFn) let i = 0 s.forEach((n) =&gt; { if (n &gt;= g[i]) { i += 1 } }) return i } 代码中使用了foreach循环，循环的次数是饼干数组的长度，所以时间复杂度是O(n)。 代码中没有用到线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号122，买卖股票的最佳时机 II 解题思路： 前提：上帝视角，找到未来的价格 局部最优：见好就收，见差就不动，不做任何长远的打算 考虑使用贪心算法 解题步骤： 新建一个变量，用来统计总利润 遍历价格数组，如果当前价格比昨天高，就在昨天买，今天卖，否者不交易 遍历结束后返回总利润 代码实现： /** * @param {number[]} prices * @return {number} */ var maxProfit = function (prices) { let profit = 0 for (let i = 1; i &lt; prices.length; i++) { if (prices[i - 1] &lt; prices[i]) { profit += prices[i] - prices[i - 1] } } return profit } 代码中使用了for循环，循环的次数是数组的长度减1，所以时间复杂度是O(n)。 代码中没有用到线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号46，全排列 解题思路： 要求：1、所有排列情况，2、没有重复元素 有出路、有死路 考虑使用回溯算法 解题步骤： 用递归模拟出所有的情况 遇到包含重复元素的情况，就回溯 手机所有到达递归终点的情况，并返回 代码实现： /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { const res = [] const backtrack = (path) =&gt; { if (path.length === nums.length) { res.push(path) return } nums.forEach((c) =&gt; { if (path.includes(c)) { return } backtrack(path.concat(c)) }) } backtrack([]) return res } 代码中有foreach循环并且内嵌递归，正常不做return的情况下，时间复杂度是O(n^2)，但是由于重复元素不进行递归，所以会发现一个规律，每一个满足的元素进行1x2x3x4...n循环，所以时间复杂度是O(n!)。 代码中虽然没有使用线性增长的数据结构，但是使用了递归，递归的最大堆栈是数组的长度，所以空间复杂度是O(n)。 LeetCode算法题：题号78，子集 解题思路： 要求：1、所有子集，2、没有重复元素 有出路、有死路 考虑使用回溯算法 解题步骤： 用递归模拟所有情况 保证后面接的数字都是后面的数字 收集所有到达递归终点的情况，并返回 代码实现： /** * @param {number[]} nums * @return {number[][]} */ var subsets = function (nums) { const res = [] const backtrack = (path, l, s) =&gt; { if (path.length === l) { res.push(path) return } for (let i = s; i &lt; nums.length; i++) { backtrack(path.concat(nums[i]), l, i + 1) } } for (let i = 0; i &lt;= nums.length; i++) { backtrack([], i, 0) } return res } 代码中for循环嵌套递归，递归里面的时间复杂度是2n，因为每个元素只有存在和不存在的可能性，所以时间复杂度是O(n*2n)。 代码中使用到了递归，递归的堆栈大小是数组的大小，所以空间复杂度是O(n)。 最后，希望读者可以通过本篇文章对常用算法思想有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/chang-yong-suan-fa-si-xiang/"},{"title":"排序与搜索","content":"本篇文章可以收获的知识： 排序算法 冒泡排序的实现及分析 选择排序的实现及分析 插入排序的实现及分析 归并排序的实现及分析 快速排序的实现及分析 搜素算法 顺序搜索的实现及分析 二分搜索的实现及分析 两道LeetCode算法题巩固搜索与排序 如何分析时间复杂度和空间复杂度 排序算法 冒泡排序 // 实现思路 // 比较所有相邻，如果第一个比第二个大，则替换位置 // 一轮下来，可以保证最后一个数是最大的 // 执行n - 1轮就可以完成排序 // 时间复杂度是O(n ^ 2) Array.prototype.bubbleSort = function() { for (let i = 0; i &lt; this.length - 1; i++) { for (let j = 0; j &lt; this.length - 1 - i; j++) { if (this[j] &gt; this[j + 1]) { const tmp = currentItem this[j] = this[j + 1] this[j + 1] = tmp } } } } const arr = [5, 4, 3, 2, 1] arr.bubbleSort() 选择排序 // 实现思路 // 找到第一个最小的值，将它保存在第一位 // 找到第二个最小的值，将它保存在第二位 // 以此类推，执行n - 1轮之后，排序完成 // 时间复杂度是O(n ^ 2) Array.prototype.selectionSort = function () { for (let i = 0; i &lt; this.length - 1; i++) { let minIndex = i for (let j = i; j &lt; this.length; j++) { if (this[minIndex] &gt; this[j]) { minIndex = j } } if (i !== minIndex) { let tmp = this[minIndex] this[minIndex] = this[i] this[i] = tmp } } } const arr = [3, 1, 5, 9, 4] arr.selectionSort() 插入排序 // 插入排序相对于选择排序、冒泡排序来说，效率相对较高，但是还是不推荐在实际应用中使用 // 实现思路 // 从第二个往前比 // 前面比后面大的往后排 // 以此类推，执行n - 1轮之后，排序完成 // 时间复杂度是O(n ^ 2) Array.prototype.insertionSort = function () { for (let i = 1; i &lt; this.length; i++) { let tmp = this[i] let j = i while (j &gt; 0) { if (this[j - 1] &gt; tmp) { this[j] = this[j - 1] } else { break } j -= 1 } this[j] = tmp } } const arr = [3, 1, 5, 9, 4] arr.insertionSort() 归并排序 // 归并排序比冒泡排序、选择排序、插入排序的效率都高，而且归并排序是可以应用到实际的项目中的，火狐浏览器的sort算法使用的就是归并排序 // 实现思路 // 分：把数组分成两半，再递归地对子数组进行分操作，直到全部子数组分成一个个单独的数 // 合：把两个数合并为有序的数组，再对有序的数组进行合并，直到全部子数组合并为一个完整的数组 // 新建一个空数组res，用于存放最终排序后的数组 // 比较两个有序数组的头部，较小者出队并推入res中 // 如果两个数组还有值，重复上一步操作 // 分的时间复杂度是O(logn) // 合的时间复杂度是O(n) // 归并排序时间复杂度是O(nlogn) Array.prototype.mergeSort = function () { const rec = (arr) =&gt; { if (arr.length === 1) { return arr } const mid = Math.floor(arr.length / 2) const left = arr.slice(0, mid) const right = arr.slice(mid, arr.length) const orderLeft = rec(left) const orderRight = rec(right) const res = [] while (orderLeft.length || orderRight.length) { if (orderLeft.length &amp;&amp; orderRight.length) { res.push( orderLeft[0] &gt; orderRight[0] ? orderRight.shift() : orderLeft.shift() ) } else if (orderLeft.length) { res.push(orderLeft.shift()) } else if (orderRight.length) { res.push(orderRight.shift()) } } return res } const res = rec(this) res.forEach((v, k) =&gt; (this[k] = v)) } const arr = [3, 1, 5, 9, 4] arr.mergeSort() 快速排序 // 快速排序比冒泡排序、选择排序、插入排序的效率都高，而且快速排序是可以应用到实际的项目中的，曾经的Chrome的sort算法使用的是快速排序 // 实现思路 // 分区：从数组中任意选择一个“基准”，所有比基准小的元素放在基准前面，所有比基准大的元素放在基准后面 // 递归：递归地对基准前后的子数组进行分区 // 递归的时间复杂度：O(logn) // 分区操作的时间复杂度是O(n) // 快速排序的时间复杂度是：O(nlogn) Array.prototype.quickSort = function () { const rec = (arr) =&gt; { if ([0, 1].includes(arr.length)) return arr const left = [] const right = [] const mid = arr[0] for (let i = 1; i &lt; arr.length; i++) { const c = arr[i] c &gt; mid ? right.push(c) : left.push(c) } return [...rec(left), mid, ...rec(right)] } const res = rec(this) res.forEach((v, k) =&gt; (this[k] = v)) } const arr = [5, 3, 6, 2, 8, 0] arr.quickSort() 搜索算法 顺序搜索 // 实现思路 // 遍历数组 // 找到目标值相等的元素，就返回它的下标 // 遍历结束后，如果没有搜索到目标值，就返回-1 // 时间复杂度是O(n) Array.prototype.sequentialSearch = function (target) { for (let i = 0; i &lt; this.length; i++) { if (this[i] === target) { return i } } return -1 } [5, 3, 6, 2, 8, 0].sequentialSearch(3) 二分搜索 // 二分搜索（折半搜索），前提是这个数组是有序的 // 实现思路 // 从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束 // 如果目标值大于或小于中间元素，则在大于或小于中间元素的那一半数组中搜索 // 时间复杂度是O(logn) Array.prototype.binarySearch = function (target) { let low = 0 let high = this.length - 1 while (low &lt;= high) { const mid = Math.floor((low + high) / 2) const c = this[mid] if (c &gt; target) { high = mid - 1 } else if (c &lt; target) { low = mid + 1 } else { return mid } } return -1 } console.error([1, 2, 3, 4, 5].binarySearch(3)) // 2 LeetCode算法题：题号21，合并两个有序链表 解题思路： 与归并排序中合并两个有序数组很相似 将数组替换成链表即可 解题步骤： 新建一个新链表，作为返回结果 用指针遍历两个有序链表，并比较两个链表的当前节点，较小者先接入新链表，并将指针后移一步 遍历结束，返回新链表 代码实现： /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { let res = new ListNode(0) let p = n let p1 = l1 let p2 = l2 while(p1 &amp;&amp; p2) { if (p1.val &gt; p2.val) { p.next = p2 p2 = p2.next } else { p.next = p1 p1 = p1.next } p = p.next } if (p1) { p.next = p1 } if (p2) { p.next = p2 } return res.next }; 由于代码中使用了while循环，循环的最大次数是两个链表的数量之和，所以时间复杂度是O(n)，n是两个链表的数量之和。 由于代码中没有额外的使用线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号374，猜数字大小 解题思路： 这到题明显使用的二分算法解题 调用guess函数，来判断中间元素是否是目标值 解题步骤： 从数组中间元素取值，如果中间元素正好是目标值，则搜索结束 如果目标值大于或者小于中间元素，则在数组大于或小于中间元素的那一半搜索 代码实现： /** * Forward declaration of guess API. * @param {number} num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * var guess = function(num) {} */ /** * @param {number} n * @return {number} */ var guessNumber = function(n) { let low = 0; let high = n; while(low &lt;= high) { const mid = Math.floor((low + high) / 2); const ret = guess(mid) if (ret === -1) { high = mid - 1 } else if (ret === 1) { low = mid + 1 } else if (ret === 0) { return mid } } }; 代码中使用的是二分搜索，所以时间复杂度是O(logn)。 代码中没有使用到线性增长的数据结构，所以空间复杂度是O(1)。 最后，希望读者可以通过本篇文章对排序与搜索有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/pai-xu-yu-sou-suo/"},{"title":"数据结构之堆","content":"本篇文章可以收获的知识： 什么是堆 堆的使用场景 使用JavaScript构建堆 三道LeetCode算法题巩固堆 如何分析时间复杂度和空间复杂度 什么是堆 堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或者小于等于（最小堆）它的子节点，JavaScript通常使用数组表示堆，左侧子节点的位置是2 * index + 1，右侧子节点的位置是2 * index + 2，父节点位置是（index - 1）/ 2。 堆的使用场景 堆能高效、快速地找出最大值和最小值，时间复杂度是O(1)。 找出第K个最大(小)元素思路 构建一个推，并将元素依次插入堆中 当堆的容量超过K，就删除堆顶 插入结束后，堆顶就是第K个最大元素 使用JavaScript构建堆 // 最小堆 // 构建堆的思路 // 在类里声明一个数组，用来装元素 // 主要方法：插入、删除堆顶、获取堆顶、获取堆大小 class MinHead { constructor() { this.heap = [] } /** * 获取左节点索引 * @param {number} index */ getLeftIndex(index) { return index * 2 + 1 } /** * 获取右节点索引 * @param {number} index */ getRightIndex(index) { return index * 2 + 2 } /** * 获取堆顶 */ peek() { return this.heap[0] } /** * 获取堆大小 */ size() { return this.heap.length } /** * 交换元素 * @param {number} i1 * @param {number} i2 */ swap(i1, i2) { const tmp = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = tmp } /** * 获取父节点索引 * @param {number} index */ getParentIndex(index) { return (index - 1) &gt;&gt; 1 } /** * 将元素往上移 * @param {number} index */ shiftUp(index) { // 如果元素已到堆顶退出即可 // 获取父节点与当前节点进行比较，如果父节点大于当前节点，则进行交换，并递归 if (index === 0) return const parentIndex = this.getParentIndex(index) if (this.heap[parentIndex] &gt; this.heap[index]) { this.swap(parentIndex, index) this.shiftUp(parentIndex) } } /** * 插入方法 * @param {number} target */ insert(target) { // 将值插入到堆的底部，即数组的结尾 // 然后上移：将这个值与父节点进行交换，直到父节点小于等于插入的这个值 // 大小为K的堆中插入元素的时间复杂度是O(logK) this.heap.push(target) this.shiftUp(this.heap.length - 1) } /** * 下移元素 * @param {number} index */ shiftDown(index) { const leftIndex = this.getLeftIndex(index) const rightIndex = this.getRightIndex(index) if (this.heap[index] &gt; this.heap[leftIndex]) { this.swap(leftIndex, index) this.shiftDown(leftIndex) } if (this.heap[index] &gt; this.heap[rightIndex]) { this.swap(rightIndex, index) this.shiftDown(rightIndex) } } /** * 删除堆顶 */ pop() { // 使用数组的尾元素替换堆顶（直接删除堆顶会破坏堆的结构） // 然后下移操作：将新堆顶和他的子节点进行交换，直到新堆顶小于等于子节点 // 大小为K的堆下移操作的时间复杂度是O(logK) this.heap[0] = this.heap.pop() this.shiftDown(0) } } LeetCode算法题：题号215，数组中的第K个最大元素 解题思路： 看到第K个最大元素，考虑使用最小堆 解题步骤： 构建一个最小堆，并依次把数组的值插入到堆中 当堆的容量大于K时，就删除堆顶 插入结束后，返回堆顶，堆顶就是第K个最大元素 代码实现： class MinHead { constructor() { this.heap = [] } getLeftIndex(index) { return index * 2 + 1 } getRightIndex(index) { return index * 2 + 2 } peek() { return this.heap[0] } size() { return this.heap.length } swap(i1, i2) { const tmp = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = tmp } getParentIndex(index) { return (index - 1) &gt;&gt; 1 } shiftUp(index) { if (index === 0) return const parentIndex = this.getParentIndex(index) if (this.heap[parentIndex] &gt; this.heap[index]) { this.swap(parentIndex, index) this.shiftUp(parentIndex) } } insert(target) { this.heap.push(target) this.shiftUp(this.heap.length - 1) } shiftDown(index) { const leftIndex = this.getLeftIndex(index) const rightIndex = this.getRightIndex(index) if (this.heap[index] &gt; this.heap[leftIndex]) { this.swap(leftIndex, index) this.shiftDown(leftIndex) } if (this.heap[index] &gt; this.heap[rightIndex]) { this.swap(rightIndex, index) this.shiftDown(rightIndex) } } pop() { this.heap[0] = this.heap.pop() this.shiftDown(0) } } /** * @param {number[]} nums * @param {number} k * @return {number} */ var findKthLargest = function(nums, k) { const heap = new MinHead() for(let i = 0; i &lt; nums.length; i ++) { heap.insert(nums[i]) if (heap.size() === k + 1) { heap.pop() } } return heap.peek() }; 由于代码中使用了循环，并且在堆中插入或者删除堆顶的时候的有个递归，所以时间复杂度时O(n * logK)，n时数组的长度，K是堆的大小。 由于代码中使用了堆，堆的空间复杂度是O(n)，n是堆的大小。 LeetCode算法题：题号347，前K个高频元素 解题思路： 前K个高频元素，使用最小堆解决问题 解题步骤 构建一个最小堆，并依次把处理过的数据的值插入到堆中 当堆的容量大于K时，删除堆顶 遍历结束后返回处理后的堆 代码实现： class MinHead { constructor() { this.heap = [] } getLeftIndex(index) { return index * 2 + 1 } getRightIndex(index) { return index * 2 + 2 } peek() { return this.heap[0] } size() { return this.heap.length } swap(i1, i2) { const tmp = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = tmp } getParentIndex(index) { return (index - 1) &gt;&gt; 1 } shiftUp(index) { if (index === 0) return const parentIndex = this.getParentIndex(index) if ( this.heap[parentIndex] &amp;&amp; this.heap[parentIndex][1] &gt; this.heap[index][1] ) { this.swap(parentIndex, index) this.shiftUp(parentIndex) } } insert(target) { this.heap.push(target) this.shiftUp(this.heap.length - 1) } shiftDown(index) { const leftIndex = this.getLeftIndex(index) const rightIndex = this.getRightIndex(index) if (this.heap[leftIndex] &amp;&amp; this.heap[index][1] &gt; this.heap[leftIndex][1]) { this.swap(leftIndex, index) this.shiftDown(leftIndex) } if ( this.heap[rightIndex] &amp;&amp; this.heap[index][1] &gt; this.heap[rightIndex][1] ) { this.swap(rightIndex, index) this.shiftDown(rightIndex) } } pop() { this.heap[0] = this.heap.pop() this.shiftDown(0) } } /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function(nums, k) { const heap = new MinHead() const map = new Map() for (let i = 0; i &lt; nums.length; i++) { const c = nums[i] map.set(c, map.get(c) ? map.get(c) + 1 : 1) } map.forEach((value, key) =&gt; { heap.insert([key, value]) if (heap.size() === k + 1) { heap.pop() } }) return heap.heap.map((i) =&gt; i[0]) } 由于代码中使用了遍历了数组，所以时间复杂度是O(n)，n是数组的长度，在遍历的时候操作堆，在上移元素或者下移元素的操作中的时间复杂度是O(logK)，K是堆的大小，所以时间复杂度是O(n * logK)。 由于代码中使用了堆，所以空间复杂度是O(K)，K是堆的大小。 LeetCode算法题：题号23，合并k个排序链表 解题思路； 排序可以使用堆数据结构，由于这道题目是链表，所以在取出堆顶的时候，如果next不为空，则还需要将next插入的堆中 解题步骤： 构建一个最小堆，并依次把链头插入到堆中 弹出堆顶接到输出链表，并将堆顶所在链表的新链表头插入到堆中 等堆元素全部弹出，合并工作就完成了 代码实现： class MinHead { constructor() { this.heap = [] } getLeftIndex(index) { return index * 2 + 1 } getRightIndex(index) { return index * 2 + 2 } peek() { return this.heap[0] } size() { return this.heap.length } swap(i1, i2) { const tmp = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = tmp } getParentIndex(index) { return (index - 1) &gt;&gt; 1 } shiftUp(index) { if (index === 0) return const parentIndex = this.getParentIndex(index) if ( this.heap[parentIndex] &amp;&amp; this.heap[parentIndex].val &gt; this.heap[index].val ) { this.swap(parentIndex, index) this.shiftUp(parentIndex) } } insert(target) { this.heap.push(target) this.shiftUp(this.heap.length - 1) } shiftDown(index) { const leftIndex = this.getLeftIndex(index) const rightIndex = this.getRightIndex(index) if ( this.heap[leftIndex] &amp;&amp; this.heap[index].val &gt; this.heap[leftIndex].val ) { this.swap(leftIndex, index) this.shiftDown(leftIndex) } if ( this.heap[rightIndex] &amp;&amp; this.heap[index].val &gt; this.heap[rightIndex].val ) { this.swap(rightIndex, index) this.shiftDown(rightIndex) } } pop() { const t = this.heap.pop() if (this.size() === 0) { return } this.heap[0] = t this.shiftDown(0) } } /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode[]} lists * @return {ListNode} */ var mergeKLists = function(lists) { const heap = new MinHead() for (let i = 0; i &lt; lists.length; i++) { lists[i] &amp;&amp; heap.insert(lists[i]) } const ln = new ListNode(0) let p = ln while (heap.size() &gt; 0) { const t = heap.peek() p.next = t p = p.next heap.pop() if (t.next) { heap.insert(t.next) } } return ln.next } 由于代码中使用了while循环，循环的次数是所有链表的长度，时间复杂度是O(n)，在循环的过程在堆在进行上移或者下移的操作，时间复杂度是O(logK)，K是K个链表，所以最终时间复杂度是O(n * logK)。 由于代码中使用了堆数据结构，所以空间复杂度是O(n)，n是K个链表。 最后，希望读者可以通过本篇文章对堆有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-jie-gou-zhi-dui/"},{"title":"数据结构之图","content":"本篇文章可以收获的知识： 什么是图 图的常用操作 三道LeetCode算法题巩固图 如何分析时间复杂度和空间复杂度 什么是图 图是网络结构的抽象模型，是一组由边连接的节点，JavaScript中没有图，使用Object和Array构建图，图的表示法有领接矩阵、领接表（JavaScript中常用）、关联矩阵等，图可以表示二元关系比如：道路、航班等。 领接矩阵表示： 领接表表示： const graph = { A: [&quot;B&quot;, &quot;D&quot;], B: [&quot;E&quot;], C: [&quot;D&quot;], D: [&quot;E&quot;], E: [] } 图的常用操作 深度优先遍历 // 深度优先遍历思路 // 访问根节点 // 对根节点没访问过的相邻节点进行深度优先遍历 const graph = { A: [&quot;B&quot;, &quot;D&quot;], B: [&quot;E&quot;], C: [&quot;D&quot;], D: [&quot;E&quot;], E: [] } const set = new Set() const dfs = (root) =&gt; { set.add(root) console.log(graph[root]) // 访问根节点 graph[root].forEach(i =&gt; { if (!set.has(i)) { dfs(i) } }) } dfs(&quot;A&quot;) 广度优先遍历 // 广度优先遍历思路 // 新建一个队列，把根节点入队 // 把队头出队访问 // 把队头没访问过的相邻节点入队 // 重复二三步 const graph = { A: [&quot;B&quot;, &quot;D&quot;], B: [&quot;E&quot;], C: [&quot;D&quot;], D: [&quot;E&quot;], E: [] } const bfs = (root) =&gt; { const q = [root] const set = new Set() while(q.length) { const h = q.shift() set.add(h) console.log(graph[h]) graph[h].forEach(i =&gt; { if (!set.has(i)) { q.push(i) } }) } } bfs(&quot;A&quot;) LeetCode算法题：题号65，有效的数字 根据题目的要求，可以构建出下面的图，3、5、6是题目中所说的有效的数字 解题思路： 构建一个表示状态的图 遍历字符串，并沿着图走，如果到了某个节点无路可走，说明是个无效的数字，返回false 遍历结束后，如果状态在3、5、6的时候说明是有效的数字 代码实现： /** * @param {string} s * @return {boolean} */ var isNumber = function(s) { const graph = { 0: { &quot;black&quot;: 0, &quot;sign&quot;: 1, &quot;number&quot;: 6, &quot;.&quot;: 2 }, 1: { &quot;number&quot;: 6, &quot;.&quot;: 2 }, 2: { &quot;number&quot;: 3 }, 3: { &quot;e&quot;: 4, &quot;number&quot;: 3 }, 4: { &quot;number&quot;: 5, &quot;sign&quot;: 7 }, 5: { &quot;number&quot;: 5 }, 6: { &quot;number&quot;: 6, &quot;.&quot;: 3, &quot;e&quot;: 4 }, 7: { &quot;number&quot;: 5 } } let state = 0 for (let c of s.trim()) { if (c &gt;= 0 &amp;&amp; c &lt;= 9) { c = &quot;number&quot; } if ([&quot;+&quot;, &quot;-&quot;].includes(c)) { c = &quot;sign&quot; } if ([&quot;e&quot;, &quot;E&quot;].includes(c)) { c = &quot;e&quot; } state = graph[state][c] if (state === undefined) { return false } } return [3, 5, 6].includes(state) }; 由于代码用到了for循环，循环的次数最多是字符串的长度，所以时间复杂度是O(n)，n是字符串的长度。 由于代码中没有用到临时的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号417，太平洋大西洋水流问题 解题思路： 把矩阵想象成图 从海岸线逆流而上遍历图，所到之处就是可以流到某个大洋的坐标 解题步骤： 新建两个矩阵，分别记录能流到两个大洋的目标 从海岸线，同时深度优先遍历图，过程中填充矩阵 遍历两个矩阵，找出能流到两个大洋的坐标 代码实现： var pacificAtlantic = function(matrix) { if (!matrix || matrix.length === 0) { return [] } const m = matrix.length const n = matrix[0].length const flow1 = Array.from({ length: m }, () =&gt; Array.from({ length: n }, () =&gt; false) ) const flow2 = Array.from({ length: m }, () =&gt; Array.from({ length: n }, () =&gt; false) ) const dfs = (x, y, flow) =&gt; { flow[x][y] = true ;[ [x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1], ].forEach(([ix, iy]) =&gt; { if ( ix &gt;= 0 &amp;&amp; iy &gt;= 0 &amp;&amp; ix &lt;= m - 1 &amp;&amp; iy &lt;= n - 1 &amp;&amp; !flow[ix][iy] &amp;&amp; matrix[ix][iy] &gt;= matrix[x][y] ) { dfs(ix, iy, flow) } }) } for (let i = 0; i &lt; m; i++) { dfs(i, 0, flow1) dfs(i, n - 1, flow2) } for (let j = 0; j &lt; n; j++) { dfs(0, j, flow1) dfs(m - 1, j, flow2) } const res = [] for (let i = 0; i &lt; m; i++) { for (let j = 0; j &lt; n; j++) { if (flow1[i][j] &amp;&amp; flow2[i][j]) { res.push([i, j]) } } } return res } 由于代码中遍历了整个矩阵，所以空间复杂度是O(m * n)，m是矩阵的列数，n是矩阵的行数。 由于代码中使用了递归，调用的堆栈是m * n也就是堆栈的列数*行数，所以空间复杂度是O(m * n)。 LeetCode算法题：题号133，克隆图 解题思路： 拷贝所有的节点 解题步骤： 深度或者广度优先遍历所有节点 拷贝所有节点，存储起来 将拷贝的节点，按照原图的连接方法进行连接 代码实现： /** * // Definition for a Node. * function Node(val, neighbors) { * this.val = val === undefined ? 0 : val; * this.neighbors = neighbors === undefined ? [] : neighbors; * }; */ /** * @param {Node} node * @return {Node} */ var cloneGraph = function(node) { if (!node) { return } const q = [node] const map = new Map() map.set(node, new Node(node.val)) while(q.length) { const h = q.shift() ;(h.neighbors || []).forEach((i) =&gt; { if (!map.has(i)) { q.push(i) map.set(i, new Node(i.val)) } map.get(h).neighbors.push(map.get(i)) }) } return map.get(node) }; 由于代码中使用了while循环，循环的次数是节点数，所以时间复杂度是O(n)，n是节点的数量。 由于代码中使用了队列数据结构，最大的长度是节点数量，所以空间复杂度是O(n)，n是节点的数量。 最后，希望读者可以通过本篇文章对图有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-jie-gou-zhi-tu/"},{"title":"数据结构之树","content":"本篇文章可以收获的知识： 什么是树 树的常用操作 五道LeetCode算法题巩固树 如何分析时间复杂度和空间复杂度 什么是树 树是一种分层数据的抽象模型，在JavaScript中没有树，但是可以使用Array和Object构建树，前端工作中常见的树包括：Dom树、级联选择器、树形控件等。 树的常用操作 树的深度/广度遍历 // 构建一颗树 const tree = { value: &quot;A&quot;, children: [ { value: &quot;B&quot;, children: [ { value: &quot;D&quot;, children: [] }, { value: &quot;E&quot;, children: [] } ] }, { value: &quot;C&quot;, children: [ { value: &quot;F&quot;, children: [] }, { value: &quot;G&quot;, children: [] } ] } ] } 深度优先遍历：尽可能的搜索树的分支 // 深度优先遍历思路 // 访问根节点 // 遍历子节点，深度优先遍历子节点 const dfs = (root) =&gt; { console.log(root.value) // 访问根节点 dfs.children.forEach(i =&gt; dfs(i) } dfs(tree) 广度优先遍历：先访问离根节点最近的节点 // 广度优先遍历思路 // 新建一个队列 // 根节点入队 // 把队头出队并访问 // 将队头的子节点依次入队 // 重复最后两步 const bfs = (root) =&gt; { const q = [root] // 根节点入队 while(q.length) { const t = q.shift() // 队头出队 console.log(t.value) // 访问队头元素 t.children.forEach(i =&gt; q.push(i)) // 将对头的子节点依次入队 } } bfs(tree) 二叉树先中后序遍历（递归与非递归版） // 二叉树就是树中的每个节点最多只能有两个子节点 // 构建一颗二叉树 const binaryTree = { value: &quot;A&quot;, left: { value: &quot;B&quot;, left: { value: &quot;D&quot;, left: null, right: null }, right: { value: &quot;E&quot;, left: null, right: null } }, right: { value: &quot;C&quot;, left: { value: &quot;F&quot;, left: null, right: null, }, right: { value: &quot;G&quot;, left: null, right: null } } } 先序遍历 // 先序遍历思路 // 访问根节点 // 先序遍历根节点的左子树 // 先序遍历根节点的右子树 // 递归版 const preorder = (root) =&gt; { if (!root) return console.log(root.value) // 访问根节点 preorder(root.left) // 先序遍历根节点的左子树 preorder(root.right) // 先序遍历根节点的右子树 } preorder(binaryTree) // 非递归版 // 除了先序遍历的基本思路外，非递归版借用栈来实现 // 因为栈是后进先出的，所以入栈的时候我们需要先把右子树入栈，再左子树入栈 const preorder = (root) =&gt; { if (root) return const stack = [root] while(stack.length) { const p = stack.pop() console.log(p.value) // 访问根节点 stack.push(p.right) // 将根节点的右子树入栈 stack.push(p.left) // 将根节点的左子树入栈 } } preorder(binaryTree) 中序遍历 // 中序遍历的思路 // 中序遍历根节点的左子树 // 访问根节点 // 中序遍历根节点的右子树 // 递归版 const inorder = (root) =&gt; { if (root) return inorder(root.left) // 中序遍历根节点的左子树 console.log(root.value) // 访问根节点 inorrder(root.right) // 中序遍历根节点的右子树 } inorder(binaryTree) // 非递归版 // 除了中序遍历的思路外，非递归版借用栈来实现 // 定义一个指针，将指针的左子树入栈，直到指针为空，访问根节点，将指针赋值有指针 const inorder = (root) =&gt; { if (!root) return const stack = [] let p = root while(stack.length || p) { while(p) { // 中序遍历左子树 stack.push(p) p = p.left } const t = stack.pop() console.log(t.value) // 访问根节点 p = t.right // 中序遍历右子树 } } inorder(binaryTree) 后序遍历 // 后序遍历的思路 // 后序遍历根节点的左子树 // 后序遍历根节点的右子树 // 访问根节点 // 递归版 const postorder = (root) =&gt; { if (root) return postorder(root.left) // 后序遍历左子树 postorder(root.right) // 后序遍历左子树 console.log(root.value) // 访问根节点 } postorder(binaryTree) // 非递归版 // 出了后序遍历的思路外，非递归版借用栈来实现 // 因为最后访问的根节点，所以我们可以把所有的节点按照规则进栈后，再出栈访问 const postorder = (root) =&gt; { if (!root) return const stack = [root] const outputStack = [] while(stack.length) { const t = stack.pop() outputStack.push(t) if (t.left) { stack.push(t.left) } if (t.right) { stack.push(t.right) } } while(outputStack.length) { const t = outputStack.pop() console.log(t.value) } } postorder(binaryTree) LeetCode算法题：题号104，二叉树的最大深度 解题思路： 求最大深度，考虑使用深度优先遍历 在遍历的过程中，记录每个节点的层级，找出最大的层级 解题步骤： 使用深度优先遍历，遍历过程中，如果左子树和右子树为空时，记录该层级 遍历结束后返回最大层级 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { let max = 0 const dfs = (root, d) =&gt; { if (!root) return if (!root.left &amp;&amp; !root.right) { max = Math.max(m, d) } dfs(root.left, d + 1) dfs(root.right, d + 1) } dfs(root, 1) return m }; 因为代码中使用了递归，循环的次数是树的节点数，所以时间复杂度是O(n)，n是树的节点数。 因为代码中使用了递归，函数调用堆栈的大小可能是树的节点数或者是树的层级，所以空间复杂度是O(n)或者是O(logn)，n是树的节点数。 LeetCode算法题：题号111，二叉树的最小深度 解题思路： 求二叉树的最小深度，使用广度优先遍历 遇到叶子节点，停止遍历，返回当前层级 解题步骤： 使用广度优先遍历二叉度，并记录每一层的层数 遇到叶子节点，停止遍历返回当前层级 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var minDepth = function(root) { if (!root) return 0 const q = [[root, 1]] while(q.length) { const [n, d] = q.shift() if (!n.left &amp;&amp; !n.right) { return d } if (n.left) { q.push([n.left, d + 1]) } if (n.right) { q.push([n.right, d + 1]) } } }; 由于代码中有个while循环，循环的次数最大是树的节点数，所以时间复杂度是O(n)，n是树的节点数。 由于代码中用到了队列的数据结构，长度并不会线性的增长，最大长度是树的节点数，所以空间复杂度是O(n)，n是树的节点数。 LeetCode算法题：题号102，二叉树的层序遍历 解题思路： 层序遍历顺序就是广度优先遍历 不过遍历时需要记录当前节点所在的层级，目的是为了添加到数组中 解题步骤： 使用广度优先遍历二叉树 遍历过程中，记录每个节点的层级，并将其添加到不同的数组中 代码实现： /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function(root) { if (!root) { return [] } const q = [[root, 0]] const res = [] while(q.length) { const [n, d] = q.shift(); res[d] = res[d] ? [...res[d], n.val] : [n.val] if (n.left) { q.push([n.left, d + 1]) } if (n.right) { q.push([n.right, d + 1]) } } return res }; 由于代码中有个while循环，循环的次数是二叉树的节点数，所以时间复杂度是O(n)，n是二叉树的节点数。 由于代码中用到了队列的数据结构，长度并不会线性的增长，长度最大是二叉树的节点数，所以空间复杂度是O(n)，n是二叉树的节点数。 LeetCode算法题：题号94，二叉树的中序遍历 解题思路： 使用二叉树的中序遍历，在遍历过程中记录每个节点的值 解题步骤： 使用二叉树的中序遍历，把访问根节点修改成对应的逻辑即可 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var inorderTraversal = function(root) { if (!root) { return [] } const stack = [] let p = root const res = [] while(stack.length || p) { while(p) { stack.push(p) p = p.left } const t = stack.pop() res.push(t.val) p = t.right } return res }; 由于代码中使用while循环，循环的次数是二叉树的节点数，所以时间复杂度是O(n)，n是二叉树的节点数。 由于代码中用到了栈数据结构，长度不会线性增长，最大长度是二叉树的节点数，所以空间复杂度是O(n)，n是二叉树的节点数。 LeetCode算法题：题号112，路径总和 解题思路： 求路径总和，使用深度优先遍历 遍历过程中记录路径的总和 解题步骤： 使用深度优先遍历二叉树，记录路径的总和，如果是叶子节点并且总和与传入的目标值相等，结束循环。 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} targetSum * @return {boolean} */ var hasPathSum = function(root, targetSum) { if (!root) { return false } let res = false const dfs = (n, c) =&gt; { if (!n.left &amp;&amp; !n.right &amp;&amp; c === targetSum) { res = true return } if (n.left) { dfs(n.left, c + n.left.val) } if (n.right) { dfs(n.right, c + n.right.val) } } dfs(root, root.val) return res }; 由于代码使用递归，调用的次数最大是二叉树的节点数，所以时间复杂度是O(n)，n是二叉树的节点数。 由于代码使用递归，函数调用堆栈可能是二叉树的节点数，或者是二叉树的层级，所以空间复杂度是O(n)或者是O(logn)，n是二叉树的节点数。 最后，希望读者可以通过本篇文章对树有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-jie-gou-zhi-shu/"},{"title":"数据结构之字典","content":"本篇文章可以收获的知识： 什么是字典 字典的常用操作 三道LeetCode算法题巩固字典 如何分析时间复杂度和空间复杂度 什么是字典 字典与集合类似，字典也是一种存储唯一值的数据结构，但字典是以键值对的形式来存储，ES6中有字典，名为Map。 字典的常用操作 const m = new Map() // 字典 m.set(&quot;a&quot;, &quot;b&quot;) // 给字典添加元素 m.set(&quot;a&quot;, &quot;c&quot;) // 修改字典的某个元素 m.get(&quot;a&quot;) // 从字典中获取目标元素 m.delete(&quot;a&quot;) // 从字典中删除目标元素 m.clear() // 清空字典 LeetCode算法题：题号349，两个数组的交集 解题思路： 用字典建立一个映射关系，记录nums1的值 遍历nums2，找出nums1也有的值 解题步骤： 新建一个字典，遍历nums1，填充字典 遍历nums2，遇到字典里的值选出来，并从字典中删除 代码实现： /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function(nums1, nums2) { const nums3 = [] const m = new Map() nums1.forEach(i =&gt; m.set(i, true)) nums2.forEach(i =&gt; { if (m.get(i)) { nums3.push(i); m.delete(i) } }) return nums3; }; 因为代码中有个循环，循环次数是数组的长度，所以时间复杂度是O(n)，n是数组的长度。 因为代码中使用了map数据结构，长度最大是数组的长度，所以空间复杂度是O(n)，n是数组的长度。 LeetCode算法题：题号1，两数之和 解题思路： 把nums当成已婚人士（成员中可能有自己的对象，也有可能对象不在这个nums中）。 把target当成寻找自己对象的目标 用字典建立一个房间，存储已婚人士的值和下标 解题步骤： 用字典建立一个房间 遍历nums如果没有找到对象的保留在房间中，如果找到就结束 代码实现： /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { const m = new Map() for (let i = 0; i &lt; nums.length; i ++) { if (m.has(target - nums[i])) { return [m.get(target - nums[i]), i] } m.set(nums[i], i) } }; 因为代码有一个for循环体，循环次数最大是nums的长度，所以时间复杂度是O(n)，n是数组的长度。 因为代码中用到map数据结构，最大长度是数组的长度，所以空间复杂度是O(n)，n是数组的长度。 LeetCode算法题：题号3，无重复字符串的最长字串 解题思路： 找出所有没有重复的字符的子串 找出长度最大的那个子串，返回其长度 解题步骤： 用双指针维护一个滑动窗口，用来剪切子串 不断移动右指针，遇到重复字符，就把左指针移动到重复字符的下一位 过程中记录所有窗口的最大长度 代码实现： /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { let l = 0 let max = 0; const map = new Map() for (let r = 0; r &lt; s.length; r ++) { if (map.has(s[r]) &amp;&amp; map.get(s[r] &gt;= l)) { l = map.get(s[r]) + 1 } max = Math.max(max, r - l + 1) map.add(s[r], r) } }; LeetCode算法题：题号76，最小覆盖子串 解题思路： 找出所有覆盖的子串 返回最小的子串 解题步骤： 使用一前一后双指针维护一个窗口 不断的移动右指针，当窗口中包含目标子串的时候，移动左指针 当左指针对应的字符串在目标字符串中的时候，记录子串 代码实现： /** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { let l = 0 let m = new Map() let str = &quot;&quot; let type = 0 for (let i = 0; i &lt; t.length; i++) { m.set(t[i], 1) } for (let r = 0; r &lt; s.length; r++) { const c = s[r] if (m.has(c)) { m.set(c, m.get(c) - 1) m.get(c) === 0 &amp;&amp; (type += 1) } while (type === 3) { if (m.has(s[l])) { str = !str || r - l + 1 &lt; str.length ? s.substr(l, r + 1) : str m.set(s[l], m.get(s[l]) + 1) m.get(s[l]) === 1 &amp;&amp; (type -= 1) } l += 1 } } return str } 最后，希望读者可以通过本篇文章对字典有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-jie-gou-zhi-zi-dian/"},{"title":"数据结构之集合","content":"本篇文章可以收获的知识： 什么是集合 集合的使用场景 一道LeetCode算法题巩固集合 如何分析时间复杂度和空间复杂度 JavaScript中的集合 什么是集合 集合是一种无序且唯一的数据结构，ES6中的集合，名为Set 集合的使用场景 数组去重 const a1 = [1, 1, 2, 2, 3, 4, 5]; const a2 = [...new Set(a1)] 判断元素是否存在集合中 const s = new Set([1, 2, 3, 4]) s.has(1) // 返回boolean 求两个集合的交集 const s1 = new Set([1, 2, 3, 4]) const s2 = new Set([2, 3]) const s3 = new Set([...s1].filter(i =&gt; s1.has(i))) LeetCode算法题：题号349，两个数组的交集 解题思路： 求交集且唯一 使用集合 解题步骤： 使用集合对数组进行去重 遍历其中一个数据，判断另一个数据是否包含 实现代码： /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function(nums1, nums2) { const s1 = new Set(nums1); const s2 = new Set(nums2); const res = [...s1].filter(i =&gt; s2.has(i)) return res }; 因为代码有用到了filter，每一个元素都要进行过滤，循环次数最大可能是nums1的长度乘以nums2的长度，所以时间复杂度是O(n * m)，n是nums1的长度，m是nums2的长度。 因为代码中用到了set数据结构，长度最大是两个数组中最大的长度，所以空间复杂度是O(n)，n是数组的长度。 这道LeetCode的算法题的最优解法是使用字典数据结构解决，在数据结构之字典文章中也会提及。 JavaScript中的集合 // JavaScript中集合的常用操作 const s = new Set() s.add(1) // 添加操作 s.delete(1) // 删除操作 s.size() // 获取集合的长度 s.has(1) // 判断集合中是否有当前元素 // JavaScript中集合的迭代 for(let item of m) {} for(let item of m.keys()) {} for(let item of m.values()) {} for(let [key, value] of m.entries()) {} // key === value // JavaScript中集合与数组互转 const a = Array.from(new Set([1, 2])) const s1 = new Set(a) 最后，希望读者可以通过本篇文章对集合有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-jie-gou-zhi-ji-he/"},{"title":"数据结构之链表","content":"本篇文章可以收获的知识： 什么是链表 链表的常用操作与数组的对比 四道LeetCode算法题巩固链表 如何分析时间复杂度和空间复杂度 详解JavaScript中的原型链 详解instanceof的原理 使用链表指针获取JSON 的节点值 什么是链表 链表是由多个元素组成的列表，元素存储是不连续的，元素之间用next指针连在一起，在JavaScript中没有链表，使用Object来模拟链表的功能。 链表的常用操作 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ const n1 = new ListNode(1) // 链表1 const n2 = new ListNode(2) // 链表2 const n3 = new ListNode(3) // 链表3 n1.next = n2 // 给n1链表，插入元素 n2.next = n3 // 给n2链表，插入元素 n1.next = n3 // 删除n2元素，一开始n1的指针指向n2的，让n1的指针指向n3就删除n2 // 遍历链表操作 // 思路 // 定义一个指针 // 循环遍历指针，访问当前指针，指针指向下一针，直到指针为空 let p = n1; while(p) { console.log(p.val) p = p.next; } 了解了链表的操作之后，我们会发现链表的新增元素和删除元素只需要修改某个指针就能实现需求，而数组在这些操作之后，需要移动元素来实现（除操作首尾元素），所以做增删操作的时候，链表的性能是比数据的性能高的。 LeetCode算法题：题号237，删除链表中的节点 其实这道题相对简单，做题人一开始的思路肯定是让传进来的node的上一个元素的next指向node的下一个元素就可以了，但是我们并不知道node的上一个元素，所以我们可以在node的下一个元素做文章。 解题思路： 不能拿到node的上一个元素，只能拿到node的下一个元素 将node的元素替换成node的下一个元素 解题步骤： 将node的下一个元素的值赋值给node 让node的下一个元素指向node的下下个元素 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} node * @return {void} Do not return anything, modify node in-place instead. */ var deleteNode = function(node) { node.val = node.next.val; node.next = node.next.next; }; 这道题因为没有循环体，没有额外的产生数据结构，所以时间复杂度和空间复杂度都是O(1)。 LeetCode算法题：题号206，反转链表 方法一，正向反转指针： 解题思路： 反转两个节点，将n+1的指针指向n 反转多个节点，重复上面的操作就能实现。 解题步骤： 一定一前一后指针，遍历链表 反转指针 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { let p1 = null; let p2 = head while(p2) { const tmp = p2.next; p2.next = p1; p1 = p2; p2 = tmp } return p1; }; 因为代码中有个while循环体，循环的次数是传进来的链表长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 方法二，反向反转指针： 解题思路： 反向反转指针，从链表的尾指针开始反转指针 这个场景非常适合递归来实现 解题步骤： 两个节点的反转，让当前指针的下下指针等于当前指针，然后将当前的下个指针等于null，解决闭环问题。 重复上一步骤 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { if (head === null || head.next === null) { return head; } const newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; }; 因为代码中是使用递归实现的，需要对链表的每个节点进行反转操作，所以时间复杂度是O(n)，n是链表的长度。 代码中虽然没有产生额外的数据结构，但是这里使用递归，递归的空间复杂度主要取决于递归调用栈的空间，也就是链表的长度，所以空间复杂度是O(n)。 LeetCode算法题：题号83，删除排序链表中的重复元素 解题思路： 给定的链表是有序的 当前指针的值等于下一指针的值时，删除下一个指针。 解题步骤： 遍历链表，当前指针的值等于下一指针的值时，将当前指针的指向下下个指针。 遍历结束后，返回链表的头部。 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { let p = head; while(p &amp;&amp; p.next) { if (p.val === p.next.val) { p.next = p.next.next; } else { p = p.next; } } return head; }; 因为代码中有个while循环体，循环的次数是链表的长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号141，环形链表 解题思路： 把这个场景想像成操场上跑步，跑的快的人，在某个时间会再遇到跑得快的人。 定义一快一慢指针，如果再某个时间两个指针能相遇，说明有环。 解题步骤： 定义一快一慢指针 如果在跑的过程在能遇到，返回true，如果快指针为null或者下一针为null，说明没有环，返回false 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { let slowP = head; let fastP = head; while(fastP &amp;&amp; fastP.next) { slowP = slowP.next; fastP = fastP.next.next; if (slowP === fastP) { return true; } } return false; }; 因为代码中有个while循环体，循环的次数最大的链表的长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 JavaScript中的原型链 原型 原型是实例对象的共有祖先，通俗的讲，构造函数有prototype属性，由这个构造函数构造出来的实例可以访问到prototype里的属性。 function Person() {} Person.prototype.name = &quot;nickname&quot; const p = new Person(); p.name; // nickname 原型链 原型链本质上是链表，通过__proto__属性进行连接，每个对象都有__proto__属性，如果访问的属性不存在的时候，会沿着对象的__proto__属性去寻找，直到为null，__proto__指向构造函数的prototype对象，也就是原型。 const n = Number(1) n.__proto__ = Number.prototype Number.prototype.__proto__ = Object.prototype Object.prototype.__proto__ = null const o = Object.create({}) o.__proto__ = Object.prototype Object.prototype.__proto__ = null // 数组、布尔、字符串也如此 ... ... ... Instanceof的原理 记住一句话，如果A instanceof B为true，说明在A的原型链上可以找到B的原型。 实现instanceof的代码： // 思路 // 定义一个指针 // 遍历A的原型链，如果A的原型链上有B的原型，返回true // 遍历完之后，说明找不到，但会false const coInstanceof = (A, B) =&gt; { let p = A while(p) { if (p.__proto__ === B.prototype) { return true } p = p.__proto__ } return false } 使用链表指针获取JSON的节点值 const json = { a: { b: { c: 1 } }, d: { e: 2 }, } const path = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; let p = json path.forEach(i =&gt; { p = p[i] console.log(`${i}：${JSON.stringify(p)}`) }) // 日志输出 // a: { b: { c: 1 } } // b: { c: 1 } // c: 1 最后，希望读者可以通过本篇文章对链表有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-jie-gou-zhi-lian-biao/"},{"title":"数据结构之队列","content":"本篇文章可以收获的知识： 什么是队列 队列的常用操作 队列的使用场景 一道LeetCode算法题巩固队列 如何分析时间复杂度和空间复杂度 什么是队列 队列是一个先进先出的数据结构，JavaScirpt中没有队列，但可以使用Array实现队列的所有功能。 队列的常用操作 const queue = [] // 队列 queue.push(1) // 入队（enqueue） queue.shift() // 出队（dequeue） 队列的使用场景 食堂排队打饭 食堂排队打饭都不陌生，先排队的学生可以先打到饭，符合队列的特点。 JavaScript异步任务队列 JavaScript是单线程的，无法同时处理异步任务中的并发任务，使用任务队列先后处理异步任务 计算最近请求次数 一个请求队列[[], [1], [100], [3001], [3002]],计算[t-3000, t]的请求次数，首先新请求t先入队，不在这个区间的出队。后面也会通过一道LeetCode算法题巩固队列的知识。 遇到这些相似的问题，都可以优先考虑使用队列来解决问题。 LeetCode算法题：题号933，最近的请求次数 解题思路： 越早发出的请求，越靠前 符合先进先出的特点，考虑使用队列。 解题步骤： 新请求，入队 不在[t - 3000, t]区间内的成员出队 最后队列的长度就是最近的请求次数 代码实现： var RecentCounter = function() { this.q = []; }; /** * @param {number} t * @return {number} */ RecentCounter.prototype.ping = function(t) { this.q.push(t); while(t - 3000 &gt; this.q[0]) { this.q.shift(); } return this.q.length; }; /** * Your RecentCounter object will be instantiated and called as such: * var obj = new RecentCounter() * var param_1 = obj.ping(t) */ 分析时间复杂度和空间复杂度 因为代码中有个while循环体，循环的次数最大是ping的次数，所以时间复杂度是O(n)，n是ping的次数。 因为代码中用到了队列，最大的长度是3000，所以空间复杂度是O(n)，n最大是3000。 最后，希望读者可以通过本篇文章对队列有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-jie-gou-zhi-dui-lie/"},{"title":"数据结构之栈","content":"本篇文章可以收获的知识： 什么是栈 栈的常用操作 栈的使用场景 一道LeetCode算法题巩固栈 如何分析时间复杂度和空间复杂度 什么是栈 栈是一个后进先出的数据结构，在JavaScript中没有栈，但是可以使用Array来实现栈的所有功能。 栈的常用操作 const stack = [] // 栈 stack.push(1) // 入栈 const item = stack.pop() // 出栈 栈的使用场景 十进制转二进制 可以从图中可以看到，我们如果按照顺序求出来的商是00111001，但是十进制转二进制得出来的结果是10011100，明显有后进先出的意思，所以遇到十进制转二进制的问题的时候，使用栈是最适合的。 有效的括号 在我们开发中经常也会用到括号，例如([])，这样的括号会发现，(是先进的，[是后进的，但是]是先出的，这就符合栈的后进先出的特点，所以遇到有效括号这类的问题的时候，使用栈是最合适的。后面也会通过一道有效的括号LeetCode算法题来巩固栈的知识。 函数调用堆栈 可以通过下面的代码进行断点进行调试，我们会发现我们先调用fn1，但是最后执行结束的是fn1 const fn1 = () =&gt; { fn2() } const fn2 = () =&gt; { fn3() } const fn3 = () =&gt; {} fn1() LeetCode算法题：题号20，有效的括号 解题思路： 对于没有闭合的左括号而言，越靠后的左括号，对应的右括号越靠前 满足后进先出的特点 解题步骤： 新建一个栈 判断字符串的长度是否是偶数，奇数直接判定为不合法 扫描字符串，遇到左括号入栈，遇到和栈顶括号类型匹配的右括号就出栈，类型不匹配直接判定为不合法 遍历结束后，栈为空代表合法，不为空代表不合法 代码实现： /** * @param {string} s * @return {boolean} */ var isValid = function(s) { if (s.length % 2 === 1) { return false; } const stack = []; const m = new Map(); m.set(&quot;(&quot;, &quot;)&quot;); m.set(&quot;{&quot;, &quot;}&quot;); m.set(&quot;[&quot;, &quot;]&quot;); for (let i = 0; i &lt; s.length; i ++) { if (m.has(s[i])) { stack.push(s[i]); } else { if (m.get(stack[stack.length - 1]) !== s[i]) { return false } stack.pop() } } return stack.length === 0; }; 分析时间复杂度和空间复杂度： 因为代码中有一个for循环，循环的次数可能是传进来的字符串长度，所以时间复杂度是O(n)，n就是传进来的字符串长度。 代码中定义了两个数据结构，Array和Map，因为Array并不会线性的增长所以是O(n)，Map是O(n)，所以最终的空间复杂度是O(n)，n是传进来的字符串长度。 最后，希望读者可以通过本篇文章对栈有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-jie-gou-zhi-zhan/"},{"title":"数据结构与算法介绍","content":"在学习数据结构与算法之前必须知道的几个概念： 什么是数据结构： 为了解决问题，会将数据用特定的方式存储起来，存储的方式不同就会导致不同的算法处理，当然我们希望算法的效率越快越好，那么我们就需要考虑数据如何保存，这就是数据结构。 通俗的讲数据结构就是计算机存储、组织数据的方式，就像是锅碗瓢盆，它们都是来存放东西的。 什么是算法： 一系列解决问题的清晰指令，就像是厨房里的食谱，有特定的制作教程，根据这个教程就可以做出相应的菜。 数据结构与算法的关系： 数据结构为算法提供服务，算法围绕数据结构操作。 如何判断一个算法是否可取 在作者身边的有一个真实的示例，一位后端工程师说：“昨天看到一个某某的算法，但是我觉得这个算法不太好...”。 这位后端工程师判断一个算法是否可行单凭直觉，这样的判断肯定是不可取的，正确的判断方式是通过时间复杂度和空间复杂度。 认识时间复杂度 时间复杂度，定性描述该算法的运行时间，通俗讲就是一个算法的循环次数。 时间复杂度的表示用一个函数 O 表示，比如 O(1)、O(n)、O(logN)...，表示时间复杂度的时候，不需要确却计算出这个数值。 两个时间复杂度相加时，取最大即可，例：O(1) + O(n) = O(n) 两个时间复杂度相乘时，相乘即可，例：O(n) * O(logN) = O(n * logN) 它们的关系是：n! &gt; 2^n &gt; n^2 &gt; nlogN &gt; n &gt; √n &gt; logN &gt; 1 认识空间复杂度 空间复杂度，对一个算法在运行过程中临时占用存储空间大小的度量。 空间复杂度的表示用一个函数 O 表示，比如 O(1)、O(n)、O(n^2)...。 认识每个数据结构 栈（Stack）：一个后进先出的数据结构，JavaScript 中并没有栈，通过 Array 来实现栈的功能，通过方法push、pop来实现入栈和出栈。 队列（Queue）：一个先进先出的数据结构，JavaScript 中没有队列，通过 Array 来实现队列的功能，通过方法push、shift来实现入队(enqueue)和出队(dequeue)。 链表（LinkedList）：一个由多个元素组成的列表，元素存储是不连续，通过next指针连在一起，JavaScript 中没有链表，通过 Object 来实现链表的功能。 集合（Set）：一个无序且唯一的数据结构，ES6 中的集合, 名Set。 字典（Map）：一个用键值对存储唯一值的数据结构，ES6 中的字典，名Map 树（Tree）：一种分层数据的抽象模型，JavaScript 中没有树，通过 Array 和 Object 构建树。 图（graph）：一种网络结构的抽象模型，是一组由边连接的节点，JavaScript 中没有图，通过 Array 和 Object 构建图。 堆（Heap）：一种特殊的完全二叉树，所有的节点大于等于（最大堆）或小于等于（最小堆）它的子节点，JavaScript 中没有堆，通过 Array 表示堆。 认识常见算法 链表的遍历、删除链表节点 树和图的深度/广度优先遍历 搜索排序 冒泡排序 选择排序 插入排序 归并排序 快速排序 顺序搜索 二分搜索 认识常见算法设计思想 分而治之 动态规划 贪心算法 回溯算法 最后，希望读者可以通过本篇文章对数据与结构有一定的认识和觉悟。。。。。。 ","link":"https://zhourengui.github.io/shu-ju-yu-jie-gou-suan-fa-jie-shao/"}]}