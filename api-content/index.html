{"posts":[{"title":"数据结构之链表","content":"本篇文章可以收获的知识： 什么是链表 链表的常用操作与数组的对比 四道LeetCode算法题巩固链表 如何分析时间复杂度和空间复杂度 详解JavaScript中的原型链 详解instanceof的原理 使用链表指针获取JSON 的节点值 什么是链表 链表是由多个元素组成的列表，元素存储是不连续的，元素之间用next指针连在一起，在JavaScript中没有链表，使用Object来模拟链表的功能。 链表的常用操作 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ const n1 = new ListNode(1) // 链表1 const n2 = new ListNode(2) // 链表2 const n3 = new ListNode(3) // 链表3 n1.next = n2 // 给n1链表，插入元素 n2.next = n3 // 给n2链表，插入元素 n1.next = n3 // 删除n2元素，一开始n1的指针指向n2的，让n1的指针指向n3就删除n2 // 遍历链表操作 // 思路 // 定义一个指针 // 循环遍历指针，访问当前指针，指针指向下一针，直到指针为空 let p = n1; while(p) { console.log(p.val) p = p.next; } 了解了链表的操作之后，我们会发现链表的新增元素和删除元素只需要修改某个指针就能实现需求，而数组在这些操作之后，需要移动元素来实现（除操作首尾元素），所以做增删操作的时候，链表的性能是比数据的性能高的。 LeetCode算法题：题号237，删除链表中的节点 其实这道题相对简单，做题人一开始的思路肯定是让传进来的node的上一个元素的next指向node的下一个元素就可以了，但是我们并不知道node的上一个元素，所以我们可以在node的下一个元素做文章。 解题思路： 不能拿到node的上一个元素，只能拿到node的下一个元素 将node的元素替换成node的下一个元素 解题步骤： 将node的下一个元素的值赋值给node 让node的下一个元素指向node的下下个元素 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} node * @return {void} Do not return anything, modify node in-place instead. */ var deleteNode = function(node) { node.val = node.next.val; node.next = node.next.next; }; 这道题因为没有循环体，没有额外的产生数据结构，所以时间复杂度和空间复杂度都是O(1)。 LeetCode算法题：题号206，反转链表 方法一，正向反转指针： 解题思路： 反转两个节点，将n+1的指针指向n 反转多个节点，重复上面的操作就能实现。 解题步骤： 一定一前一后指针，遍历链表 反转指针 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { let p1 = null; let p2 = head while(p2) { const tmp = p2.next; p2.next = p1; p1 = p2; p2 = tmp } return p1; }; 因为代码中有个while循环体，循环的次数是传进来的链表长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 方法二，反向反转指针： 解题思路： 反向反转指针，从链表的尾指针开始反转指针 这个场景非常适合递归来实现 解题步骤： 两个节点的反转，让当前指针的下下指针等于当前指针，然后将当前的下个指针等于null，解决闭环问题。 重复上一步骤 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { if (head === null || head.next === null) { return head; } const newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; }; 因为代码中是使用递归实现的，需要对链表的每个节点进行反转操作，所以时间复杂度是O(n)，n是链表的长度。 代码中虽然没有产生额外的数据结构，但是这里使用递归，递归的空间复杂度主要取决于递归调用栈的空间，也就是链表的长度，所以空间复杂度是O(n)。 LeetCode算法题：题号83，删除排序链表中的重复元素 解题思路： 给定的链表是有序的 当前指针的值等于下一指针的值时，删除下一个指针。 解题步骤： 遍历链表，当前指针的值等于下一指针的值时，将当前指针的指向下下个指针。 遍历结束后，返回链表的头部。 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { let p = head; while(p &amp;&amp; p.next) { if (p.val === p.next.val) { p.next = p.next.next; } else { p = p.next; } } return head; }; 因为代码中有个while循环体，循环的次数是链表的长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号141，环形链表 解题思路： 把这个场景想像成操场上跑步，跑的快的人，在某个时间会再遇到跑得快的人。 定义一快一慢指针，如果再某个时间两个指针能相遇，说明有环。 解题步骤： 定义一快一慢指针 如果在跑的过程在能遇到，返回true，如果快指针为null或者下一针为null，说明没有环，返回false 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { let slowP = head; let fastP = head; while(fastP &amp;&amp; fastP.next) { slowP = slowP.next; fastP = fastP.next.next; if (slowP === fastP) { return true; } } return false; }; 因为代码中有个while循环体，循环的次数最大的链表的长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 JavaScript中的原型链 原型 原型是实例对象的共有祖先，通俗的讲，构造函数有prototype属性，由这个构造函数构造出来的实例可以访问到prototype里的属性。 function Person() {} Person.prototype.name = &quot;nickname&quot; const p = new Person(); p.name; // nickname 原型链 原型链本质上是链表，通过__proto__属性进行连接，每个对象都有__proto__属性，如果访问的属性不存在的时候，会沿着对象的__proto__属性去寻找，直到为null，__proto__指向构造函数的prototype对象，也就是原型。 const n = Number(1) n.__proto__ = Number.prototype Number.prototype.__proto__ = Object.prototype Object.prototype.__proto__ = null const o = Object.create({}) o.__proto__ = Object.prototype Object.prototype.__proto__ = null // 数组、布尔、字符串也如此 ... ... ... Instanceof的原理 记住一句话，如果A instanceof B为true，说明在A的原型链上可以找到B的原型。 实现instanceof的代码： // 思路 // 定义一个指针 // 遍历A的原型链，如果A的原型链上有B的原型，返回true // 遍历完之后，说明找不到，但会false const coInstanceof = (A, B) =&gt; { let p = A while(p) { if (p.__proto__ === B.prototype) { return true } p = p.__proto__ } return false } 使用链表指针获取JSON的节点值 const json = { a: { b: { c: 1 } }, d: { e: 2 }, } const path = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; let p = json path.forEach(i =&gt; { p = p[i] console.log(`${i}：${JSON.stringify(p)}`) }) // 日志输出 // a: { b: { c: 1 } } // b: { c: 1 } // c: 1 最后，希望读者可以通过本篇文章对链表有一定的认识和觉悟。。。。。。 ","link":"https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-lian-biao/"},{"title":"数据结构之队列","content":"本篇文章可以收获的知识： 什么是队列 队列的常用操作 队列的使用场景 一道LeetCode算法题巩固队列 如何分析时间复杂度和空间复杂度 什么是队列 队列是一个先进先出的数据结构，JavaScirpt中没有队列，但可以使用Array实现队列的所有功能。 队列的常用操作 const queue = [] // 队列 queue.push(1) // 入队（enqueue） queue.shift() // 出队（dequeue） 队列的使用场景 食堂排队打饭 食堂排队打饭都不陌生，先排队的学生可以先打到饭，符合队列的特点。 JavaScript异步任务队列 JavaScript是单线程的，无法同时处理异步任务中的并发任务，使用任务队列先后处理异步任务 计算最近请求次数 一个请求队列[[], [1], [100], [3001], [3002]],计算[t-3000, t]的请求次数，首先新请求t先入队，不在这个区间的出队。后面也会通过一道LeetCode算法题巩固队列的知识。 遇到这些相似的问题，都可以优先考虑使用队列来解决问题。 LeetCode算法题：题号933，最近的请求次数 解题思路： 越早发出的请求，越靠前 符合先进先出的特点，考虑使用队列。 解题步骤： 新请求，入队 不在[t - 3000, t]区间内的成员出队 最后队列的长度就是最近的请求次数 代码实现： var RecentCounter = function() { this.q = []; }; /** * @param {number} t * @return {number} */ RecentCounter.prototype.ping = function(t) { this.q.push(t); while(t - 3000 &gt; this.q[0]) { this.q.shift(); } return this.q.length; }; /** * Your RecentCounter object will be instantiated and called as such: * var obj = new RecentCounter() * var param_1 = obj.ping(t) */ 分析时间复杂度和空间复杂度 因为代码中有个while循环体，循环的次数最大是ping的次数，所以时间复杂度是O(n)，n是ping的次数。 因为代码中用到了队列，最大的长度是3000，所以空间复杂度是O(n)，n最大是3000。 最后，希望读者可以通过本篇文章对队列有一定的认识和觉悟。。。。。。 ","link":"https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-dui-lie/"},{"title":"数据结构之栈","content":"本篇文章可以收获的知识： 什么是栈 栈的常用操作 栈的使用场景 一道LeetCode算法题巩固栈 如何分析时间复杂度和空间复杂度 什么是栈 栈是一个后进先出的数据结构，在JavaScript中没有栈，但是可以使用Array来实现栈的所有功能。 栈的常用操作 const stack = [] // 栈 stack.push(1) // 入栈 const item = stack.pop() // 出栈 栈的使用场景 十进制转二进制 可以从图中可以看到，我们如果按照顺序求出来的商是00111001，但是十进制转二进制得出来的结果是10011100，明显有后进先出的意思，所以遇到十进制转二进制的问题的时候，使用栈是最适合的。 有效的括号 在我们开发中经常也会用到括号，例如([])，这样的括号会发现，(是先进的，[是后进的，但是]是先出的，这就符合栈的后进先出的特点，所以遇到有效括号这类的问题的时候，使用栈是最合适的。后面也会通过一道有效的括号LeetCode算法题来巩固栈的知识。 函数调用堆栈 可以通过下面的代码进行断点进行调试，我们会发现我们先调用fn1，但是最后执行结束的是fn1 const fn1 = () =&gt; { fn2() } const fn2 = () =&gt; { fn3() } const fn3 = () =&gt; {} fn1() LeetCode算法题：题号20，有效的括号 解题思路： 对于没有闭合的左括号而言，越靠后的左括号，对应的右括号越靠前 满足后进先出的特点 解题步骤： 新建一个栈 判断字符串的长度是否是偶数，奇数直接判定为不合法 扫描字符串，遇到左括号入栈，遇到和栈顶括号类型匹配的右括号就出栈，类型不匹配直接判定为不合法 遍历结束后，栈为空代表合法，不为空代表不合法 代码实现： /** * @param {string} s * @return {boolean} */ var isValid = function(s) { if (s.length % 2 === 1) { return false; } const stack = []; const m = new Map(); m.set(&quot;(&quot;, &quot;)&quot;); m.set(&quot;{&quot;, &quot;}&quot;); m.set(&quot;[&quot;, &quot;]&quot;); for (let i = 0; i &lt; s.length; i ++) { if (m.has(s[i])) { stack.push(s[i]); } else { if (m.get(stack[stack.length - 1]) !== s[i]) { return false } stack.pop() } } return stack.length === 0; }; 分析时间复杂度和空间复杂度： 因为代码中有一个for循环，循环的次数可能是传进来的字符串长度，所以时间复杂度是O(n)，n就是传进来的字符串长度。 代码中定义了两个数据结构，Array和Map，因为Array并不会线性的增长所以是O(n)，Map是O(n)，所以最终的空间复杂度是O(n)，n是传进来的字符串长度。 最后，希望读者可以通过本篇文章对栈有一定的认识和觉悟。。。。。。 ","link":"https://github.com/zhourengui/zhourengui.github.io/shu-ju-jie-gou-zhi-zhan/"},{"title":"数据结构与算法介绍","content":"在学习数据结构与算法之前必须知道的几个概念： 什么是数据结构： 为了解决问题，会将数据用特定的方式存储起来，存储的方式不同就会导致不同的算法处理，当然我们希望算法的效率越快越好，那么我们就需要考虑数据如何保存，这就是数据结构。 通俗的讲数据结构就是计算机存储、组织数据的方式，就像是锅碗瓢盆，它们都是来存放东西的。 什么是算法： 一系列解决问题的清晰指令，就像是厨房里的食谱，有特定的制作教程，根据这个教程就可以做出相应的菜。 数据结构与算法的关系： 数据结构为算法提供服务，算法围绕数据结构操作。 如何判断一个算法是否可取 在作者身边的有一个真实的示例，一位后端工程师说：“昨天看到一个某某的算法，但是我觉得这个算法不太好...”。 这位后端工程师判断一个算法是否可行单凭直觉，这样的判断肯定是不可取的，正确的判断方式是通过时间复杂度和空间复杂度。 认识时间复杂度 时间复杂度，定性描述该算法的运行时间，通俗讲就是一个算法的循环次数。 时间复杂度的表示用一个函数 O 表示，比如 O(1)、O(n)、O(logN)...，表示时间复杂度的时候，不需要确却计算出这个数值。 两个时间复杂度相加时，取最大即可，例：O(1) + O(n) = O(n) 两个时间复杂度相乘时，相乘即可，例：O(n) * O(logN) = O(n * logN) 它们的关系是：n! &gt; 2^n &gt; n^2 &gt; nlogN &gt; n &gt; √n &gt; logN &gt; 1 认识空间复杂度 空间复杂度，对一个算法在运行过程中临时占用存储空间大小的度量。 空间复杂度的表示用一个函数 O 表示，比如 O(1)、O(n)、O(n^2)...。 认识每个数据结构 栈（Stack）：一个后进先出的数据结构，JavaScript 中并没有栈，通过 Array 来实现栈的功能，通过方法push、pop来实现入栈和出栈。 队列（Queue）：一个先进先出的数据结构，JavaScript 中没有队列，通过 Array 来实现队列的功能，通过方法push、shift来实现入队(enqueue)和出队(dequeue)。 链表（LinkedList）：一个由多个元素组成的列表，元素存储是不连续，通过next指针连在一起，JavaScript 中没有链表，通过 Object 来实现链表的功能。 集合（Set）：一个无序且唯一的数据结构，ES6 中的集合, 名Set。 字典（Map）：一个用键值对存储唯一值的数据结构，ES6 中的字典，名Map 树（Tree）：一种分层数据的抽象模型，JavaScript 中没有树，通过 Array 和 Object 构建树。 图（graph）：一种网络结构的抽象模型，是一组由边连接的节点，JavaScript 中没有图，通过 Array 和 Object 构建图。 堆（Heap）：一种特殊的完全二叉树，所有的节点大于等于（最大堆）或小于等于（最小堆）它的子节点，JavaScript 中没有堆，通过 Array 表示堆。 认识常见算法 链表的遍历、删除链表节点 树和图的深度/广度优先遍历 搜索排序 冒泡排序 选择排序 插入排序 归并排序 快速排序 顺序搜索 二分搜索 认识常见算法设计思想 分而治之 动态规划 贪心算法 回溯算法 最后，希望读者可以通过本篇文章对数据与结构有一定的认识和觉悟。。。。。。 ","link":"https://github.com/zhourengui/zhourengui.github.io/shu-ju-yu-jie-gou-suan-fa-jie-shao/"}]}