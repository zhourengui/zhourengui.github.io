{"posts":[{"title":"函数式编程","content":"前言： 函数式编程(Functional Programming)其实相对于计算机的历史 而言是一个非常古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 λ (Lambda x=&gt;x*2)演算，而 λ 演算并 非设计于在计算机上执行，它是在 20 世纪三十年代引入的一套用 于研究函数定义、函数应用和递归的形式系统。 函数式编程不是用函数来编程， 也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数。运算过程尽量写成一系列嵌套的函数调用。 函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、 行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。为什么函数式编程要求函数必须是纯的，不能有副作用?因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数 运算法则了。 函数式编程随着React的高阶函数的普遍使用慢慢在前端流行起来。 一. 特点 函数与其他数据类型一样， 可以赋值给其他变量，也可以是参数，传入另一个函数，或者是别的函数的返回值。 只用表达式，不用语句 没有副作用 不修改状态 函数运行只靠参数 二. 深入学习函数式编程 1. 纯函数 纯函数的特点 相同的输入，会得到相同的输出 没有任何的副作用 不依赖外部环境的状态 通过例子认识纯函数 // 举一个是纯函数的例子： const arr = [1, 2, 3, 4, 5] arr.slice(0, 3) // [1, 2, 3] arr.slice(0, 3) // [1, 2, 3] arr.slice(0, 3) // [1, 2, 3] arr.slice(0, 3) // [1, 2, 3] slice传入的相同的参数，输出都是相同的，没有任何的依赖，没有任何的副作用（arr数组没有变化），说明Array.ptototype.slice是个纯函数 // 举一个不是纯函数的例子： const minAge = 20 const checkAge = age =&gt; age &gt; minAge 由于checkAge方法依赖了minAge这个变量，所以checkAge不是纯函数，可以将checkAge修改成const checkage = age =&gt; age &gt; 20。 问题思考？ 假如需要另一个函数判断传入的年龄是否是大于21，大于22。。。 那不得不重写一个方法，这样一个最大的问题就是拓展性不好。下一节的柯里化函数可以得到答案。 2. 柯里化函数 ☝️上一节的答案 // 使用柯里化解决上一节的问题 const checkAge = min =&gt; (age =&gt; age &gt; min) const checkAge21 = checkAge(21) checkAge21(22) checkAge21(23) checkAge21(25) const checkAge22 = checkAge(22) checkAge21(22) checkAge方法与上一节的实现多了一层function, 从举的例子也不难看出，这样的定义非常的灵活，拓展性也非常好。 柯里化函数的特点 传递给函数一部分参数，返回另一个函数去处理剩下的参数 什么是柯里化 柯里化函数是一种“预加载”函数的方法，通过传递较少的参数，返回另一个函数，这个函数通过保留执行期的上下文（闭包）缓存了第一次传入的参数，是一种非常高效的编写函数的方法。 3. 函数组合 什么是函数组合 需要多个函数有顺序的处理得到的结果，把这些函数合并成一个函数就是函数组合。 通过例子认识函数组合 const compose = (...fns) =&gt; (...args) =&gt; { const fnLength = fns.length if (fnLength === 0) return arg =&gt; arg if (fnLength === 1) return fns[0](...args) return fns.reduce((pre, current = arg =&gt; arg) =&gt; (pre(current(...args)))) } function fn1(arr) { console.log(arr) } function fn2(arr) { return arr.splice(3) } compose(fn1)([1, 2, 3, 4]) 上面定义了一个compose方法，这个方法把传入的所有方法组合起来，方法调用顺序从右向左。 4. Point Free 什么是Point Free 对象自带的防范转化成纯函数，不要命名转瞬即逝的中间变量，这样说可能有点抽象，下面的例子说明的更清楚。 通过例子认识Point Free const f = str =&gt; str.toUpperCase().split(' ')这段代码使用了str作为中间变量，这个中间变量除了让代码变得长一点以外毫无意义。 我们可以使用函数组合进行修改 const toUpperCase = str =&gt; str.toUpperCase() const split = x =&gt; (str =&gt; str.split(x)) const f = compose(split(' '), toUpperCase) f(&quot;test string&quot;) 这样的编程可以减少不必要的命名，让代码保存简洁和通用。 5. 声明式与命令式代码 什么是声明式 通过编写一条有一条指令去让计算机执行一些操作 什么是命令式 通过写表达式的方式来声明要做声明 不是通过一步一步指示 通过例子认识声明式与命令式代码 // 命令式 const persons = [] for (let i = 0; i &lt; arr.length; i ++) { persons.push(arr[i]) } // 声明式 const persons = arr.map(p =&gt; p) 6. 惰性求值 什么是惰性求值 一种将对函数或请求处理延迟到真正需要结果时进行的通用概念。有很多应用程序都采用了这种概念，有的非常明显，有些则不太明显。从惰性编程的角度来思考问题，可以帮您消除代码中不必要的计算。 通过例子认识惰性求值 // 原生js封装ajax function ajax() { //1.创建xhr对象 //创建xhr对象 - 非IE6 if (window.XMLHttpRequest) { var xhr = new XMLHttpRequest(); } else { //IE6及其以下版本浏览器 var xhr = new ActiveXObject('Microsoft.XMLHTTP'); } ... } 上面通过原生js封装ajax理解惰性求值，如果我们上面不做任何的处理我们每次调用ajax这个方法的时候，方法内部都会做一次兼容处理，但是呢当第一次调用后，我们就知道了用户的浏览器是否支持ie，所以可以修改如下 // 原生js封装ajax function ajax() { //1.创建xhr对象 //创建xhr对象 - 非IE6 if (window.XMLHttpRequest) { var xhr = new XMLHttpRequest(); } else { //IE6及其以下版本浏览器 var xhr = new ActiveXObject('Microsoft.XMLHTTP'); } ajax = xhr } 通过这样修改后，当调用一次后ajax=xhr，当第二次调用的时候，就不用去重新判断兼容处理，这样可以提升性能。 7. 高阶函数 什么是高阶函数 函数当作参数，把传入的函数做一个封装，然后返回这个封装的函数，达到更高成都的抽象。 通过例子认识高阶函数 function add(x, y, fn) { return fn(x) + fn(y) } add(2, 3, (n) =&gt; n * n) 这就是一个简单的高级函数，只要一个函数接收一个函数作为参数， 这种函数就可以称之为高阶函数。 8. 尾递归（尾调用） 什么是尾递归 函数内部的最后一个动作是函数调用。该调用的返回值直接返回给函数。函数调用自身成为递归。如果尾调用自身，就成为尾递归。递归需要保存大量的调用记录, 很容易发生栈溢出错误，如果使用尾递归优化， 将递归变为循环， 那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。 通过例子认识尾递归（尾调用） // 斐波那契数列 正常递归 function factorial(n) { if (n === 1) return 1 return n * factorial(n - 1) } // 使用尾递归 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } 尾递归的优点 整个调用过程是线性的，调用一次后就会进入下一个栈，相关的数据信息跟随进入， 不保留在栈堆上，有效的防止堆栈溢出 9. 闭包 什么是闭包? 在某个块区域保留了父级以及父级以上的执行期上下文，这就是闭包，由于闭包网上有很多的资料，这里不做太多的赘述。 10. 容器（范畴）与函子（Funcctor） 什么是范畴 范畴就是容器，容器包含两样东西。值和值的变形关系（函数） 值的变形关系（函数）可以用于同一个容器的转换， 也可以用于将一个容器专程另一个容器。 什么是函子 函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。他首先是一种范畴，换句话说，函子也是容器，他也包含了容器的两样东西，只不过他的变形关系可以依次作用于每一个值，将当前的容器变形成另一个容器。 函子是一个对于函数调用的抽象， 赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选中何时何地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等特性。 通过例子认识函子 函子的特点 任何具有map方法的数据结构，都可以当作函子的实现。 函数式编程一般约定，函子（Functor）有一个of方法, 用来生成新 的容器。 函子（Functor）遵守一些特定规则的容器类型。 函子（Functor） 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等特性。 根据上面的特点用代码实现 class Functor { constructor(x) { this.__value = x } // 一般约定，函子的标志就是容器具有map方法。该方法将容器 里面的每一个值，映射到另一个容器。 map(f) { return Functor.of(f(this.__value)) } // 函数式编程一般约定，函子（Functor）有一个of方法 static of(x) { return new Functor(x) } } // 使用如下 Functor.of(2) .map(x =&gt; x + 1) // Functor(3) .map(x =&gt; x * 2) // Functor(6) 上面代码中，Functor是一个函子，它的map方法接受函数f作为 参数，然后返回一个新的函子，里面包含的值是被f处理过的 (f(this.val))。 函数式编程里面的运算，都是通过函子完成， 即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口(map方法)，各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。 11. Maybe函子 什么是Maybe函子 函子接受各种函数，处理容器内部的值。这里有一个问题，容器内部的值可能是一个空值，而外部函数未必有处理空值的机制，如果传入控制，很可能会报错。Maybe函子就是做这种预处理，让不管传入的值是什么都不会报错 通过例子认识Maybe函子 class Maybe { constructor(x) { this.__value = x } map(f) { return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value)) } isNothing() { return this.__value === null || this.__value === undefined } static of(x) { return new Maybe(x) } } 上面的例子map方法里多了一层判断，判断如果传进来的值是空的情况下不会去调用传进去的函数，因为空值没有任何的意义。 12. 错误处理 和 Either 什么是Either 程序中常用条件运算符if-else, 但是在函数式编程里面，Either函子内部有两个值：left（左值） 和right(右值)。右值是正常情况下使用的值，左值是右值不存在的时候使用的默认值。 通过例子认识Either class Either { constructor(left, right) { this.left = left this.right = right } map(f) { return this.right ? Either.of(this.left, f(this.right)) : Either.of(f(this.left), this.right) } static of(left, right) { return new Either(left, right) } } const add = x =&gt; x + 1 Either.of(1, 2).map(add) // Either(1, 3) Either.of(1, null).map(add) // Either(2, null) 上面的例子和普通函子不太一样的地方就是传入的值是两个，然后map方法通过判断右值是否存在，如果右值（正常值）存在的情况是作用于右值，不存在则作用域左值。这样就达到了错误处理的功能，在函数式编程是没有try-catch的，Either可以代替try-catch。 13. AP函子 什么是AP函子 函子里面包含的值是函数 通过例子认识AP函子 class Ap { constructor(x) { this.__value = x } ap(F) { return Ap.of(this.__value(F.__value)) } map(f) { return Ap.of(f(this.__value)) } static of(x) { return new Ap(x) } } Ap.of(x =&gt; x + 1).ap(Functor.of(2)) 上面的例子里的有个ap函数，它与map方法不同，因为Ap.of(x =&gt; x + 1)里__value是个方法，所以这种函子成为AP函子 14. IO 什么是IO 在我们真正编程的时候，不可能达到我们的预期，我们一定会有不纯的操作，比如（IO、网络请求、dom操作），我们可以把这些不纯的操作包裹到一个函数内。 普通的IO函子 class IO { constructor(f) { this.__value = f } // 与其他函子的不同之处就是map方法 map(f) { return IO.of(compose(f, this.__value)) // compose方法在前面的时候实现过 } static of(f) { return new IO(f) } } 15. Monad 什么是Monad Maybe、Either、IO这三个强大的Functor在链式调用、惰性求值、错误捕获、输入输出都发挥着巨大的作用。但是在我们开发的时候仍然有问题：1. 处理不了嵌套的Functor 2. 处理不了一个由非纯函数或者异步的操作序列。Monad可以解决这两个问题 Monad是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个操作。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。 Promise就是一种Monad。 Monad可以避开地狱嵌套，可以轻松地进行深度嵌套的函数式编程。 Monad的作用 Monad函子总是返回一个单层的函子，它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了嵌套函子，他会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。 flagMap方法接受一个f，里面会实行josin方法，为了保证这个方法总是返回一个单层的函子，这就意味着嵌套的函子会被扁平。 通过例子认识Monad函子 class Monad { constructor(x) { this.__value = x } map(f) { return Monad.of(f(this.__value)) } join() { return this.__value } flatMap(f) { return this.map(f).join() } static of(x) { return new Monad(x) } } Monad函子比普通的函子多了flatMap和join方法 Monad与IO实现文件操作 const fs = require(&quot;fs&quot;) const _ = require(&quot;lodash&quot;) // 第三方方法库 class Functor { constructor(x) { this.__value = x } map(f) { return Functor.of(f(this.__value)) } of(x) { return new Functor(x) } } class Monad extends Functor { join() { return this.__value } flatMap(f) { return this.map(f).join() } } class IO extends Monad { static of(__value) { return new IO(__value) } map(f) { // this.__value === print和读文件方法的组合后的方法 // _.flowRight是lodash实现compose方法 flowRight代表的是方法从右向左执行 return IO.of(_.flowRight(f, this.__value)) } // 继承过来的方法 运行的时候请把下面两个方法注释 为了好理解才把它复制过来 join() { // print和读文件方法的组合后的方法 return this.__value } flatMap(f) { // this.map(f) === IO(print和读文件方法的组合后的方法) // this.map(f).join() === print和读文件方法的组合后的方法 return this.map(f).join() } } const print = (x) =&gt; console.log(x) const readFile = (filePath) =&gt; IO.of(() =&gt; fs.readFileSync(filePath, &quot;utf8&quot;)) const result = readFile(&quot;目标文件&quot;) // IO(() =&gt; fs.readFileSync(filePath, &quot;uft-8&quot;)) .flatMap(print) // 组合后的方法 result() 已经把整个过程在代码中注释好了，请慢慢领悟下其中的奥秘。 ","link":"https://github.com/zhourengui/zhourengui.github.io/han-shu-shi-bian-cheng/"}]}