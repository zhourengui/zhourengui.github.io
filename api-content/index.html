{"posts":[{"title":"设计模式介绍","content":"设计模式介绍 设计模式是软件开发过程中面临的一般问题的解决方案，这些方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 在认识23种设计模式之前，需要知道什么是面向对象、UML类图、设计原则，因为设计模式最开始是通过面向对象语言总结出来的。 1、认识面向对象 1.1、面向对象和面向过程的区别 面向过程----步骤化：面向过程就是分析出现需求所需要的步骤，通过函数（方法）一步一步实现这些步骤。 面向对象----行为化：面向对象是把整个需求按照特点、功能划分，将这些存在共性的部分封装成类（类实例化后才是对象），创建了对象不是为了完成某一个步骤，而是描述某个事物在解决问题的步骤的行为。 1.2、面向对象和面向过程的优缺点 面向过程 优点：性能上比面向对象好，因为类在调用的时候需要实例化，开销大。 缺点：不容易维护、复用、拓展 应用：单片机、嵌入式开发、Linux/Unix等对性能要求较高的地方 面向对象 优点：易维护、易复用、易拓展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活。 缺点：性能低，类的实例化开销大。 1.3、面向对象的三大特征 封装（public、private、proteted） 减少耦合性，不该外露的不外露 利于数据、结构权限管理 继承（extends） 子类继承父类 多态（implements） 同一个接口不同实现 通过一段代码了解面向对象的三大特性 interface IUser { name: string; age: number; speak(): void; } // implements：People类实现IUser接口，这时候People类必须包含接口的属性和方法 // public：允许通过子类或者当前类的实例对象访问 // private: 只允许当前类访问，子类或者当前类的实例对象不可访问 // protected：只允许在类之前访问，实例对象不可访问 class People implements IUser { constructor(public name: string, public age: number, private weight: number) { } public speak(): void { console.error(`My name is ${this.name}, age ${this.age}`) } public getWeight(): void { console.error(this.weight) } } // extends: Student类继承父类People class Student extends People { constructor(public name: string, public age: number, private sWeight: number) { super(name, age, sWeight) } } const student = new Student(&quot;littleboy&quot;, 24, 50) student.age // 24 student.name // littleboy student.weight // 访问不到weight属性，因为private不允许实例访问 2、认识UML类图 2.1、什么是UML类图 类是具有相似结构、行为和关系的一组对象的描述符。类是面向对象系统中最重要的构造块。类图显示了一组类、接口、协作以及他们之间的关系。在UML中问题域最终要被逐步转化，通过类来建模，通过编程语言构建这些类从而实现系统。类加上他们之间的关系就构成了类图，类图中还可以包含接口、包等元素，也可以包括对象、链等实例。 2.2、如何画UML类图 // People中引用House，使用实心的箭头 // Student和Teacher继承People，使用空心的箭头 // public用+表示 // private用-表示 // protected用#表示 class House { constructor(public city: string, public price: number) { } } class People { constructor(public name: string, public house?: House) { } public sayHello(): void { console.error(`My name is ${this.name}`) } } class Student extends People { constructor(public name: string, public house?: House) { super(name, house) } public study(): void { } } class Teacher extends People { constructor(public name: string, public house?: House) { super(name, house) } public teacher(): void { } } 上面代码对应的UML类图是： 正常情况下，是先设计出UML类图再根据类图编写代码，这里为了方便理解，所以先看懂代码，再理解UML类图是如何画的。 3、两道面试题 3.1、第一题（画出UML类图和写出相应的代码） 1、打车时，可以打专车或者快车。任何车都有车牌号和名称。 2、不同车不同价格，快车每公里1元，专车每公里2元。 3、行程开始时，显示车辆信息 4、行程结束时，显示打车金额（假定行程就5公里） class Car { constructor(public carNo: string, public name: string) { } } class QuickCar extends Car { constructor(public carNo: string, public name: string, public perKPrice: number) { super(carNo, name) } } class SpecialCar extends Car { constructor(public carNo: string, public name: string, public perKPrice: number) { super(carNo, name) } } class Trip { public start(): void { console.error(`车牌号：${this.car.carNo}，车辆名称： ${this.car.name}。`) } public end(): void { console.error(`需付金额：${this.car.perKPrice * 5}`) } constructor(public car: QuickCar | SpecialCar) { } } const quickCar = new QuickCar(&quot;粤A&quot;, &quot;丰田&quot;, 1) const specialCar = new SpecialCar(&quot;粤C&quot;, &quot;本田&quot;, 2) const trip = new Trip(specialCar) trip.start() trip.end() 3.2、第二题（画出UML类图和写出相应的代码） 1、某停车场，分n层，每层n个车位 2、每个车位都能监控到车辆的驶入和离开 3、车辆进入前，显示每层的空余车位数量 4、车辆进入时，摄像头可识别车牌号和名称 5、车辆出来时，出口显示器显示车牌号和停车时长 interface IDist extends Car { inTime: number, lot: Lot } class Parking { public emptyLots: Array&lt;Lot&gt; = [] protected cars: { [key: string]: IDist } = {} constructor(public layers: Array&lt;Layer&gt;, public camera: Camera, public monitor: Monitor) { } public beforeEntry(): void { for (let i = 0; i &lt; layers.length; i++) { console.error(`${i}层空余车位数量：${layers[i].showEmptyNums()}`) this.emptyLots = [...this.emptyLots, ...layers[i].getEmptyLots()] } } public whenEntry(car: Car): void { this.camera.distinguish(car) this.cars[car.no] = { ...car, inTime: new Date().getTime(), lot: this.emptyLots[0] } this.emptyLots[0].entry() } public afterLeave(car: Car): void { this.monitor.show(car, this.cars[car.no].inTime) this.cars[car.no].lot.leave() delete this.cars[car.no] } } class Car { constructor(public no: string, public name: string) { } } class Lot { public isUsing: boolean = false public entry(): void { this.isUsing = true } public leave(): void { this.isUsing = false } } class Layer { constructor(public lots: Array&lt;Lot&gt;) { } public showEmptyNums(): number { return this.lots.reduce((t, c) =&gt; t + (c.isUsing ? 0 : 1), 0) } public getEmptyLots(): Array&lt;Lot&gt; { return this.lots.filter(l =&gt; !l.isUsing) } } class Camera { public distinguish(car: Car): void { console.error(`车牌号：${car.no}，车的名称：${car.name}`) } } class Monitor { public show(car: Car, inTime: number): void { console.error(`车牌号：${car.no}，停车时长：${new Date().getTime() - inTime}`) } } const car = new Car(&quot;粤A&quot;, &quot;五菱&quot;) const car1 = new Car(&quot;粤B&quot;, &quot;黑&quot;) const camera = new Camera() const monitor = new Monitor() const layers = [] for (let i = 0; i &lt; 10; i++) { const lots: Array&lt;Lot&gt; = [] for (let j = 0; j &lt; 100; j++) { lots.push(new Lot()) } layers.push(new Layer(lots)) } const parking = new Parking(layers, camera, monitor) parking.beforeEntry() parking.whenEntry(car) setTimeout(() =&gt; { parking.afterLeave(car) }, 3000) parking.beforeEntry() parking.whenEntry(car1) 输出： 0层空余车位数量：100 1层空余车位数量：100 2层空余车位数量：100 3层空余车位数量：100 4层空余车位数量：100 5层空余车位数量：100 6层空余车位数量：100 7层空余车位数量：100 8层空余车位数量：100 9层空余车位数量：100 车牌号：粤A，车的名称：五菱 0层空余车位数量：99 1层空余车位数量：100 2层空余车位数量：100 3层空余车位数量：100 4层空余车位数量：100 5层空余车位数量：100 6层空余车位数量：100 7层空余车位数量：100 8层空余车位数量：100 9层空余车位数量：100 车牌号：粤B，车的名称：黑 车牌号：粤A，停车时长：3002 4、设计原则 4.1、五大设计原则 4.1.1、 单一职责原则（Single） 一个程序制作好一件事 如果功能过于复杂就拆分开，每个部分保持独立 // UserSettings的功能就是设置，如果把验证的逻辑也放进UserSettings的话，违背了单一指责的原则，所以需要把验证的逻辑放到正确的位置 interface ISetting { } // Bad class UserSettings { constructor(public setting: ISetting) { } public changeSetting(setting: ISetting): void { if (this.verifyCredential()) { this.setting = setting } } public verifyCredential(): boolean { return true } } // Good class UserSettings { private auth: UserAuth = new UserAuth() constructor(public setting: ISetting) { } public changeSetting(setting: ISetting): void { if (this.auth.verifyCredential()) { this.setting = setting } } } class UserAuth { public verifyCredential(): boolean { return true } } 4.1.2、 开放封闭原则（Open Close） 对拓展进行开发，对修改封闭 增加需求时，拓展新代码，而非修改已有的代码 这是软件设计的终极目标 // 像第一种写法的HttpRequest，代码会出现很多逻辑都揉合到了一起，这种情况下不利于维护和拓展，并且有很多的if-else的字眼，而第二种完美的解决了第一种的问题 class Adapter { constructor(public name: AdapterType) { } public request&lt;T&gt;(): Promise&lt;T&gt; { return new Promise&lt;T&gt;(() =&gt; { }) } } enum AdapterType { BrowserAdapter, NodeAdapter } // Bad class BrowserAdapter extends Adapter { constructor() { super(AdapterType.BrowserAdapter) } } class NodeAdapter extends Adapter { constructor() { super(AdapterType.NodeAdapter) } } class HttpRequest { constructor(private adapter: Adapter) { } public fetch&lt;T&gt;(): Promise&lt;T&gt; { if (this.adapter.name === AdapterType.BrowserAdapter) { // 进行请求逻辑 return new Promise&lt;T&gt;(() =&gt; { }) } else if (this.adapter.name === AdapterType.NodeAdapter) { // 进行请求逻辑 return new Promise&lt;T&gt;(() =&gt; { }) } } } // Good class BrowserAdapter extends Adapter { constructor() { super(AdapterType.BrowserAdapter) } public request&lt;T&gt;(): Promise&lt;T&gt; { return new Promise&lt;T&gt;(() =&gt; { }) } } class NodeAdapter extends Adapter { constructor() { super(AdapterType.NodeAdapter) } public request&lt;T&gt;(): Promise&lt;T&gt; { return new Promise&lt;T&gt;(() =&gt; { }) } } class HttpRequest { constructor(private adapter: Adapter) { } public fetch&lt;T&gt;(): Promise&lt;T&gt; { return this.adapter.request&lt;T&gt;().then((res) =&gt; { return res }) } } const httpRequest = new HttpRequest(new BrowserAdapter()) 4.1.3、 李氏置换原则（Liskov Substitution） 子类能够覆盖父类 父类能出现的地方子类就能出现 // Bad class Rect { protected width: number = 0 protected height: number = 0 protected color: string public getArea(): number { return this.width * this.height } public setWidth(width: number) { this.width = width } public setHeight(height: number) { this.height = height } public setColor(color: string): void { this.color = color } public render(): void { } } class Square extends Rect { constructor() { super() } public setWidth(width: number) { this.width = width this.height = width } public setHeight(height: number) { this.width = height this.height = height } } // Good class Shape { protected color: string public setColor(color: string): void { this.color = color } public render(): void { } } class Rect extends Shape { private width: number = 0 private height: number = 0 public getArea(): number { return this.width * this.height } constructor() { super() } } class Square extends Shape { private width: number = 0 public getArea(): number { return this.width * this.width } constructor() { super() } } 4.1.4、 接口独立原则（Interface Segregation） 保持接口独立，避免出现胖接口 类似单一原则，这里更关注接口 interface Settings { rootNode: Element options: { [key: string]: any } } // Bad class DomTraverser { public rootNode: Element public setup(): void { this.rootNode = this.settings.rootNode this.settings.options.animationModule() } public traverse(): void { } constructor(public settings: Settings) { this.setup() } } const $1 = new DomTraverser({ rootNode: document.querySelector(&quot;#app&quot;), options: { animationModule() { } } }) // Good class DomTraverser { public rootNode: Element public options: { [key: string]: any } public setup(): void { this.rootNode = this.settings.rootNode this.setupOptions() } public setupOptions(): void { if (this.options.animationModule) { } } public traverse(): void { } constructor(public settings: Settings) { this.options = settings.options this.setup() } } const $1 = new DomTraverser({ rootNode: document.querySelector(&quot;#app&quot;), options: { animationModule() { } } }) 4.1.5、 依赖倒置原则（Dependence Inversion） 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口而不关注具体类的实现 abstract class GlobalRequester { abstract requestItem(...args): void } class InventoryRequester extends GlobalRequester { requestItem(item): void { } } class InventoryRequesterWS extends GlobalRequester { requestItem(item): void { } } // 库存查询的例子 // Bad // 这样做，InventoryTracker的请求写死在了类里，类里应该不关心具体哪个请求，而是关心我需要这么一个接口就行 class InventoryTracker { private requeser: InventoryRequester = new InventoryRequester() public requestItems(): void { for (let i = 0; i &lt; this.items.length; i++) { this.requeser.requestItem(this.items[i]) } } constructor(public items: Array&lt;string&gt;) { } } // new InventoryTracker([&quot;apple&quot;]).requestItems() // Good // 修改程下面的代码后，如果发送的请求是不一样的，下面的代码就能达到目的，而不需要去修改原有的代码 class InventoryTracker { public requestItems(): void { for (let i = 0; i &lt; this.items.length; i++) { this.requeser.requestItem(this.items[i]) } } constructor(public items: Array&lt;string&gt;, public requeser: GlobalRequester) { } } new InventoryTracker([&quot;apple&quot;], new InventoryRequester()) new InventoryTracker([&quot;apple&quot;], new InventoryRequesterWS()) 4.2、《UNIX/LINUX设计哲学》中的设计原则 4.2.1、大准则 小即是美 让每个程序只做一件事 快速建立原型（搭建基础功能后续迭代） 舍弃高效率而取可移植性 采用纯文本来存取数据 充分利用软件的杠杆效应（软件复用） 使用shell脚本来提高杠杆效应的可移植性 避免强制性的用户界面 让每个程序都成为过滤器 4.2.2、小准则 允许用户定制环境 尽量使操作系统内核小而轻量化 使用小写字母并简短 沉默是金 各部分之和大于整体 寻求90%的解决方案 5、认识23种设计模式 5.1、创建型模式 工厂模式（Factory Pattern） 单例模式（Abstract Factory Pattern） 原型模式（Prototype Pattern） 5.2、结构性模式 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 5.3、行为型模式 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） 后面的文章会详细的讲解每个设计模式是什么，如何使用，什么场景下适合使用。 最后，希望读者可以通过本篇文章对常用算法思想有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/she-ji-mo-shi-jie-shao/"},{"title":"常用算法思想","content":"本篇文章可以收获的知识： 什么是分而治之 什么是动态规划 什么是贪心算法 什么是回溯算法 九道LeetCode算法题巩固常用算法思想 如何分析时间复杂度和空间复杂度 分而治之 分而治之是一种算法设计思想，不是数据结构也不是一种算法，它将一个问题分成多个和原问题相似的小问题，再将结构合并以解决原来的问题。 在排序算法中，归并排序和快速排序使用的就是分而治之的思想，归并排序：分：把数组从中间一分为二，解：递归地对两个子数组进行排序，合：合并有序子数组，快速排序：分：选基准，按基准把数组分成两个子数组，解：递归地对两个子数组进行快速排序，合：对两个子数组进行合并。 动态规划 动态规划是一种算法设计思想，不是数据结构也不是一种算法，它将一个问题分解为相互重叠的子问题，通过反复求解子问题，来解决原来的问题。 使用动态规划解决斐波那契数列问题：1、定义子问题：F(n) = F(n - 1) + f(n - 2)，2、反复执行：从2循环到n，执行公示。 动态规划和分而治之的区别：子问题是独立的是分而治之，子问题是重叠的是动态规划。 贪心算法 贪心算法是一种算法设计思想，不是数据结构也不是一种算法，期盼通过每个阶段的局部最优选择，从而达到全局的最优，但是结果并不一定是最优的。 通过一个例子认识贪心算法： // 零钱兑换 const coins = [1, 2, 5] const amount = 11 // 11 = 5 + 5 + 1 // 输出的是3，这个时候的贪心算法满足最优结果 const coins = [1, 3, 4] const amount = 6 // 输出3 // 6 = 4 + 1 + 1 // 这时候贪心算法不是最优解 通过上面的例子，不难知道贪心算法得到的结果并不一定是最优解，但是并不能说贪心算法不能用，在某些场景下是可以使用贪心算法的，后面的算法题中会有贪心算法的解决方案。 回溯算法 回溯算法是一种算法设计思想，不是数据结构也不是一种算法，是一种渐进式寻找并构建问题解决方式的策略，会从一个可能的动作开始解决问题，如果不行，就会回溯并选择另一个动作，直到将问题解决。 什么问题适合用回溯算法：有很多路，这些路里，有死路，也有出路，通常需要递归来模拟所有的路。 通过文字理解算法思想有点难理解，下面通过算法题来深入了解算法思想的使用。 LeetCode算法题：题号100，相同的树 解题思路： 两个树：根结点相同，左子树相同，右子树相同 符合：“分、解、合”特性 考虑使用分而治之 解题步骤： 分：获取两个树的左子树和右子树 解：递归地判断两个树的左子树是否相同，右子树是否相同 合：将上述结果合并，如果根结点也相同，树就相同 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */ var isSameTree = function (p, q) { const isSame = (t1, t2) =&gt; { if (!t1 &amp;&amp; !t2) { return true } if ( t1 &amp;&amp; t2 &amp;&amp; t1.val === t2.val &amp;&amp; isSameTree(t1.left, t2.left) &amp;&amp; isSameTree(t1.right, t2.right) ) { return true } return false } return isSame(p, q) } 代码中使用了递归，递归的次数最大是树的节点树，所以时间复杂度是O(n)，n是树的节点树。 代码中虽然没有定义线性增长的数据结构，但是有递归，递归的堆栈最大是树的高度，树均匀分布的情况下是logn，所以空间复杂度是O(n)或者是O(logn)。 LeetCode算法题：题号101，对称二叉树 解题思路： 转化为：左子树和右子树是否镜像 分解为：左子树的左节点是否和右子树的右节点镜像并且左子树的右节点是否和右子树的左节点镜像 符合分、解、合特性，使用分而治之 解题步骤： 分：获取树的左子树和右子树 解：递归地判断左子树的左节点是否和右子树的右节点镜像并且左子树的右节点是否和右子树的左节点镜像 合：如果上述都成立，且根节点相同，两个树就镜像 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isSymmetric = function (root) { if (!root) { return true } const isMirror = (left, right) =&gt; { if (!left &amp;&amp; !right) { return true } if ( left &amp;&amp; right &amp;&amp; left.val === right.val &amp;&amp; isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left) ) { return true } return false } return isMirror(root.left, root.right) } 代码中使用了递归，递归的最大次数是树的节点树，所以时间复杂度是O(n)，n是树的节点树。 代码中虽然没有使用线性增长的数据结构，但是使用了递归，递归的调用堆栈最大是树的高度，树均匀分布的情况下是logn，所以空间复杂度是O(n)或者O(logn)。 LeetCode算法题：题号226，翻转二叉树 解题思路： 先翻转左右子树，再将子树换个位置 符合“分、解、合”特性 考虑使用分而治之 解题步骤： 分：获取左右子树 解：递归地翻转左右子树 将翻转后的左右子树换个位置放到根结点上 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {TreeNode} */ var invertTree = function (root) { if (!root) return null return { val: root.val, left: invertTree(root.right), right: invertTree(root.left), } } 代码中使用了递归，递归的最大次数是树的节点树，所以时间复杂度是O(n)，n是树的节点树。 代码中虽然没有使用线性增长的数据结构，但是使用了递归，递归的调用堆栈最大是树的高度，树均匀分布的情况下是logn，所以空间复杂度是O(n)或者O(logn)。 LeetCode算法题：题号70， 爬楼梯 解题思路： 第n阶可以在第n - 1阶爬1个台阶，或者在n - 2阶爬2个台阶 F(n) = F(n - 1) + F(n - 2) 使用动态规划 解题步骤： 定义子问题：F(n) = F(n - 1) + F(n - 2) 反复执行：从2循环到n，执行上述公式 代码实现： /** * @param {number} n * @return {number} */ var climbStairs = function (n) { if (n &lt;= 1) { return 1 } let dp0 = 0 let dp1 = 1 for (let i = 1; i &lt;= n; i++) { const tmp = dp0 dp0 = dp1 dp1 = tmp + dp1 } return dp1 } 代码中使用了for循环，循环的次数是n，所以时间复杂度是O(n)。 代码中没有用到线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号198，打家劫舍 实现思路： f(k) = 从前k个房屋中能偷窃到的最大金额 ak = 第k个房屋的金额 f(k) = Math.max(ak + f(k - 2), f(k - 1)) 考虑使用动态规划 解题步骤： 定义子问题：f(k) = Math.max(ak + f(k - 2), f(k - 1)) 反复执行：从数组的第二位循环到n，执行上述公式 代码实现： /** * @param {number[]} nums * @return {number} */ var rob = function (nums) { if (!nums.length) return 0 let dp0 = 0 let dp1 = nums[0] for (let i = 1; i &lt; nums.length; i++) { const dp2 = Math.max(nums[i] + dp0, dp1) dp0 = dp1 dp1 = dp2 } return dp1 } 代码中使用了for循环，循环的次数是数组的长度减2，所以时间复杂度是O(n)。 代码中没有用到线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号455，分发饼干 解题思路： 局部最优：既能满足孩子，还消耗的饼干最少 先将“较小的饼干”分给“胃口最小”的孩子 考虑使用贪心算法 解题步骤： 对饼干数组和胃口数组进行升序 遍历饼干数组，找到能满足胃口最小的孩子的饼干 遍历结束后返回返回结果 代码实现： /** * @param {number[]} g * @param {number[]} s * @return {number} */ var findContentChildren = function (g, s) { const sortFn = (a, b) =&gt; a - b g.sort(sortFn) s.sort(sortFn) let i = 0 s.forEach((n) =&gt; { if (n &gt;= g[i]) { i += 1 } }) return i } 代码中使用了foreach循环，循环的次数是饼干数组的长度，所以时间复杂度是O(n)。 代码中没有用到线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号122，买卖股票的最佳时机 II 解题思路： 前提：上帝视角，找到未来的价格 局部最优：见好就收，见差就不动，不做任何长远的打算 考虑使用贪心算法 解题步骤： 新建一个变量，用来统计总利润 遍历价格数组，如果当前价格比昨天高，就在昨天买，今天卖，否者不交易 遍历结束后返回总利润 代码实现： /** * @param {number[]} prices * @return {number} */ var maxProfit = function (prices) { let profit = 0 for (let i = 1; i &lt; prices.length; i++) { if (prices[i - 1] &lt; prices[i]) { profit += prices[i] - prices[i - 1] } } return profit } 代码中使用了for循环，循环的次数是数组的长度减1，所以时间复杂度是O(n)。 代码中没有用到线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号46，全排列 解题思路： 要求：1、所有排列情况，2、没有重复元素 有出路、有死路 考虑使用回溯算法 解题步骤： 用递归模拟出所有的情况 遇到包含重复元素的情况，就回溯 手机所有到达递归终点的情况，并返回 代码实现： /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { const res = [] const backtrack = (path) =&gt; { if (path.length === nums.length) { res.push(path) return } nums.forEach((c) =&gt; { if (path.includes(c)) { return } backtrack(path.concat(c)) }) } backtrack([]) return res } 代码中有foreach循环并且内嵌递归，正常不做return的情况下，时间复杂度是O(n^2)，但是由于重复元素不进行递归，所以会发现一个规律，每一个满足的元素进行1x2x3x4...n循环，所以时间复杂度是O(n!)。 代码中虽然没有使用线性增长的数据结构，但是使用了递归，递归的最大堆栈是数组的长度，所以空间复杂度是O(n)。 LeetCode算法题：题号78，子集 解题思路： 要求：1、所有子集，2、没有重复元素 有出路、有死路 考虑使用回溯算法 解题步骤： 用递归模拟所有情况 保证后面接的数字都是后面的数字 收集所有到达递归终点的情况，并返回 代码实现： /** * @param {number[]} nums * @return {number[][]} */ var subsets = function (nums) { const res = [] const backtrack = (path, l, s) =&gt; { if (path.length === l) { res.push(path) return } for (let i = s; i &lt; nums.length; i++) { backtrack(path.concat(nums[i]), l, i + 1) } } for (let i = 0; i &lt;= nums.length; i++) { backtrack([], i, 0) } return res } 代码中for循环嵌套递归，递归里面的时间复杂度是2n，因为每个元素只有存在和不存在的可能性，所以时间复杂度是O(n*2n)。 代码中使用到了递归，递归的堆栈大小是数组的大小，所以空间复杂度是O(n)。 最后，希望读者可以通过本篇文章对常用算法思想有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/chang-yong-suan-fa-si-xiang/"},{"title":"排序与搜索","content":"本篇文章可以收获的知识： 排序算法 冒泡排序的实现及分析 选择排序的实现及分析 插入排序的实现及分析 归并排序的实现及分析 快速排序的实现及分析 搜素算法 顺序搜索的实现及分析 二分搜索的实现及分析 两道LeetCode算法题巩固搜索与排序 如何分析时间复杂度和空间复杂度 排序算法 冒泡排序 // 实现思路 // 比较所有相邻，如果第一个比第二个大，则替换位置 // 一轮下来，可以保证最后一个数是最大的 // 执行n - 1轮就可以完成排序 // 时间复杂度是O(n ^ 2) Array.prototype.bubbleSort = function() { for (let i = 0; i &lt; this.length - 1; i++) { for (let j = 0; j &lt; this.length - 1 - i; j++) { if (this[j] &gt; this[j + 1]) { const tmp = currentItem this[j] = this[j + 1] this[j + 1] = tmp } } } } const arr = [5, 4, 3, 2, 1] arr.bubbleSort() 选择排序 // 实现思路 // 找到第一个最小的值，将它保存在第一位 // 找到第二个最小的值，将它保存在第二位 // 以此类推，执行n - 1轮之后，排序完成 // 时间复杂度是O(n ^ 2) Array.prototype.selectionSort = function () { for (let i = 0; i &lt; this.length - 1; i++) { let minIndex = i for (let j = i; j &lt; this.length; j++) { if (this[minIndex] &gt; this[j]) { minIndex = j } } if (i !== minIndex) { let tmp = this[minIndex] this[minIndex] = this[i] this[i] = tmp } } } const arr = [3, 1, 5, 9, 4] arr.selectionSort() 插入排序 // 插入排序相对于选择排序、冒泡排序来说，效率相对较高，但是还是不推荐在实际应用中使用 // 实现思路 // 从第二个往前比 // 前面比后面大的往后排 // 以此类推，执行n - 1轮之后，排序完成 // 时间复杂度是O(n ^ 2) Array.prototype.insertionSort = function () { for (let i = 1; i &lt; this.length; i++) { let tmp = this[i] let j = i while (j &gt; 0) { if (this[j - 1] &gt; tmp) { this[j] = this[j - 1] } else { break } j -= 1 } this[j] = tmp } } const arr = [3, 1, 5, 9, 4] arr.insertionSort() 归并排序 // 归并排序比冒泡排序、选择排序、插入排序的效率都高，而且归并排序是可以应用到实际的项目中的，火狐浏览器的sort算法使用的就是归并排序 // 实现思路 // 分：把数组分成两半，再递归地对子数组进行分操作，直到全部子数组分成一个个单独的数 // 合：把两个数合并为有序的数组，再对有序的数组进行合并，直到全部子数组合并为一个完整的数组 // 新建一个空数组res，用于存放最终排序后的数组 // 比较两个有序数组的头部，较小者出队并推入res中 // 如果两个数组还有值，重复上一步操作 // 分的时间复杂度是O(logn) // 合的时间复杂度是O(n) // 归并排序时间复杂度是O(nlogn) Array.prototype.mergeSort = function () { const rec = (arr) =&gt; { if (arr.length === 1) { return arr } const mid = Math.floor(arr.length / 2) const left = arr.slice(0, mid) const right = arr.slice(mid, arr.length) const orderLeft = rec(left) const orderRight = rec(right) const res = [] while (orderLeft.length || orderRight.length) { if (orderLeft.length &amp;&amp; orderRight.length) { res.push( orderLeft[0] &gt; orderRight[0] ? orderRight.shift() : orderLeft.shift() ) } else if (orderLeft.length) { res.push(orderLeft.shift()) } else if (orderRight.length) { res.push(orderRight.shift()) } } return res } const res = rec(this) res.forEach((v, k) =&gt; (this[k] = v)) } const arr = [3, 1, 5, 9, 4] arr.mergeSort() 快速排序 // 快速排序比冒泡排序、选择排序、插入排序的效率都高，而且快速排序是可以应用到实际的项目中的，曾经的Chrome的sort算法使用的是快速排序 // 实现思路 // 分区：从数组中任意选择一个“基准”，所有比基准小的元素放在基准前面，所有比基准大的元素放在基准后面 // 递归：递归地对基准前后的子数组进行分区 // 递归的时间复杂度：O(logn) // 分区操作的时间复杂度是O(n) // 快速排序的时间复杂度是：O(nlogn) Array.prototype.quickSort = function () { const rec = (arr) =&gt; { if ([0, 1].includes(arr.length)) return arr const left = [] const right = [] const mid = arr[0] for (let i = 1; i &lt; arr.length; i++) { const c = arr[i] c &gt; mid ? right.push(c) : left.push(c) } return [...rec(left), mid, ...rec(right)] } const res = rec(this) res.forEach((v, k) =&gt; (this[k] = v)) } const arr = [5, 3, 6, 2, 8, 0] arr.quickSort() 搜索算法 顺序搜索 // 实现思路 // 遍历数组 // 找到目标值相等的元素，就返回它的下标 // 遍历结束后，如果没有搜索到目标值，就返回-1 // 时间复杂度是O(n) Array.prototype.sequentialSearch = function (target) { for (let i = 0; i &lt; this.length; i++) { if (this[i] === target) { return i } } return -1 } [5, 3, 6, 2, 8, 0].sequentialSearch(3) 二分搜索 // 二分搜索（折半搜索），前提是这个数组是有序的 // 实现思路 // 从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束 // 如果目标值大于或小于中间元素，则在大于或小于中间元素的那一半数组中搜索 // 时间复杂度是O(logn) Array.prototype.binarySearch = function (target) { let low = 0 let high = this.length - 1 while (low &lt;= high) { const mid = Math.floor((low + high) / 2) const c = this[mid] if (c &gt; target) { high = mid - 1 } else if (c &lt; target) { low = mid + 1 } else { return mid } } return -1 } console.error([1, 2, 3, 4, 5].binarySearch(3)) // 2 LeetCode算法题：题号21，合并两个有序链表 解题思路： 与归并排序中合并两个有序数组很相似 将数组替换成链表即可 解题步骤： 新建一个新链表，作为返回结果 用指针遍历两个有序链表，并比较两个链表的当前节点，较小者先接入新链表，并将指针后移一步 遍历结束，返回新链表 代码实现： /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { let res = new ListNode(0) let p = n let p1 = l1 let p2 = l2 while(p1 &amp;&amp; p2) { if (p1.val &gt; p2.val) { p.next = p2 p2 = p2.next } else { p.next = p1 p1 = p1.next } p = p.next } if (p1) { p.next = p1 } if (p2) { p.next = p2 } return res.next }; 由于代码中使用了while循环，循环的最大次数是两个链表的数量之和，所以时间复杂度是O(n)，n是两个链表的数量之和。 由于代码中没有额外的使用线性增长的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号374，猜数字大小 解题思路： 这到题明显使用的二分算法解题 调用guess函数，来判断中间元素是否是目标值 解题步骤： 从数组中间元素取值，如果中间元素正好是目标值，则搜索结束 如果目标值大于或者小于中间元素，则在数组大于或小于中间元素的那一半搜索 代码实现： /** * Forward declaration of guess API. * @param {number} num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * var guess = function(num) {} */ /** * @param {number} n * @return {number} */ var guessNumber = function(n) { let low = 0; let high = n; while(low &lt;= high) { const mid = Math.floor((low + high) / 2); const ret = guess(mid) if (ret === -1) { high = mid - 1 } else if (ret === 1) { low = mid + 1 } else if (ret === 0) { return mid } } }; 代码中使用的是二分搜索，所以时间复杂度是O(logn)。 代码中没有使用到线性增长的数据结构，所以空间复杂度是O(1)。 最后，希望读者可以通过本篇文章对排序与搜索有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/pai-xu-yu-sou-suo/"},{"title":"数据结构之堆","content":"本篇文章可以收获的知识： 什么是堆 堆的使用场景 使用JavaScript构建堆 三道LeetCode算法题巩固堆 如何分析时间复杂度和空间复杂度 什么是堆 堆是一种特殊的完全二叉树，所有的节点都大于等于（最大堆）或者小于等于（最小堆）它的子节点，JavaScript通常使用数组表示堆，左侧子节点的位置是2 * index + 1，右侧子节点的位置是2 * index + 2，父节点位置是（index - 1）/ 2。 堆的使用场景 堆能高效、快速地找出最大值和最小值，时间复杂度是O(1)。 找出第K个最大(小)元素思路 构建一个推，并将元素依次插入堆中 当堆的容量超过K，就删除堆顶 插入结束后，堆顶就是第K个最大元素 使用JavaScript构建堆 // 最小堆 // 构建堆的思路 // 在类里声明一个数组，用来装元素 // 主要方法：插入、删除堆顶、获取堆顶、获取堆大小 class MinHead { constructor() { this.heap = [] } /** * 获取左节点索引 * @param {number} index */ getLeftIndex(index) { return index * 2 + 1 } /** * 获取右节点索引 * @param {number} index */ getRightIndex(index) { return index * 2 + 2 } /** * 获取堆顶 */ peek() { return this.heap[0] } /** * 获取堆大小 */ size() { return this.heap.length } /** * 交换元素 * @param {number} i1 * @param {number} i2 */ swap(i1, i2) { const tmp = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = tmp } /** * 获取父节点索引 * @param {number} index */ getParentIndex(index) { return (index - 1) &gt;&gt; 1 } /** * 将元素往上移 * @param {number} index */ shiftUp(index) { // 如果元素已到堆顶退出即可 // 获取父节点与当前节点进行比较，如果父节点大于当前节点，则进行交换，并递归 if (index === 0) return const parentIndex = this.getParentIndex(index) if (this.heap[parentIndex] &gt; this.heap[index]) { this.swap(parentIndex, index) this.shiftUp(parentIndex) } } /** * 插入方法 * @param {number} target */ insert(target) { // 将值插入到堆的底部，即数组的结尾 // 然后上移：将这个值与父节点进行交换，直到父节点小于等于插入的这个值 // 大小为K的堆中插入元素的时间复杂度是O(logK) this.heap.push(target) this.shiftUp(this.heap.length - 1) } /** * 下移元素 * @param {number} index */ shiftDown(index) { const leftIndex = this.getLeftIndex(index) const rightIndex = this.getRightIndex(index) if (this.heap[index] &gt; this.heap[leftIndex]) { this.swap(leftIndex, index) this.shiftDown(leftIndex) } if (this.heap[index] &gt; this.heap[rightIndex]) { this.swap(rightIndex, index) this.shiftDown(rightIndex) } } /** * 删除堆顶 */ pop() { // 使用数组的尾元素替换堆顶（直接删除堆顶会破坏堆的结构） // 然后下移操作：将新堆顶和他的子节点进行交换，直到新堆顶小于等于子节点 // 大小为K的堆下移操作的时间复杂度是O(logK) this.heap[0] = this.heap.pop() this.shiftDown(0) } } LeetCode算法题：题号215，数组中的第K个最大元素 解题思路： 看到第K个最大元素，考虑使用最小堆 解题步骤： 构建一个最小堆，并依次把数组的值插入到堆中 当堆的容量大于K时，就删除堆顶 插入结束后，返回堆顶，堆顶就是第K个最大元素 代码实现： class MinHead { constructor() { this.heap = [] } getLeftIndex(index) { return index * 2 + 1 } getRightIndex(index) { return index * 2 + 2 } peek() { return this.heap[0] } size() { return this.heap.length } swap(i1, i2) { const tmp = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = tmp } getParentIndex(index) { return (index - 1) &gt;&gt; 1 } shiftUp(index) { if (index === 0) return const parentIndex = this.getParentIndex(index) if (this.heap[parentIndex] &gt; this.heap[index]) { this.swap(parentIndex, index) this.shiftUp(parentIndex) } } insert(target) { this.heap.push(target) this.shiftUp(this.heap.length - 1) } shiftDown(index) { const leftIndex = this.getLeftIndex(index) const rightIndex = this.getRightIndex(index) if (this.heap[index] &gt; this.heap[leftIndex]) { this.swap(leftIndex, index) this.shiftDown(leftIndex) } if (this.heap[index] &gt; this.heap[rightIndex]) { this.swap(rightIndex, index) this.shiftDown(rightIndex) } } pop() { this.heap[0] = this.heap.pop() this.shiftDown(0) } } /** * @param {number[]} nums * @param {number} k * @return {number} */ var findKthLargest = function(nums, k) { const heap = new MinHead() for(let i = 0; i &lt; nums.length; i ++) { heap.insert(nums[i]) if (heap.size() === k + 1) { heap.pop() } } return heap.peek() }; 由于代码中使用了循环，并且在堆中插入或者删除堆顶的时候的有个递归，所以时间复杂度时O(n * logK)，n时数组的长度，K是堆的大小。 由于代码中使用了堆，堆的空间复杂度是O(n)，n是堆的大小。 LeetCode算法题：题号347，前K个高频元素 解题思路： 前K个高频元素，使用最小堆解决问题 解题步骤 构建一个最小堆，并依次把处理过的数据的值插入到堆中 当堆的容量大于K时，删除堆顶 遍历结束后返回处理后的堆 代码实现： class MinHead { constructor() { this.heap = [] } getLeftIndex(index) { return index * 2 + 1 } getRightIndex(index) { return index * 2 + 2 } peek() { return this.heap[0] } size() { return this.heap.length } swap(i1, i2) { const tmp = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = tmp } getParentIndex(index) { return (index - 1) &gt;&gt; 1 } shiftUp(index) { if (index === 0) return const parentIndex = this.getParentIndex(index) if ( this.heap[parentIndex] &amp;&amp; this.heap[parentIndex][1] &gt; this.heap[index][1] ) { this.swap(parentIndex, index) this.shiftUp(parentIndex) } } insert(target) { this.heap.push(target) this.shiftUp(this.heap.length - 1) } shiftDown(index) { const leftIndex = this.getLeftIndex(index) const rightIndex = this.getRightIndex(index) if (this.heap[leftIndex] &amp;&amp; this.heap[index][1] &gt; this.heap[leftIndex][1]) { this.swap(leftIndex, index) this.shiftDown(leftIndex) } if ( this.heap[rightIndex] &amp;&amp; this.heap[index][1] &gt; this.heap[rightIndex][1] ) { this.swap(rightIndex, index) this.shiftDown(rightIndex) } } pop() { this.heap[0] = this.heap.pop() this.shiftDown(0) } } /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var topKFrequent = function(nums, k) { const heap = new MinHead() const map = new Map() for (let i = 0; i &lt; nums.length; i++) { const c = nums[i] map.set(c, map.get(c) ? map.get(c) + 1 : 1) } map.forEach((value, key) =&gt; { heap.insert([key, value]) if (heap.size() === k + 1) { heap.pop() } }) return heap.heap.map((i) =&gt; i[0]) } 由于代码中使用了遍历了数组，所以时间复杂度是O(n)，n是数组的长度，在遍历的时候操作堆，在上移元素或者下移元素的操作中的时间复杂度是O(logK)，K是堆的大小，所以时间复杂度是O(n * logK)。 由于代码中使用了堆，所以空间复杂度是O(K)，K是堆的大小。 LeetCode算法题：题号23，合并k个排序链表 解题思路； 排序可以使用堆数据结构，由于这道题目是链表，所以在取出堆顶的时候，如果next不为空，则还需要将next插入的堆中 解题步骤： 构建一个最小堆，并依次把链头插入到堆中 弹出堆顶接到输出链表，并将堆顶所在链表的新链表头插入到堆中 等堆元素全部弹出，合并工作就完成了 代码实现： class MinHead { constructor() { this.heap = [] } getLeftIndex(index) { return index * 2 + 1 } getRightIndex(index) { return index * 2 + 2 } peek() { return this.heap[0] } size() { return this.heap.length } swap(i1, i2) { const tmp = this.heap[i1] this.heap[i1] = this.heap[i2] this.heap[i2] = tmp } getParentIndex(index) { return (index - 1) &gt;&gt; 1 } shiftUp(index) { if (index === 0) return const parentIndex = this.getParentIndex(index) if ( this.heap[parentIndex] &amp;&amp; this.heap[parentIndex].val &gt; this.heap[index].val ) { this.swap(parentIndex, index) this.shiftUp(parentIndex) } } insert(target) { this.heap.push(target) this.shiftUp(this.heap.length - 1) } shiftDown(index) { const leftIndex = this.getLeftIndex(index) const rightIndex = this.getRightIndex(index) if ( this.heap[leftIndex] &amp;&amp; this.heap[index].val &gt; this.heap[leftIndex].val ) { this.swap(leftIndex, index) this.shiftDown(leftIndex) } if ( this.heap[rightIndex] &amp;&amp; this.heap[index].val &gt; this.heap[rightIndex].val ) { this.swap(rightIndex, index) this.shiftDown(rightIndex) } } pop() { const t = this.heap.pop() if (this.size() === 0) { return } this.heap[0] = t this.shiftDown(0) } } /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode[]} lists * @return {ListNode} */ var mergeKLists = function(lists) { const heap = new MinHead() for (let i = 0; i &lt; lists.length; i++) { lists[i] &amp;&amp; heap.insert(lists[i]) } const ln = new ListNode(0) let p = ln while (heap.size() &gt; 0) { const t = heap.peek() p.next = t p = p.next heap.pop() if (t.next) { heap.insert(t.next) } } return ln.next } 由于代码中使用了while循环，循环的次数是所有链表的长度，时间复杂度是O(n)，在循环的过程在堆在进行上移或者下移的操作，时间复杂度是O(logK)，K是K个链表，所以最终时间复杂度是O(n * logK)。 由于代码中使用了堆数据结构，所以空间复杂度是O(n)，n是K个链表。 最后，希望读者可以通过本篇文章对堆有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-jie-gou-zhi-dui/"},{"title":"数据结构之图","content":"本篇文章可以收获的知识： 什么是图 图的常用操作 三道LeetCode算法题巩固图 如何分析时间复杂度和空间复杂度 什么是图 图是网络结构的抽象模型，是一组由边连接的节点，JavaScript中没有图，使用Object和Array构建图，图的表示法有领接矩阵、领接表（JavaScript中常用）、关联矩阵等，图可以表示二元关系比如：道路、航班等。 领接矩阵表示： 领接表表示： const graph = { A: [&quot;B&quot;, &quot;D&quot;], B: [&quot;E&quot;], C: [&quot;D&quot;], D: [&quot;E&quot;], E: [] } 图的常用操作 深度优先遍历 // 深度优先遍历思路 // 访问根节点 // 对根节点没访问过的相邻节点进行深度优先遍历 const graph = { A: [&quot;B&quot;, &quot;D&quot;], B: [&quot;E&quot;], C: [&quot;D&quot;], D: [&quot;E&quot;], E: [] } const set = new Set() const dfs = (root) =&gt; { set.add(root) console.log(graph[root]) // 访问根节点 graph[root].forEach(i =&gt; { if (!set.has(i)) { dfs(i) } }) } dfs(&quot;A&quot;) 广度优先遍历 // 广度优先遍历思路 // 新建一个队列，把根节点入队 // 把队头出队访问 // 把队头没访问过的相邻节点入队 // 重复二三步 const graph = { A: [&quot;B&quot;, &quot;D&quot;], B: [&quot;E&quot;], C: [&quot;D&quot;], D: [&quot;E&quot;], E: [] } const bfs = (root) =&gt; { const q = [root] const set = new Set() while(q.length) { const h = q.shift() set.add(h) console.log(graph[h]) graph[h].forEach(i =&gt; { if (!set.has(i)) { q.push(i) } }) } } bfs(&quot;A&quot;) LeetCode算法题：题号65，有效的数字 根据题目的要求，可以构建出下面的图，3、5、6是题目中所说的有效的数字 解题思路： 构建一个表示状态的图 遍历字符串，并沿着图走，如果到了某个节点无路可走，说明是个无效的数字，返回false 遍历结束后，如果状态在3、5、6的时候说明是有效的数字 代码实现： /** * @param {string} s * @return {boolean} */ var isNumber = function(s) { const graph = { 0: { &quot;black&quot;: 0, &quot;sign&quot;: 1, &quot;number&quot;: 6, &quot;.&quot;: 2 }, 1: { &quot;number&quot;: 6, &quot;.&quot;: 2 }, 2: { &quot;number&quot;: 3 }, 3: { &quot;e&quot;: 4, &quot;number&quot;: 3 }, 4: { &quot;number&quot;: 5, &quot;sign&quot;: 7 }, 5: { &quot;number&quot;: 5 }, 6: { &quot;number&quot;: 6, &quot;.&quot;: 3, &quot;e&quot;: 4 }, 7: { &quot;number&quot;: 5 } } let state = 0 for (let c of s.trim()) { if (c &gt;= 0 &amp;&amp; c &lt;= 9) { c = &quot;number&quot; } if ([&quot;+&quot;, &quot;-&quot;].includes(c)) { c = &quot;sign&quot; } if ([&quot;e&quot;, &quot;E&quot;].includes(c)) { c = &quot;e&quot; } state = graph[state][c] if (state === undefined) { return false } } return [3, 5, 6].includes(state) }; 由于代码用到了for循环，循环的次数最多是字符串的长度，所以时间复杂度是O(n)，n是字符串的长度。 由于代码中没有用到临时的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号417，太平洋大西洋水流问题 解题思路： 把矩阵想象成图 从海岸线逆流而上遍历图，所到之处就是可以流到某个大洋的坐标 解题步骤： 新建两个矩阵，分别记录能流到两个大洋的目标 从海岸线，同时深度优先遍历图，过程中填充矩阵 遍历两个矩阵，找出能流到两个大洋的坐标 代码实现： var pacificAtlantic = function(matrix) { if (!matrix || matrix.length === 0) { return [] } const m = matrix.length const n = matrix[0].length const flow1 = Array.from({ length: m }, () =&gt; Array.from({ length: n }, () =&gt; false) ) const flow2 = Array.from({ length: m }, () =&gt; Array.from({ length: n }, () =&gt; false) ) const dfs = (x, y, flow) =&gt; { flow[x][y] = true ;[ [x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1], ].forEach(([ix, iy]) =&gt; { if ( ix &gt;= 0 &amp;&amp; iy &gt;= 0 &amp;&amp; ix &lt;= m - 1 &amp;&amp; iy &lt;= n - 1 &amp;&amp; !flow[ix][iy] &amp;&amp; matrix[ix][iy] &gt;= matrix[x][y] ) { dfs(ix, iy, flow) } }) } for (let i = 0; i &lt; m; i++) { dfs(i, 0, flow1) dfs(i, n - 1, flow2) } for (let j = 0; j &lt; n; j++) { dfs(0, j, flow1) dfs(m - 1, j, flow2) } const res = [] for (let i = 0; i &lt; m; i++) { for (let j = 0; j &lt; n; j++) { if (flow1[i][j] &amp;&amp; flow2[i][j]) { res.push([i, j]) } } } return res } 由于代码中遍历了整个矩阵，所以空间复杂度是O(m * n)，m是矩阵的列数，n是矩阵的行数。 由于代码中使用了递归，调用的堆栈是m * n也就是堆栈的列数*行数，所以空间复杂度是O(m * n)。 LeetCode算法题：题号133，克隆图 解题思路： 拷贝所有的节点 解题步骤： 深度或者广度优先遍历所有节点 拷贝所有节点，存储起来 将拷贝的节点，按照原图的连接方法进行连接 代码实现： /** * // Definition for a Node. * function Node(val, neighbors) { * this.val = val === undefined ? 0 : val; * this.neighbors = neighbors === undefined ? [] : neighbors; * }; */ /** * @param {Node} node * @return {Node} */ var cloneGraph = function(node) { if (!node) { return } const q = [node] const map = new Map() map.set(node, new Node(node.val)) while(q.length) { const h = q.shift() ;(h.neighbors || []).forEach((i) =&gt; { if (!map.has(i)) { q.push(i) map.set(i, new Node(i.val)) } map.get(h).neighbors.push(map.get(i)) }) } return map.get(node) }; 由于代码中使用了while循环，循环的次数是节点数，所以时间复杂度是O(n)，n是节点的数量。 由于代码中使用了队列数据结构，最大的长度是节点数量，所以空间复杂度是O(n)，n是节点的数量。 最后，希望读者可以通过本篇文章对图有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-jie-gou-zhi-tu/"},{"title":"数据结构之树","content":"本篇文章可以收获的知识： 什么是树 树的常用操作 五道LeetCode算法题巩固树 如何分析时间复杂度和空间复杂度 什么是树 树是一种分层数据的抽象模型，在JavaScript中没有树，但是可以使用Array和Object构建树，前端工作中常见的树包括：Dom树、级联选择器、树形控件等。 树的常用操作 树的深度/广度遍历 // 构建一颗树 const tree = { value: &quot;A&quot;, children: [ { value: &quot;B&quot;, children: [ { value: &quot;D&quot;, children: [] }, { value: &quot;E&quot;, children: [] } ] }, { value: &quot;C&quot;, children: [ { value: &quot;F&quot;, children: [] }, { value: &quot;G&quot;, children: [] } ] } ] } 深度优先遍历：尽可能的搜索树的分支 // 深度优先遍历思路 // 访问根节点 // 遍历子节点，深度优先遍历子节点 const dfs = (root) =&gt; { console.log(root.value) // 访问根节点 dfs.children.forEach(i =&gt; dfs(i) } dfs(tree) 广度优先遍历：先访问离根节点最近的节点 // 广度优先遍历思路 // 新建一个队列 // 根节点入队 // 把队头出队并访问 // 将队头的子节点依次入队 // 重复最后两步 const bfs = (root) =&gt; { const q = [root] // 根节点入队 while(q.length) { const t = q.shift() // 队头出队 console.log(t.value) // 访问队头元素 t.children.forEach(i =&gt; q.push(i)) // 将对头的子节点依次入队 } } bfs(tree) 二叉树先中后序遍历（递归与非递归版） // 二叉树就是树中的每个节点最多只能有两个子节点 // 构建一颗二叉树 const binaryTree = { value: &quot;A&quot;, left: { value: &quot;B&quot;, left: { value: &quot;D&quot;, left: null, right: null }, right: { value: &quot;E&quot;, left: null, right: null } }, right: { value: &quot;C&quot;, left: { value: &quot;F&quot;, left: null, right: null, }, right: { value: &quot;G&quot;, left: null, right: null } } } 先序遍历 // 先序遍历思路 // 访问根节点 // 先序遍历根节点的左子树 // 先序遍历根节点的右子树 // 递归版 const preorder = (root) =&gt; { if (!root) return console.log(root.value) // 访问根节点 preorder(root.left) // 先序遍历根节点的左子树 preorder(root.right) // 先序遍历根节点的右子树 } preorder(binaryTree) // 非递归版 // 除了先序遍历的基本思路外，非递归版借用栈来实现 // 因为栈是后进先出的，所以入栈的时候我们需要先把右子树入栈，再左子树入栈 const preorder = (root) =&gt; { if (root) return const stack = [root] while(stack.length) { const p = stack.pop() console.log(p.value) // 访问根节点 stack.push(p.right) // 将根节点的右子树入栈 stack.push(p.left) // 将根节点的左子树入栈 } } preorder(binaryTree) 中序遍历 // 中序遍历的思路 // 中序遍历根节点的左子树 // 访问根节点 // 中序遍历根节点的右子树 // 递归版 const inorder = (root) =&gt; { if (root) return inorder(root.left) // 中序遍历根节点的左子树 console.log(root.value) // 访问根节点 inorrder(root.right) // 中序遍历根节点的右子树 } inorder(binaryTree) // 非递归版 // 除了中序遍历的思路外，非递归版借用栈来实现 // 定义一个指针，将指针的左子树入栈，直到指针为空，访问根节点，将指针赋值有指针 const inorder = (root) =&gt; { if (!root) return const stack = [] let p = root while(stack.length || p) { while(p) { // 中序遍历左子树 stack.push(p) p = p.left } const t = stack.pop() console.log(t.value) // 访问根节点 p = t.right // 中序遍历右子树 } } inorder(binaryTree) 后序遍历 // 后序遍历的思路 // 后序遍历根节点的左子树 // 后序遍历根节点的右子树 // 访问根节点 // 递归版 const postorder = (root) =&gt; { if (root) return postorder(root.left) // 后序遍历左子树 postorder(root.right) // 后序遍历左子树 console.log(root.value) // 访问根节点 } postorder(binaryTree) // 非递归版 // 出了后序遍历的思路外，非递归版借用栈来实现 // 因为最后访问的根节点，所以我们可以把所有的节点按照规则进栈后，再出栈访问 const postorder = (root) =&gt; { if (!root) return const stack = [root] const outputStack = [] while(stack.length) { const t = stack.pop() outputStack.push(t) if (t.left) { stack.push(t.left) } if (t.right) { stack.push(t.right) } } while(outputStack.length) { const t = outputStack.pop() console.log(t.value) } } postorder(binaryTree) LeetCode算法题：题号104，二叉树的最大深度 解题思路： 求最大深度，考虑使用深度优先遍历 在遍历的过程中，记录每个节点的层级，找出最大的层级 解题步骤： 使用深度优先遍历，遍历过程中，如果左子树和右子树为空时，记录该层级 遍历结束后返回最大层级 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { let max = 0 const dfs = (root, d) =&gt; { if (!root) return if (!root.left &amp;&amp; !root.right) { max = Math.max(m, d) } dfs(root.left, d + 1) dfs(root.right, d + 1) } dfs(root, 1) return m }; 因为代码中使用了递归，循环的次数是树的节点数，所以时间复杂度是O(n)，n是树的节点数。 因为代码中使用了递归，函数调用堆栈的大小可能是树的节点数或者是树的层级，所以空间复杂度是O(n)或者是O(logn)，n是树的节点数。 LeetCode算法题：题号111，二叉树的最小深度 解题思路： 求二叉树的最小深度，使用广度优先遍历 遇到叶子节点，停止遍历，返回当前层级 解题步骤： 使用广度优先遍历二叉度，并记录每一层的层数 遇到叶子节点，停止遍历返回当前层级 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var minDepth = function(root) { if (!root) return 0 const q = [[root, 1]] while(q.length) { const [n, d] = q.shift() if (!n.left &amp;&amp; !n.right) { return d } if (n.left) { q.push([n.left, d + 1]) } if (n.right) { q.push([n.right, d + 1]) } } }; 由于代码中有个while循环，循环的次数最大是树的节点数，所以时间复杂度是O(n)，n是树的节点数。 由于代码中用到了队列的数据结构，长度并不会线性的增长，最大长度是树的节点数，所以空间复杂度是O(n)，n是树的节点数。 LeetCode算法题：题号102，二叉树的层序遍历 解题思路： 层序遍历顺序就是广度优先遍历 不过遍历时需要记录当前节点所在的层级，目的是为了添加到数组中 解题步骤： 使用广度优先遍历二叉树 遍历过程中，记录每个节点的层级，并将其添加到不同的数组中 代码实现： /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function(root) { if (!root) { return [] } const q = [[root, 0]] const res = [] while(q.length) { const [n, d] = q.shift(); res[d] = res[d] ? [...res[d], n.val] : [n.val] if (n.left) { q.push([n.left, d + 1]) } if (n.right) { q.push([n.right, d + 1]) } } return res }; 由于代码中有个while循环，循环的次数是二叉树的节点数，所以时间复杂度是O(n)，n是二叉树的节点数。 由于代码中用到了队列的数据结构，长度并不会线性的增长，长度最大是二叉树的节点数，所以空间复杂度是O(n)，n是二叉树的节点数。 LeetCode算法题：题号94，二叉树的中序遍历 解题思路： 使用二叉树的中序遍历，在遍历过程中记录每个节点的值 解题步骤： 使用二叉树的中序遍历，把访问根节点修改成对应的逻辑即可 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var inorderTraversal = function(root) { if (!root) { return [] } const stack = [] let p = root const res = [] while(stack.length || p) { while(p) { stack.push(p) p = p.left } const t = stack.pop() res.push(t.val) p = t.right } return res }; 由于代码中使用while循环，循环的次数是二叉树的节点数，所以时间复杂度是O(n)，n是二叉树的节点数。 由于代码中用到了栈数据结构，长度不会线性增长，最大长度是二叉树的节点数，所以空间复杂度是O(n)，n是二叉树的节点数。 LeetCode算法题：题号112，路径总和 解题思路： 求路径总和，使用深度优先遍历 遍历过程中记录路径的总和 解题步骤： 使用深度优先遍历二叉树，记录路径的总和，如果是叶子节点并且总和与传入的目标值相等，结束循环。 代码实现： /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} targetSum * @return {boolean} */ var hasPathSum = function(root, targetSum) { if (!root) { return false } let res = false const dfs = (n, c) =&gt; { if (!n.left &amp;&amp; !n.right &amp;&amp; c === targetSum) { res = true return } if (n.left) { dfs(n.left, c + n.left.val) } if (n.right) { dfs(n.right, c + n.right.val) } } dfs(root, root.val) return res }; 由于代码使用递归，调用的次数最大是二叉树的节点数，所以时间复杂度是O(n)，n是二叉树的节点数。 由于代码使用递归，函数调用堆栈可能是二叉树的节点数，或者是二叉树的层级，所以空间复杂度是O(n)或者是O(logn)，n是二叉树的节点数。 最后，希望读者可以通过本篇文章对树有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-jie-gou-zhi-shu/"},{"title":"数据结构之字典","content":"本篇文章可以收获的知识： 什么是字典 字典的常用操作 三道LeetCode算法题巩固字典 如何分析时间复杂度和空间复杂度 什么是字典 字典与集合类似，字典也是一种存储唯一值的数据结构，但字典是以键值对的形式来存储，ES6中有字典，名为Map。 字典的常用操作 const m = new Map() // 字典 m.set(&quot;a&quot;, &quot;b&quot;) // 给字典添加元素 m.set(&quot;a&quot;, &quot;c&quot;) // 修改字典的某个元素 m.get(&quot;a&quot;) // 从字典中获取目标元素 m.delete(&quot;a&quot;) // 从字典中删除目标元素 m.clear() // 清空字典 LeetCode算法题：题号349，两个数组的交集 解题思路： 用字典建立一个映射关系，记录nums1的值 遍历nums2，找出nums1也有的值 解题步骤： 新建一个字典，遍历nums1，填充字典 遍历nums2，遇到字典里的值选出来，并从字典中删除 代码实现： /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function(nums1, nums2) { const nums3 = [] const m = new Map() nums1.forEach(i =&gt; m.set(i, true)) nums2.forEach(i =&gt; { if (m.get(i)) { nums3.push(i); m.delete(i) } }) return nums3; }; 因为代码中有个循环，循环次数是数组的长度，所以时间复杂度是O(n)，n是数组的长度。 因为代码中使用了map数据结构，长度最大是数组的长度，所以空间复杂度是O(n)，n是数组的长度。 LeetCode算法题：题号1，两数之和 解题思路： 把nums当成已婚人士（成员中可能有自己的对象，也有可能对象不在这个nums中）。 把target当成寻找自己对象的目标 用字典建立一个房间，存储已婚人士的值和下标 解题步骤： 用字典建立一个房间 遍历nums如果没有找到对象的保留在房间中，如果找到就结束 代码实现： /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { const m = new Map() for (let i = 0; i &lt; nums.length; i ++) { if (m.has(target - nums[i])) { return [m.get(target - nums[i]), i] } m.set(nums[i], i) } }; 因为代码有一个for循环体，循环次数最大是nums的长度，所以时间复杂度是O(n)，n是数组的长度。 因为代码中用到map数据结构，最大长度是数组的长度，所以空间复杂度是O(n)，n是数组的长度。 LeetCode算法题：题号3，无重复字符串的最长字串 解题思路： 找出所有没有重复的字符的子串 找出长度最大的那个子串，返回其长度 解题步骤： 用双指针维护一个滑动窗口，用来剪切子串 不断移动右指针，遇到重复字符，就把左指针移动到重复字符的下一位 过程中记录所有窗口的最大长度 代码实现： /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { let l = 0 let max = 0; const map = new Map() for (let r = 0; r &lt; s.length; r ++) { if (map.has(s[r]) &amp;&amp; map.get(s[r] &gt;= l)) { l = map.get(s[r]) + 1 } max = Math.max(max, r - l + 1) map.add(s[r], r) } }; LeetCode算法题：题号76，最小覆盖子串 解题思路： 找出所有覆盖的子串 返回最小的子串 解题步骤： 使用一前一后双指针维护一个窗口 不断的移动右指针，当窗口中包含目标子串的时候，移动左指针 当左指针对应的字符串在目标字符串中的时候，记录子串 代码实现： /** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { let l = 0 let m = new Map() let str = &quot;&quot; let type = 0 for (let i = 0; i &lt; t.length; i++) { m.set(t[i], 1) } for (let r = 0; r &lt; s.length; r++) { const c = s[r] if (m.has(c)) { m.set(c, m.get(c) - 1) m.get(c) === 0 &amp;&amp; (type += 1) } while (type === 3) { if (m.has(s[l])) { str = !str || r - l + 1 &lt; str.length ? s.substr(l, r + 1) : str m.set(s[l], m.get(s[l]) + 1) m.get(s[l]) === 1 &amp;&amp; (type -= 1) } l += 1 } } return str } 最后，希望读者可以通过本篇文章对字典有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-jie-gou-zhi-zi-dian/"},{"title":"数据结构之集合","content":"本篇文章可以收获的知识： 什么是集合 集合的使用场景 一道LeetCode算法题巩固集合 如何分析时间复杂度和空间复杂度 JavaScript中的集合 什么是集合 集合是一种无序且唯一的数据结构，ES6中的集合，名为Set 集合的使用场景 数组去重 const a1 = [1, 1, 2, 2, 3, 4, 5]; const a2 = [...new Set(a1)] 判断元素是否存在集合中 const s = new Set([1, 2, 3, 4]) s.has(1) // 返回boolean 求两个集合的交集 const s1 = new Set([1, 2, 3, 4]) const s2 = new Set([2, 3]) const s3 = new Set([...s1].filter(i =&gt; s1.has(i))) LeetCode算法题：题号349，两个数组的交集 解题思路： 求交集且唯一 使用集合 解题步骤： 使用集合对数组进行去重 遍历其中一个数据，判断另一个数据是否包含 实现代码： /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */ var intersection = function(nums1, nums2) { const s1 = new Set(nums1); const s2 = new Set(nums2); const res = [...s1].filter(i =&gt; s2.has(i)) return res }; 因为代码有用到了filter，每一个元素都要进行过滤，循环次数最大可能是nums1的长度乘以nums2的长度，所以时间复杂度是O(n * m)，n是nums1的长度，m是nums2的长度。 因为代码中用到了set数据结构，长度最大是两个数组中最大的长度，所以空间复杂度是O(n)，n是数组的长度。 这道LeetCode的算法题的最优解法是使用字典数据结构解决，在数据结构之字典文章中也会提及。 JavaScript中的集合 // JavaScript中集合的常用操作 const s = new Set() s.add(1) // 添加操作 s.delete(1) // 删除操作 s.size() // 获取集合的长度 s.has(1) // 判断集合中是否有当前元素 // JavaScript中集合的迭代 for(let item of m) {} for(let item of m.keys()) {} for(let item of m.values()) {} for(let [key, value] of m.entries()) {} // key === value // JavaScript中集合与数组互转 const a = Array.from(new Set([1, 2])) const s1 = new Set(a) 最后，希望读者可以通过本篇文章对集合有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-jie-gou-zhi-ji-he/"},{"title":"数据结构之链表","content":"本篇文章可以收获的知识： 什么是链表 链表的常用操作与数组的对比 四道LeetCode算法题巩固链表 如何分析时间复杂度和空间复杂度 详解JavaScript中的原型链 详解instanceof的原理 使用链表指针获取JSON 的节点值 什么是链表 链表是由多个元素组成的列表，元素存储是不连续的，元素之间用next指针连在一起，在JavaScript中没有链表，使用Object来模拟链表的功能。 链表的常用操作 /** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ const n1 = new ListNode(1) // 链表1 const n2 = new ListNode(2) // 链表2 const n3 = new ListNode(3) // 链表3 n1.next = n2 // 给n1链表，插入元素 n2.next = n3 // 给n2链表，插入元素 n1.next = n3 // 删除n2元素，一开始n1的指针指向n2的，让n1的指针指向n3就删除n2 // 遍历链表操作 // 思路 // 定义一个指针 // 循环遍历指针，访问当前指针，指针指向下一针，直到指针为空 let p = n1; while(p) { console.log(p.val) p = p.next; } 了解了链表的操作之后，我们会发现链表的新增元素和删除元素只需要修改某个指针就能实现需求，而数组在这些操作之后，需要移动元素来实现（除操作首尾元素），所以做增删操作的时候，链表的性能是比数据的性能高的。 LeetCode算法题：题号237，删除链表中的节点 其实这道题相对简单，做题人一开始的思路肯定是让传进来的node的上一个元素的next指向node的下一个元素就可以了，但是我们并不知道node的上一个元素，所以我们可以在node的下一个元素做文章。 解题思路： 不能拿到node的上一个元素，只能拿到node的下一个元素 将node的元素替换成node的下一个元素 解题步骤： 将node的下一个元素的值赋值给node 让node的下一个元素指向node的下下个元素 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} node * @return {void} Do not return anything, modify node in-place instead. */ var deleteNode = function(node) { node.val = node.next.val; node.next = node.next.next; }; 这道题因为没有循环体，没有额外的产生数据结构，所以时间复杂度和空间复杂度都是O(1)。 LeetCode算法题：题号206，反转链表 方法一，正向反转指针： 解题思路： 反转两个节点，将n+1的指针指向n 反转多个节点，重复上面的操作就能实现。 解题步骤： 一定一前一后指针，遍历链表 反转指针 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { let p1 = null; let p2 = head while(p2) { const tmp = p2.next; p2.next = p1; p1 = p2; p2 = tmp } return p1; }; 因为代码中有个while循环体，循环的次数是传进来的链表长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 方法二，反向反转指针： 解题思路： 反向反转指针，从链表的尾指针开始反转指针 这个场景非常适合递归来实现 解题步骤： 两个节点的反转，让当前指针的下下指针等于当前指针，然后将当前的下个指针等于null，解决闭环问题。 重复上一步骤 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { if (head === null || head.next === null) { return head; } const newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; }; 因为代码中是使用递归实现的，需要对链表的每个节点进行反转操作，所以时间复杂度是O(n)，n是链表的长度。 代码中虽然没有产生额外的数据结构，但是这里使用递归，递归的空间复杂度主要取决于递归调用栈的空间，也就是链表的长度，所以空间复杂度是O(n)。 LeetCode算法题：题号83，删除排序链表中的重复元素 解题思路： 给定的链表是有序的 当前指针的值等于下一指针的值时，删除下一个指针。 解题步骤： 遍历链表，当前指针的值等于下一指针的值时，将当前指针的指向下下个指针。 遍历结束后，返回链表的头部。 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { let p = head; while(p &amp;&amp; p.next) { if (p.val === p.next.val) { p.next = p.next.next; } else { p = p.next; } } return head; }; 因为代码中有个while循环体，循环的次数是链表的长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 LeetCode算法题：题号141，环形链表 解题思路： 把这个场景想像成操场上跑步，跑的快的人，在某个时间会再遇到跑得快的人。 定义一快一慢指针，如果再某个时间两个指针能相遇，说明有环。 解题步骤： 定义一快一慢指针 如果在跑的过程在能遇到，返回true，如果快指针为null或者下一针为null，说明没有环，返回false 代码实现： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { let slowP = head; let fastP = head; while(fastP &amp;&amp; fastP.next) { slowP = slowP.next; fastP = fastP.next.next; if (slowP === fastP) { return true; } } return false; }; 因为代码中有个while循环体，循环的次数最大的链表的长度，所以时间复杂度是O(n)，n是链表的长度。 因为代码中没有产生额外的数据结构，所以空间复杂度是O(1)。 JavaScript中的原型链 原型 原型是实例对象的共有祖先，通俗的讲，构造函数有prototype属性，由这个构造函数构造出来的实例可以访问到prototype里的属性。 function Person() {} Person.prototype.name = &quot;nickname&quot; const p = new Person(); p.name; // nickname 原型链 原型链本质上是链表，通过__proto__属性进行连接，每个对象都有__proto__属性，如果访问的属性不存在的时候，会沿着对象的__proto__属性去寻找，直到为null，__proto__指向构造函数的prototype对象，也就是原型。 const n = Number(1) n.__proto__ = Number.prototype Number.prototype.__proto__ = Object.prototype Object.prototype.__proto__ = null const o = Object.create({}) o.__proto__ = Object.prototype Object.prototype.__proto__ = null // 数组、布尔、字符串也如此 ... ... ... Instanceof的原理 记住一句话，如果A instanceof B为true，说明在A的原型链上可以找到B的原型。 实现instanceof的代码： // 思路 // 定义一个指针 // 遍历A的原型链，如果A的原型链上有B的原型，返回true // 遍历完之后，说明找不到，但会false const coInstanceof = (A, B) =&gt; { let p = A while(p) { if (p.__proto__ === B.prototype) { return true } p = p.__proto__ } return false } 使用链表指针获取JSON的节点值 const json = { a: { b: { c: 1 } }, d: { e: 2 }, } const path = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; let p = json path.forEach(i =&gt; { p = p[i] console.log(`${i}：${JSON.stringify(p)}`) }) // 日志输出 // a: { b: { c: 1 } } // b: { c: 1 } // c: 1 最后，希望读者可以通过本篇文章对链表有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-jie-gou-zhi-lian-biao/"},{"title":"数据结构之队列","content":"本篇文章可以收获的知识： 什么是队列 队列的常用操作 队列的使用场景 一道LeetCode算法题巩固队列 如何分析时间复杂度和空间复杂度 什么是队列 队列是一个先进先出的数据结构，JavaScirpt中没有队列，但可以使用Array实现队列的所有功能。 队列的常用操作 const queue = [] // 队列 queue.push(1) // 入队（enqueue） queue.shift() // 出队（dequeue） 队列的使用场景 食堂排队打饭 食堂排队打饭都不陌生，先排队的学生可以先打到饭，符合队列的特点。 JavaScript异步任务队列 JavaScript是单线程的，无法同时处理异步任务中的并发任务，使用任务队列先后处理异步任务 计算最近请求次数 一个请求队列[[], [1], [100], [3001], [3002]],计算[t-3000, t]的请求次数，首先新请求t先入队，不在这个区间的出队。后面也会通过一道LeetCode算法题巩固队列的知识。 遇到这些相似的问题，都可以优先考虑使用队列来解决问题。 LeetCode算法题：题号933，最近的请求次数 解题思路： 越早发出的请求，越靠前 符合先进先出的特点，考虑使用队列。 解题步骤： 新请求，入队 不在[t - 3000, t]区间内的成员出队 最后队列的长度就是最近的请求次数 代码实现： var RecentCounter = function() { this.q = []; }; /** * @param {number} t * @return {number} */ RecentCounter.prototype.ping = function(t) { this.q.push(t); while(t - 3000 &gt; this.q[0]) { this.q.shift(); } return this.q.length; }; /** * Your RecentCounter object will be instantiated and called as such: * var obj = new RecentCounter() * var param_1 = obj.ping(t) */ 分析时间复杂度和空间复杂度 因为代码中有个while循环体，循环的次数最大是ping的次数，所以时间复杂度是O(n)，n是ping的次数。 因为代码中用到了队列，最大的长度是3000，所以空间复杂度是O(n)，n最大是3000。 最后，希望读者可以通过本篇文章对队列有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-jie-gou-zhi-dui-lie/"},{"title":"数据结构之栈","content":"本篇文章可以收获的知识： 什么是栈 栈的常用操作 栈的使用场景 一道LeetCode算法题巩固栈 如何分析时间复杂度和空间复杂度 什么是栈 栈是一个后进先出的数据结构，在JavaScript中没有栈，但是可以使用Array来实现栈的所有功能。 栈的常用操作 const stack = [] // 栈 stack.push(1) // 入栈 const item = stack.pop() // 出栈 栈的使用场景 十进制转二进制 可以从图中可以看到，我们如果按照顺序求出来的商是00111001，但是十进制转二进制得出来的结果是10011100，明显有后进先出的意思，所以遇到十进制转二进制的问题的时候，使用栈是最适合的。 有效的括号 在我们开发中经常也会用到括号，例如([])，这样的括号会发现，(是先进的，[是后进的，但是]是先出的，这就符合栈的后进先出的特点，所以遇到有效括号这类的问题的时候，使用栈是最合适的。后面也会通过一道有效的括号LeetCode算法题来巩固栈的知识。 函数调用堆栈 可以通过下面的代码进行断点进行调试，我们会发现我们先调用fn1，但是最后执行结束的是fn1 const fn1 = () =&gt; { fn2() } const fn2 = () =&gt; { fn3() } const fn3 = () =&gt; {} fn1() LeetCode算法题：题号20，有效的括号 解题思路： 对于没有闭合的左括号而言，越靠后的左括号，对应的右括号越靠前 满足后进先出的特点 解题步骤： 新建一个栈 判断字符串的长度是否是偶数，奇数直接判定为不合法 扫描字符串，遇到左括号入栈，遇到和栈顶括号类型匹配的右括号就出栈，类型不匹配直接判定为不合法 遍历结束后，栈为空代表合法，不为空代表不合法 代码实现： /** * @param {string} s * @return {boolean} */ var isValid = function(s) { if (s.length % 2 === 1) { return false; } const stack = []; const m = new Map(); m.set(&quot;(&quot;, &quot;)&quot;); m.set(&quot;{&quot;, &quot;}&quot;); m.set(&quot;[&quot;, &quot;]&quot;); for (let i = 0; i &lt; s.length; i ++) { if (m.has(s[i])) { stack.push(s[i]); } else { if (m.get(stack[stack.length - 1]) !== s[i]) { return false } stack.pop() } } return stack.length === 0; }; 分析时间复杂度和空间复杂度： 因为代码中有一个for循环，循环的次数可能是传进来的字符串长度，所以时间复杂度是O(n)，n就是传进来的字符串长度。 代码中定义了两个数据结构，Array和Map，因为Array并不会线性的增长所以是O(n)，Map是O(n)，所以最终的空间复杂度是O(n)，n是传进来的字符串长度。 最后，希望读者可以通过本篇文章对栈有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-jie-gou-zhi-zhan/"},{"title":"数据结构与算法介绍","content":"在学习数据结构与算法之前必须知道的几个概念： 什么是数据结构： 为了解决问题，会将数据用特定的方式存储起来，存储的方式不同就会导致不同的算法处理，当然我们希望算法的效率越快越好，那么我们就需要考虑数据如何保存，这就是数据结构。 通俗的讲数据结构就是计算机存储、组织数据的方式，就像是锅碗瓢盆，它们都是来存放东西的。 什么是算法： 一系列解决问题的清晰指令，就像是厨房里的食谱，有特定的制作教程，根据这个教程就可以做出相应的菜。 数据结构与算法的关系： 数据结构为算法提供服务，算法围绕数据结构操作。 如何判断一个算法是否可取 在作者身边的有一个真实的示例，一位后端工程师说：“昨天看到一个某某的算法，但是我觉得这个算法不太好...”。 这位后端工程师判断一个算法是否可行单凭直觉，这样的判断肯定是不可取的，正确的判断方式是通过时间复杂度和空间复杂度。 认识时间复杂度 时间复杂度，定性描述该算法的运行时间，通俗讲就是一个算法的循环次数。 时间复杂度的表示用一个函数 O 表示，比如 O(1)、O(n)、O(logN)...，表示时间复杂度的时候，不需要确却计算出这个数值。 两个时间复杂度相加时，取最大即可，例：O(1) + O(n) = O(n) 两个时间复杂度相乘时，相乘即可，例：O(n) * O(logN) = O(n * logN) 它们的关系是：n! &gt; 2^n &gt; n^2 &gt; nlogN &gt; n &gt; √n &gt; logN &gt; 1 认识空间复杂度 空间复杂度，对一个算法在运行过程中临时占用存储空间大小的度量。 空间复杂度的表示用一个函数 O 表示，比如 O(1)、O(n)、O(n^2)...。 认识每个数据结构 栈（Stack）：一个后进先出的数据结构，JavaScript 中并没有栈，通过 Array 来实现栈的功能，通过方法push、pop来实现入栈和出栈。 队列（Queue）：一个先进先出的数据结构，JavaScript 中没有队列，通过 Array 来实现队列的功能，通过方法push、shift来实现入队(enqueue)和出队(dequeue)。 链表（LinkedList）：一个由多个元素组成的列表，元素存储是不连续，通过next指针连在一起，JavaScript 中没有链表，通过 Object 来实现链表的功能。 集合（Set）：一个无序且唯一的数据结构，ES6 中的集合, 名Set。 字典（Map）：一个用键值对存储唯一值的数据结构，ES6 中的字典，名Map 树（Tree）：一种分层数据的抽象模型，JavaScript 中没有树，通过 Array 和 Object 构建树。 图（graph）：一种网络结构的抽象模型，是一组由边连接的节点，JavaScript 中没有图，通过 Array 和 Object 构建图。 堆（Heap）：一种特殊的完全二叉树，所有的节点大于等于（最大堆）或小于等于（最小堆）它的子节点，JavaScript 中没有堆，通过 Array 表示堆。 认识常见算法 链表的遍历、删除链表节点 树和图的深度/广度优先遍历 搜索排序 冒泡排序 选择排序 插入排序 归并排序 快速排序 顺序搜索 二分搜索 认识常见算法设计思想 分而治之 动态规划 贪心算法 回溯算法 最后，希望读者可以通过本篇文章对数据与结构有一定的认识和觉悟。。。。。。 ","link":"http://localhost:4000/shu-ju-yu-jie-gou-suan-fa-jie-shao/"}]}